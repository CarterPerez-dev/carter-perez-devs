This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: package-lock.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/
  API/
    AI.py
  helpers/
    about_me.txt
    port.py
  routes/
    portfolio.py
  app.py
  Dockerfile.backend
  requirements.txt
frontend/
  public/
    vite.svg
  src/
    animations/
      dataFlowAnimation.js
      glitchAnimation.js
      neonPulseAnimation.js
    components/
      3d/
        CyberCity.jsx
        HoloProfile.jsx
        ParticleNetwork.jsx
      common/
        CircuitLines.jsx
        CyberLoader.jsx
        DataStream.jsx
        GlitchText.jsx
        HolographicCard.jsx
        NeonButton.jsx
        ParticleGridBackground.jsx
      layout/
        AmbientBackground.jsx
        DigitalFooter.jsx
        HolographicNav.jsx
      sections/
        AITerminal.jsx
        ContactPortal.jsx
        HeroSection.jsx
        HolographicTimeline.jsx
        ProjectsGrid.jsx
        ResumeHologram.jsx
        TechStackGalaxy.jsx
    contexts/
      AudioContext.jsx
      ThemeContext.jsx
    hooks/
      useAudio.js
      useDataStream.js
      useGlitch.js
      useHolographicEffect.js
    styles/
      animations.css
      base.css
      cyberpunk.css
      glitch.css
      holographic.css
      neon.css
      reset.css
      responsive.css
    utils/
      3dUtils.js
      glitchUtils.js
      terminalCommands.js
    App.jsx
    index.css
    main.jsx
  .gitignore
  Dockerfile.dev
  eslint.config.js
  index.html
  package.json
  README.md
  vite.config.js
nginx/
  sites-enabled/
    reverse_proxy.conf
  nginx.conf
.gitignore
docker-compose.yaml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/API/AI.py">
import os
import logging
from openai import OpenAI
from dotenv import load_dotenv


load_dotenv()


logger = logging.getLogger(__name__)
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)


def load_api_key() -> str:
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        logger.error("OpenAI API key is missing. Please ensure it's set in the environment variables.")
        raise ValueError("OpenAI API key is required but not found.")
    return api_key


api_key = load_api_key()
client = OpenAI(api_key=api_key)
</file>

<file path="backend/helpers/about_me.txt">
Carter Rush Perez - About Me
Personal Background
My name is Carter Rush Perez, and I am 21 years old. I was born on October 2nd, 2003, in Washington, D.C. My favorite color is black. I am a native English speaker and speak Spanish conversationally. I live in Annapolis and reside alone in an apartment, which provides me with a quiet and focused environment for both work and personal projects. I have two sisters who are an integral part of my life, fostering a strong sense of family and camaraderie. Additionally, I have grandparents who have greatly influenced my values and work ethic. I own two white cats named Iggy and Rose, who bring joy and companionship to my home.

Physical Fitness
I maintain an active lifestyle with a focus on strength training and overall fitness. I weigh 150 pounds and have achieved significant milestones in my fitness journey:

Bench Press: 275 lbs
Squat: 300 lbs
Deadlift: 400 lbs
My long-term gym goals include benching 315 lbs, squatting 500 lbs, and deadlifting 600 lbs. In addition to weightlifting, I enjoy swimming as part of my fitness regimen, which helps improve my cardiovascular health and overall endurance. My dedication to fitness not only enhances my physical well-being but also reinforces my discipline and resilience in other areas of life.

Education
I am currently attending the University of Maryland Global Campus, where I am pursuing a master's degree in Cybersecurity. My academic journey has been marked by competitiveness and a strong commitment to long-term success. Balancing multiple jobs, such as working at Jimmy John's and DoorDash, has honed my time management skills and taught me the value of hard work and perseverance. My coursework and hands-on projects have provided me with a solid foundation in cybersecurity principles, risk management, and technical implementation.

Professional Experience
I work at Sealing Technologies as a System Integration Technician II, a position I have held for eight months. In this role, I focus on building and configuring custom cybersecurity and defense systems, ensuring they meet client needs and perform reliably under demanding conditions. My responsibilities include system assembly, optimization, testing, and maintenance, as well as collaborating with cross-functional teams to deliver comprehensive solutions. This experience has deepened my expertise in system integration, cybersecurity best practices, and client relations.

Certifications
I hold seven CompTIA certifications:

CompTIA A+
CompTIA Network+
CompTIA Security+
CompTIA CySA+
CompTIA PenTest+
CompTIA CASP+
PCEP (Certified Entry-Level Python Programmer)
I achieved these certifications within nine months, dedicating an average of two weeks of study time for each. Some tips that helped me include watching Professor Messer's tutorials, using ChatGPT to enhance understanding, employing the PQR method, and maintaining confidence throughout the process. These certifications have significantly enhanced my technical skills and prepared me for advanced roles in cybersecurity and system integration.

Technical Skills
Cybersecurity
Risk Assessment
Threat Mitigation
Compliance with ISO 27001 and 9001:2015
Role-Based Access Controls
Encryption Best Practices
Incident Response Planning
Networking
TCP/IP, DNS, DHCP
Firewalls (UFW, iptables)
Secure Network Configurations
SSH Encryption
AWS Networking (Route 53, CloudFront)
Virtual Private Networks (VPNs)
Cloud Computing
AWS Security Ecosystem (EC2, S3, WAF, Shield, ACM, CloudWatch, EventBridge)
Securing S3 Buckets
TLS/SSL Implementation with AWS Certificate Manager
Cloud Resource Optimization
Programming and Development
Languages: Python, JavaScript, HTML, CSS, Shell Scripting, Regex, Perl
Frameworks and Tools: React, Flask, MongoDB, Docker, Nginx, Apache
Web Development: Proficient in developing dynamic and interactive web applications
API Development and Integration
Virtualization
Docker Containers
VMware, Hyper-V, VirtualBox
Kubernetes Basics
Log Analysis
Splunk (SIEM)
Advanced Log Processing
Debugging and Troubleshooting
Operating Systems
Linux (Ubuntu, Red Hat)
Windows
MacOS
System Hardening and Security
DevOps/DevSecOps
CI/CD Pipelines
Container Orchestration
Multi-Stage Builds
System Scalability
Infrastructure as Code (IaC)
Automation Tools
Celery
Redis Caching
Ansible Basics
Data Analysis
Root Cause Analysis
AI-Powered Insights for Cybersecurity Logs
Data Visualization Techniques
Compliance & Governance
NIST, COBIT, GDPR, HIPAA, ITIL Frameworks
Policy Development and Implementation
Audit Preparation and Management
Leadership & Management Skills
Training and Leading Teams (10+ Members)
Streamlining Operational Workflows for Improved Efficiency
Customer Service Protocols and Satisfaction Strategies
Managing Technical Operations Across Multiple Locations
Project Management and Coordination
Soft Skills
Problem-Solving and Troubleshooting
Adaptability in High-Pressure Environments
Effective Communication and Collaboration
Continuous Learning and Skill Development
Critical Thinking and Analytical Skills
Tools & Software
Splunk (SIEM)
AWS Console
Docker Compose
GitHub
Nginx, Apache
Cloud Monitoring and Reporting with AWS CloudWatch
Office Tools: Microsoft Office Suite, Google Workspace
IDEs and Code Editors: Visual Studio Code, PyCharm
Miscellaneous Skills
Public Speaking: Presented at ISSA UMBC on CompTIA certifications
Writing: Technical documentation and blogs
Organizing and Leading Cybersecurity Workshops and Simulations
Time Management and Organizational Skills
Projects and Achievements
Professional Projects
ProxyAuthRequired.com: A centralized cybersecurity platform integrating AI-driven simulations and learning modules. Features include GRC Wizard for compliance questions, Log Analysis for real-time practice, and scenario-based exercises for incident response. This project showcases my ability to design and implement comprehensive cybersecurity solutions that address various aspects of threat management and compliance.
Personal Projects
AutoApplication: An automated application bot for Indeed and LinkedIn, streamlining the job application process. This tool leverages web automation and scripting to enhance efficiency in job searching, demonstrating my proficiency in programming and automation.
Cyber Labs: Hands-on labs for penetration testing and system hardening, providing practical training environments for cybersecurity enthusiasts. This project highlights my commitment to education and skill development in the cybersecurity field.
Key Achievements
Fitness: Bench pressing 225 lbs
Certifications: Completed the CompTIA Cybersecurity Path within nine months
Web Development: Created my own website, showcasing my technical and design skills
Blog Creation: Wrote a blog for my company, sharing insights and knowledge in cybersecurity
Interests and Hobbies
Outside of work and academics, I enjoy a variety of activities that keep me engaged and motivated:

Working Out: Strength training and swimming are integral parts of my fitness routine, helping me stay physically and mentally sharp.
Cliff Jumping: An exhilarating outdoor activity that provides an adrenaline rush and a break from the daily grind.
Programming: Developing projects and learning new technologies fuels my passion for innovation and problem-solving.
Cybersecurity: Continuously learning and enhancing my skills in the field to stay ahead of emerging threats and technologies.
Reading: My favorite book is "48 Laws of Power," which offers valuable insights into strategy and leadership.
Gaming: Enjoy watching shows like "Mr. Robot," "Game of Thrones," "Succession," and "Ozark," which inspire my strategic thinking and appreciation for complex narratives.
Goals and Aspirations
Professional Goals
Short-Term: Expand my knowledge in DevOps, DevSecOps, and AWS to enhance my cybersecurity expertise. I aim to take on more complex projects and leadership roles within my current position.
Long-Term: Transition into a security-focused role such as Cybersecurity Analyst, GRC Manager, CTO, CISO, or Cybersecurity Engineer. I aspire to lead initiatives that protect organizations from cyber threats and drive strategic security planning.
Fitness Goals
Bench Press: Achieve 315 lbs and eventually 405 lbs
Squat: Reach 500 lbs
Deadlift: Accomplish a 600 lb lift
Endurance: Improve my swimming techniques and increase my overall stamina
Academic Goals
Education: Complete my master's degree in Cybersecurity at the University of Maryland Global Campus, focusing on advanced security protocols and threat intelligence.
Continued Learning: Pursue additional certifications in areas like AWS Security Specialty and Certified Ethical Hacker (CEH) to broaden my expertise.
Personal Philosophy and Values
I believe in being confident and taking accountability for my actions. My work ethic is defined by dedication and a commitment to long-term success rather than short-term wins. I strive to think outside the box and excel in problem-solving. Continuous learning and self-improvement are integral to my personal and professional growth.

Motivation
I stay motivated by keeping busy and listening to music, particularly phonk music, which energizes me during workouts and study sessions. Enhancing my cognitive abilities using methods inspired by Andrew Huberman also drives my productivity and focus, allowing me to maintain a high level of performance in all my endeavors.

Core Values
Confidence: Believing in my abilities and taking initiative to achieve my goals.
Accountability: Owning my actions and learning from mistakes to foster personal and professional growth.
Integrity: Maintaining honesty and strong moral principles in all aspects of life.
Perseverance: Persisting through challenges and setbacks to achieve long-term success.
Continuous Improvement: Always seeking ways to enhance my skills and knowledge.
Favorite Tools and Technologies
I enjoy using a variety of tools and technologies that enhance my productivity and effectiveness:

Operating Systems: Linux (Ubuntu, Red Hat) for its efficiency and flexibility; Windows and MacOS for their unique capabilities.
Cloud Platforms: AWS Console for managing cloud resources and deploying scalable applications.
Containerization: Docker Compose for orchestrating containerized applications.
Version Control: GitHub for collaborative coding and version management.
Web Servers: Nginx and Apache for hosting and serving web applications.
Monitoring Tools: AWS CloudWatch for tracking application performance and health.
Development Tools: Visual Studio Code and PyCharm for writing and debugging code.
Automation Tools: Celery and Redis for managing asynchronous tasks and caching.
Security Tools: Splunk (SIEM) for log analysis and threat detection.
Inspirations
I am inspired by individuals who exemplify resilience, discipline, and continuous growth:

David Goggins: His relentless pursuit of excellence and mental toughness motivates me to push my limits and overcome challenges.
Andrew Huberman: His work on enhancing cognitive abilities and optimizing performance inspires me to adopt effective strategies for personal and professional development.
Favorite Quote
"Comparison is the thief of joy." This quote reminds me to focus on my own journey and accomplishments rather than comparing myself to others, fostering a positive and self-motivated mindset.

Blog and Content Creation
I have written a blog for my company, sharing insights and knowledge in the field of cybersecurity. Through my blog, I aim to educate others on best practices, emerging threats, and innovative solutions. Additionally, I enjoy writing technical documentation and organizing cybersecurity workshops and simulations to educate and train aspiring professionals. These activities allow me to contribute to the cybersecurity community and stay engaged with the latest industry developments.

ProxyAuthRequired.com - Project Overview
Real-World Scenario Explorer
Offers industry-specific scenarios to mimic real-world cybersecurity incidents. Users can adjust variables like threat intensity, attack types, and skill levels. Examples include ransomware attacks, phishing campaigns, and SQL injection breaches. This tool provides practical, hands-on experience for users to understand and respond to various cyber threats effectively.

Analogies Playground
Breaks down complex cybersecurity concepts into relatable analogies (e.g., video games, mythology, pop culture). Tailored to varying learning styles for enhanced comprehension, this feature helps users grasp intricate ideas by connecting them to familiar contexts.

Attack vs. Defense Strategy Simulator
Provides interactive simulations of offensive (Red Team) and defensive (Blue Team) tactics. Users can role-play attackers or defenders to understand both perspectives, fostering a deeper understanding of cybersecurity strategies and the importance of proactive defense mechanisms.

Log Analysis Generator
Integrates Splunk for SIEM log generation and analysis. Supports real-time interpretation of logs from security, event, error, debug, and info types. Provides AI-powered insights to assist with root cause analysis and identifying threat indicators, enabling users to efficiently monitor and respond to security events.

Incident Response Simulator
Interactive training module for handling cybersecurity incidents, including data breaches and ransomware. Encourages users to practice containment, eradication, and recovery steps in controlled environments, enhancing their ability to manage and mitigate real-world security incidents.

GRC Trainer
Guides users through Governance, Risk, and Compliance frameworks. Generates dynamic questions for practice on topics like HIPAA, GDPR, PCI DSS, and ISO 27001. This module ensures users are well-versed in essential compliance standards and best practices.

Daily Cyber Learning Emailer
Sends daily educational content, such as cybersecurity acronyms, real-world scenarios, and exam tips. This feature keeps users engaged and continuously learning, reinforcing their knowledge and preparing them for certifications and real-world applications.

Cybersecurity Resource Hub
Centralizes study guides, technical blogs, YouTube tutorials, and certification objectives (e.g., CompTIA). Features curated resources for tools, frameworks, and best practices, providing a comprehensive repository for users to enhance their cybersecurity skills and knowledge.

ScenarioSphere
Hosts over 2,000 simulated cyberattacks and vulnerabilities for training purposes. Includes guided walkthroughs and mitigation techniques for each attack vector, offering extensive hands-on experience to users seeking to improve their defensive and offensive cybersecurity skills.

XploitCraft Customization Suite
Supports over 400 simulated attack scenarios, including SQL injection and XSS. Users can create, deploy, and practice custom attacks with step-by-step guides for execution, mitigation, and prevention, allowing for personalized and advanced cybersecurity training.

Threat Intelligence Dashboard
Aggregates real-time cybersecurity news, emerging threats, and vulnerability alerts. Includes daily threat briefings and exam preparation tips, ensuring users stay informed about the latest developments in the cybersecurity landscape.

Backend Infrastructure
Technology Stack: Python (Flask for backend server), MongoDB for storing user profiles, logs, GRC questions, and configurations, Celery and Redis for distributed task queues, Flask-SocketIO for live updates and interactions, Nginx (reverse proxy), and Apache for backend support.
Key Backend Features: AI-Powered Modules using OpenAI GPT models for generating analogies, scenarios, and cybersecurity explanations; Log Analysis API for processing logs and providing detailed insights; Scenario API for creating tailored cybersecurity scenarios; Daily Cyber Brief API for aggregating news, threat intelligence, and cybersecurity updates.
Frontend Infrastructure
Technology Stack: React.js for building a dynamic and interactive UI, styled with a dark, hacker-themed design featuring neon highlights in pink and turquoise. Incorporates loading spinners, visual effects, and a responsive UI for a seamless user experience.
Frontend Features: Interactive modules with dropdowns, sliders, and buttons to control scenario intensity, attack types, and training preferences; responsive design optimized for desktops, tablets, and mobile devices; real-time feedback through visual elements like notifications for user interactions and API responses; comprehensive resource pages detailing certifications, tools, and educational content.
Deployment and Security
AWS Infrastructure: Hosted on AWS EC2 instances (Debian 12), S3 bucket for asset storage and secure backups, AWS CloudFront for content delivery and caching, AWS WAF and Shield for web app security, and AWS Certificate Manager for SSL/TLS encryption.
Security Measures: Role-based access controls, SSL/TLS encryption with AWS Certificate Manager, firewall rules to protect critical data, and compliance with ISO 9001:2015 and ISO 27001 standards to ensure robust security and reliability.
Key Statistics
User Base: Over 1,000 active monthly users engaging in cybersecurity training.
Uptime: 99.9%, supported by CloudFront and Shield for DDoS mitigation.
Training Content: Features over 400 attack scenarios and 2,000+ exercises, providing extensive training opportunities for users.
Key Achievements
Built a secure, scalable platform leveraging Docker containers and multi-stage builds.
Integrated advanced log analysis and compliance tools for real-world training.
Created an educational hub tailored for CompTIA certifications and cybersecurity skill-building.
Successfully launched multiple interactive modules that enhance user engagement and learning outcomes.
Future Enhancements
Threat Intelligence Dashboard Expansion: Adding more real-time analytics and tracking tools to provide deeper insights into emerging threats.
Cyber Labs: Developing hands-on labs for penetration testing and system hardening to offer practical training environments.
Enhanced Logging: Implementing interactive graphs for data visualization and tracking threat patterns more effectively.
AI-Powered Bots: Automating job applications and providing industry-specific training insights through intelligent bots, further enhancing user experience and efficiency.
Additional Context for AI Assistant
Personality Traits
Ambitious: Driven to achieve both personal and professional goals, always striving for improvement.
Detail-Oriented: Pays close attention to details, ensuring accuracy and quality in all tasks.
Resilient: Capable of bouncing back from setbacks and maintaining focus on long-term objectives.
Curious: Continuously seeks to learn new things and expand knowledge, especially in technology and cybersecurity.
Adaptable: Easily adjusts to new environments and challenges, thriving in dynamic settings.
Work Habits
Proactive: Takes initiative to identify and solve problems before they escalate.
Collaborative: Enjoys working in teams, valuing diverse perspectives and collective problem-solving.
Time Management: Efficiently balances multiple responsibilities, ensuring deadlines are met without compromising quality.
Continuous Learner: Regularly updates skills and stays informed about the latest industry trends and technologies.
Interests and Preferences
Technology Enthusiast: Passionate about emerging technologies, especially in AI, cloud computing, and cybersecurity.
Gaming: Enjoys strategy-based games that challenge critical thinking and planning skills.
Outdoor Activities: Finds relaxation and excitement in activities like hiking and cliff jumping.
Music Lover: Prefers phonk music for its unique beats and motivational qualities during workouts and study sessions.
Reading: Interested in books that offer strategic insights and personal development, beyond just "48 Laws of Power."
Motivations
Professional Growth: Motivated by opportunities to advance in the cybersecurity field and take on leadership roles.
Personal Development: Strives to enhance both technical and soft skills to become a well-rounded professional.
Helping Others: Enjoys sharing knowledge through blogs and workshops, aiming to educate and inspire others in cybersecurity.
Communication Style
Clear and Concise: Prefers straightforward communication, avoiding unnecessary jargon.
Open-Minded: Receptive to feedback and new ideas, fostering an environment of continuous improvement.
Supportive: Encourages and mentors peers and team members, promoting a collaborative work culture.
Problem-Solving Approach
Analytical: Breaks down complex problems into manageable components for effective resolution.
Creative: Utilizes innovative thinking to develop unique solutions to challenges.
Strategic: Plans and executes tasks with a focus on long-term success and sustainability.
Lifestyle
Healthy Living: Maintains a balanced lifestyle with regular exercise and a focus on physical well-being.
Independent: Comfortable managing personal responsibilities and making decisions autonomously.
Organized: Keeps a structured approach to both personal and professional tasks, ensuring efficiency and effectiveness.
Future Aspirations
Leadership Roles: Aspires to lead cybersecurity teams and drive strategic initiatives within an organization.
Innovative Projects: Interested in developing cutting-edge cybersecurity tools and platforms that address emerging threats.
Global Impact: Aims to contribute to the cybersecurity field on a global scale, enhancing security measures and practices worldwide.
Additional Skills
Public Speaking: Confident in presenting ideas and leading discussions in both formal and informal settings.
Technical Documentation: Skilled in creating clear and comprehensive technical documents and guides.
Event Organization: Experienced in planning and executing cybersecurity workshops and simulation exercises.
I am white
I know leon tang
My favorite food are pasture raised eggs
</file>

<file path="backend/helpers/port.py">
# port.py
import os
import logging
from API.AI import client

logger = logging.getLogger(__name__)

class PortfolioAssistant:
    def __init__(self):
        # Find the current file's directory
        dir_path = os.path.dirname(os.path.realpath(__file__))
        file_path = os.path.join(dir_path, "about_me.txt")
        
        # Read the biography from a file
        with open(file_path, "r", encoding="utf-8") as f:
            self.about_text = f.read()

        logger.info("PortfolioAssistant initialized. Biography length: %d", len(self.about_text))

    def ask_about_me(self, question: str, stream: bool = False):
        system_message = (
            "You are an AI assistant who knows everything about Carter. "
            "Use the following info to answer any questions about me:\n\n"
            f"{self.about_text}\n\n"
            "Answer concisely make up info using the context from the text if not provided above. So if the info is not in the text about me, make it up relative to what you might think is true based on the text using context from about_text, So if there are yes or no answers, answer yes to things that present me in a good light, and no fro anything that presents me in a bad light. Make sure you answer any question that is asked whether you know the answer or not- if you do not know the answer then make something up."
        )

        if stream:
            return self._streaming(system_message, question)
        else:
            return self._single_response(system_message, question)

    def _single_response(self, system_message: str, user_question: str):
        try:
            res = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": user_question}
                ],
                max_tokens=500,
                temperature=0.5
            )
            answer = res.choices[0].message.content.strip()
            logger.debug("Single-response answer: %s", answer)
            return answer
        except Exception as e:
            logger.error("Error generating single response: %s", e)
            raise

    def _streaming(self, system_message: str, user_question: str):
        try:
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": user_question}
                ],
                max_tokens=500,
                temperature=0.5,
                stream=True
            )
            for chunk in response:
                if chunk.choices:
                    delta = chunk.choices[0].delta
                    chunk_content = getattr(delta, "content", None)
                    if chunk_content:
                        yield chunk_content
        except Exception as e:
            logger.error("Error during streaming: %s", str(e))
            yield f"[Error during streaming: {str(e)}]"
</file>

<file path="backend/routes/portfolio.py">
import logging
from flask import Blueprint, request, jsonify, Response
from helpers.port import PortfolioAssistant

logger = logging.getLogger(__name__)

# Create a Blueprint instance
portfolio_bp = Blueprint('portfolio_bp', __name__)

# Instantiate the assistant
assistant = PortfolioAssistant()

@portfolio_bp.route('/ask_about_me', methods=['POST'])
def ask_about_me():
    """
    POST /ask_about_me
    Body: {
      "question": "some question about Carter",
      "stream": true or false (optional)
    }
    """
    data = request.get_json() or {}
    question = data.get('question')
    stream_requested = data.get('stream', False)

    if not question:
        logger.error("No 'question' provided in request body.")
        return jsonify({"error": "Missing 'question' field."}), 400

    try:
        # Handle streaming vs. non-streaming
        if stream_requested:
            def generate():
                for chunk in assistant.ask_about_me(question, stream=True):
                    yield chunk
            return Response(generate(), mimetype='text/plain')
        else:
            answer = assistant.ask_about_me(question, stream=False)
            logger.debug(f"Non-streaming answer: {answer}")
            return jsonify({"answer": answer})
    except Exception as e:
        logger.error(f"Error generating answer: {str(e)}")
        return jsonify({"error": "Failed to generate answer."}), 500
</file>

<file path="backend/app.py">
from flask import Flask
from flask_socketio import SocketIO
from dotenv import load_dotenv
from flask_cors import CORS
from flask_session import Session
import os
import logging
from flask import request, jsonify
from routes.portfolio import portfolio_bp


load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")


app.register_blueprint(portfolio_bp, url_prefix='/portfolio')

@app.before_request
def log_request_info():
    logger.info(f"Handling request to {request.path} with method {request.method}")
    
    
 


@socketio.on('connect')
def handle_connect():
    logger.info('Client connected')
    socketio.emit('message', {'data': 'Connected to server'})

if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5000, debug=True, allow_unsafe_werkzeug=True)
</file>

<file path="backend/Dockerfile.backend">
FROM python:3.11.3


WORKDIR /app


RUN apt-get update && apt-get install -y --no-install-recommends \
    apt-transport-https \
    ca-certificates \
    build-essential \
    libffi-dev \
    gcc \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*



RUN python3 -m venv /venv


RUN /venv/bin/pip install --upgrade pip setuptools wheel


COPY requirements.txt /app/requirements.txt


RUN /venv/bin/pip install --no-cache-dir -r /app/requirements.txt


COPY . /app


ENV VIRTUAL_ENV="/venv"
ENV PATH="/venv/bin:$PATH"
ENV FLASK_ENV=production
ENV FLASK_APP=app.py


RUN chmod +x /app/app.py


EXPOSE 5000

CMD ["/venv/bin/gunicorn", "-k", "gevent", "-b", "0.0.0.0:5000", "app:app", "--timeout", "120"]
</file>

<file path="backend/requirements.txt">
annotated-types==0.7.0
anyio==4.6.2.post1
bidict==0.23.1
blinker==1.9.0
certifi==2024.8.30
click==8.1.7
dnspython==2.7.0
Flask==3.0.3
Flask-SocketIO==5.4.1
httpx==0.27.2
idna==3.10
itsdangerous==2.2.0
Jinja2==3.1.4
MarkupSafe==3.0.2
openai==1.54.3
pydantic==2.9.2
pymongo==4.10.1
python-engineio==4.10.1
python-socketio==5.11.4
simple-websocket==1.1.0
tqdm==4.67.0
typing_extensions==4.12.2
Werkzeug==3.1.3
python-dotenv==1.0.0
requests==2.31.0
gunicorn==21.2.0
Flask-CORS==3.0.10
Flask-Session
redis==5.0.0
celery==5.3.4
sendgrid==6.9.7
gevent==23.9.1
cffi==1.15.1
greenlet
faker
tzdata
Flask-Migrate
psutil
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="frontend/src/animations/dataFlowAnimation.js">
/**
 * Data flow animation utilities
 * Creates particle and line animations to visualize data flow in a cyberpunk style
 */

// Create streaming data particles along a path
export const createDataStream = (
  canvas, 
  startPoint, 
  endPoint, 
  color = '#00fff5', 
  particleCount = 20,
  speed = 2,
  spread = 5,
  size = 2
) => {
  if (!canvas || !canvas.getContext) return null;
  
  const ctx = canvas.getContext('2d');
  
  // Calculate direction vector
  const directionX = endPoint.x - startPoint.x;
  const directionY = endPoint.y - startPoint.y;
  const distance = Math.sqrt(directionX * directionX + directionY * directionY);
  
  // Normalize direction
  const normalX = directionX / distance;
  const normalY = directionY / distance;
  
  // Perpendicular vector for spread
  const perpX = -normalY;
  const perpY = normalX;
  
  // Create particles
  const particles = [];
  
  for (let i = 0; i < particleCount; i++) {
    // Position along path
    const progress = Math.random();
    const pathX = startPoint.x + directionX * progress;
    const pathY = startPoint.y + directionY * progress;
    
    // Add perpendicular spread
    const spreadFactor = (Math.random() - 0.5) * spread;
    const particleX = pathX + perpX * spreadFactor;
    const particleY = pathY + perpY * spreadFactor;
    
    // Create particle
    particles.push({
      x: particleX,
      y: particleY,
      progress,
      size: Math.random() * size + 1,
      speed: (Math.random() * 0.5 + 0.5) * speed,
      alpha: Math.random() * 0.7 + 0.3
    });
  }
  
  // Animation variables
  let animationId;
  let active = true;
  
  // Animation loop
  const animate = () => {
    if (!active) return;
    
    // Clear canvas or specific portion
    ctx.clearRect(
      Math.min(startPoint.x, endPoint.x) - spread - size,
      Math.min(startPoint.y, endPoint.y) - spread - size,
      Math.abs(directionX) + spread * 2 + size * 2,
      Math.abs(directionY) + spread * 2 + size * 2
    );
    
    // Update and draw particles
    for (let i = 0; i < particles.length; i++) {
      const particle = particles[i];
      
      // Update progress
      particle.progress += particle.speed / distance;
      
      // Reset if reached end
      if (particle.progress > 1) {
        particle.progress = 0;
        
        // Randomize spread again
        const spreadFactor = (Math.random() - 0.5) * spread;
        particle.x = startPoint.x + perpX * spreadFactor;
        particle.y = startPoint.y + perpY * spreadFactor;
        particle.alpha = Math.random() * 0.7 + 0.3;
      } else {
        // Calculate new position
        particle.x = startPoint.x + directionX * particle.progress + perpX * (Math.random() - 0.5) * 2;
        particle.y = startPoint.y + directionY * particle.progress + perpY * (Math.random() - 0.5) * 2;
      }
      
      // Draw particle
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fillStyle = color.replace(')', `, ${particle.alpha})`).replace('rgb', 'rgba');
      ctx.fill();
      
      // Optional glow effect
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
      ctx.fillStyle = color.replace(')', `, ${particle.alpha * 0.3})`).replace('rgb', 'rgba');
      ctx.fill();
    }
    
    animationId = requestAnimationFrame(animate);
  };
  
  // Start animation
  animate();
  
  // Return control object
  return {
    stop: () => {
      active = false;
      cancelAnimationFrame(animationId);
    },
    
    update: (newStartPoint, newEndPoint) => {
      startPoint = newStartPoint;
      endPoint = newEndPoint;
      
      // Recalculate vectors
      const dirX = endPoint.x - startPoint.x;
      const dirY = endPoint.y - startPoint.y;
      const dist = Math.sqrt(dirX * dirX + dirY * dirY);
      
      const normX = dirX / dist;
      const normY = dirY / dist;
      
      const perpendX = -normY;
      const perpendY = normX;
      
      // Reset particles along new path
      for (let i = 0; i < particles.length; i++) {
        const progress = Math.random();
        const spreadFactor = (Math.random() - 0.5) * spread;
        
        particles[i].x = startPoint.x + dirX * progress + perpendX * spreadFactor;
        particles[i].y = startPoint.y + dirY * progress + perpendY * spreadFactor;
        particles[i].progress = progress;
      }
    }
  };
};

// Create a grid of flowing data
export const createDataGrid = (
  canvas,
  color = '#00fff5',
  cellSize = 40,
  pulseSpeed = 2,
  lineWidth = 1
) => {
  if (!canvas || !canvas.getContext) return null;
  
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  // Calculate grid dimensions
  const columns = Math.ceil(width / cellSize);
  const rows = Math.ceil(height / cellSize);
  
  // Create active cells array (which cells have data flowing)
  const activeCells = [];
  const maxActiveCells = Math.floor((rows * columns) * 0.2); // 20% of cells active
  
  // Animation variables
  let animationId;
  let active = true;
  
  // Function to activate a random cell
  const activateRandomCell = () => {
    if (activeCells.length >= maxActiveCells) return;
    
    const col = Math.floor(Math.random() * columns);
    const row = Math.floor(Math.random() * rows);
    
    // Check if already active
    for (let i = 0; i < activeCells.length; i++) {
      if (activeCells[i].col === col && activeCells[i].row === row) {
        return;
      }
    }
    
    // Add new active cell
    activeCells.push({
      col,
      row,
      progress: 0,
      direction: Math.floor(Math.random() * 4), // 0: right, 1: down, 2: left, 3: up
      speed: (Math.random() * 0.5 + 0.5) * pulseSpeed
    });
  };
  
  // Initialize with some active cells
  const initialActiveCells = Math.floor(maxActiveCells / 3);
  for (let i = 0; i < initialActiveCells; i++) {
    activateRandomCell();
  }
  
  // Animation loop
  const animate = () => {
    if (!active) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Draw grid
    ctx.strokeStyle = color.replace(')', ', 0.2)').replace('rgb', 'rgba');
    ctx.lineWidth = lineWidth / 2;
    
    // Draw vertical lines
    for (let x = 0; x <= columns; x++) {
      ctx.beginPath();
      ctx.moveTo(x * cellSize, 0);
      ctx.lineTo(x * cellSize, height);
      ctx.stroke();
    }
    
    // Draw horizontal lines
    for (let y = 0; y <= rows; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * cellSize);
      ctx.lineTo(width, y * cellSize);
      ctx.stroke();
    }
    
    // Draw active data flows
    ctx.lineWidth = lineWidth;
    
    for (let i = activeCells.length - 1; i >= 0; i--) {
      const cell = activeCells[i];
      
      // Calculate start and end points based on direction
      let startX, startY, endX, endY;
      
      switch (cell.direction) {
        case 0: // right
          startX = cell.col * cellSize;
          startY = cell.row * cellSize + cellSize / 2;
          endX = (cell.col + 1) * cellSize;
          endY = startY;
          break;
        case 1: // down
          startX = cell.col * cellSize + cellSize / 2;
          startY = cell.row * cellSize;
          endX = startX;
          endY = (cell.row + 1) * cellSize;
          break;
        case 2: // left
          startX = (cell.col + 1) * cellSize;
          startY = cell.row * cellSize + cellSize / 2;
          endX = cell.col * cellSize;
          endY = startY;
          break;
        case 3: // up
          startX = cell.col * cellSize + cellSize / 2;
          startY = (cell.row + 1) * cellSize;
          endX = startX;
          endY = cell.row * cellSize;
          break;
      }
      
      // Update progress
      cell.progress += cell.speed / 100;
      
      // Draw data pulse
      const pulseLength = cellSize * 0.6;
      const pulsePosition = cell.progress * cellSize;
      
      if (pulsePosition <= cellSize) {
        // Calculate pulse start and end
        let pulseStartX, pulseStartY, pulseEndX, pulseEndY;
        const pulseStart = Math.max(0, pulsePosition - pulseLength);
        const pulseEnd = Math.min(cellSize, pulsePosition);
        
        switch (cell.direction) {
          case 0: // right
            pulseStartX = startX + pulseStart;
            pulseStartY = startY;
            pulseEndX = startX + pulseEnd;
            pulseEndY = startY;
            break;
          case 1: // down
            pulseStartX = startX;
            pulseStartY = startY + pulseStart;
            pulseEndX = startX;
            pulseEndY = startY + pulseEnd;
            break;
          case 2: // left
            pulseStartX = startX - pulseStart;
            pulseStartY = startY;
            pulseEndX = startX - pulseEnd;
            pulseEndY = startY;
            break;
          case 3: // up
            pulseStartX = startX;
            pulseStartY = startY - pulseStart;
            pulseEndX = startX;
            pulseEndY = startY - pulseEnd;
            break;
        }
        
        // Create gradient
        const gradient = ctx.createLinearGradient(pulseStartX, pulseStartY, pulseEndX, pulseEndY);
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(0.5, color);
        gradient.addColorStop(1, 'transparent');
        
        ctx.strokeStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(pulseStartX, pulseStartY);
        ctx.lineTo(pulseEndX, pulseEndY);
        ctx.stroke();
      } else {
        // Remove cell when pulse completed
        activeCells.splice(i, 1);
        
        // Random chance to activate a new cell
        if (Math.random() < 0.7) {
          activateRandomCell();
        }
      }
    }
    
    // Random chance to activate a new cell
    if (Math.random() < 0.05) {
      activateRandomCell();
    }
    
    animationId = requestAnimationFrame(animate);
  };
  
  // Start animation
  animate();
  
  // Return control object
  return {
    stop: () => {
      active = false;
      cancelAnimationFrame(animationId);
    },
    
    resize: (newWidth, newHeight) => {
      canvas.width = newWidth;
      canvas.height = newHeight;
      
      // Recalculate grid
      const newColumns = Math.ceil(newWidth / cellSize);
      const newRows = Math.ceil(newHeight / cellSize);
      
      // Update active cells to fit in new grid
      for (let i = activeCells.length - 1; i >= 0; i--) {
        if (activeCells[i].col >= newColumns || activeCells[i].row >= newRows) {
          activeCells.splice(i, 1);
        }
      }
      
      // Add new cells if needed
      const newMaxActive = Math.floor((newRows * newColumns) * 0.2);
      while (activeCells.length < newMaxActive / 3) {
        activateRandomCell();
      }
    }
  };
};

export default {
  createDataStream,
  createDataGrid
};
</file>

<file path="frontend/src/animations/glitchAnimation.js">
/**
 * Cyberpunk-style glitch animation utilities
 * These functions create different types of glitch effects for text and images
 */

// Text glitch effect - shifts character positions and adds color artifacts
export const glitchText = (element, intensity = 5, duration = 500) => {
  if (!element) return;
  
  const originalContent = element.textContent;
  const originalHTML = element.innerHTML;
  const glitchChars = '!<>-_\\/[]{}â€”=+*^?#________';
  const colors = ['#00fff5', '#ff3d3d', '#4d4dff', '#ffffff'];
  
  let iterations = 0;
  const maxIterations = Math.floor(duration / 50); // 20 frames per second
  
  // Save original styles
  const originalStyles = {
    color: window.getComputedStyle(element).color,
    textShadow: window.getComputedStyle(element).textShadow
  };
  
  const interval = setInterval(() => {
    if (iterations >= maxIterations) {
      clearInterval(interval);
      element.innerHTML = originalHTML;
      element.style.color = originalStyles.color;
      element.style.textShadow = originalStyles.textShadow;
      return;
    }
    
    // Create glitched text
    element.textContent = originalContent
      .split('')
      .map((char, index) => {
        // Only glitch some characters randomly
        if (Math.random() < intensity / 100) {
          return glitchChars[Math.floor(Math.random() * glitchChars.length)];
        }
        return char;
      })
      .join('');
    
    // Add color glitch
    if (Math.random() < 0.3) {
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      const glitchX = Math.random() * 3 - 1.5;
      const glitchY = Math.random() * 2 - 1;
      
      element.style.color = randomColor;
      element.style.textShadow = `${glitchX}px ${glitchY}px 3px rgba(255,0,0,0.5), 
                                 ${-glitchX}px ${-glitchY}px 3px rgba(0,255,255,0.5), 
                                 0 0 5px rgba(255,255,255,0.7)`;
    }
    
    iterations++;
  }, 50);
  
  return interval;
};

// Image glitch effect - applies CSS filters and clip-path distortions
export const glitchImage = (element, intensity = 5, duration = 500) => {
  if (!element || element.tagName !== 'IMG') return;
  
  const originalStyles = {
    filter: element.style.filter || 'none',
    clipPath: element.style.clipPath || 'none',
    transform: element.style.transform || 'none'
  };
  
  let iterations = 0;
  const maxIterations = Math.floor(duration / 50);
  
  const interval = setInterval(() => {
    if (iterations >= maxIterations) {
      clearInterval(interval);
      element.style.filter = originalStyles.filter;
      element.style.clipPath = originalStyles.clipPath;
      element.style.transform = originalStyles.transform;
      return;
    }
    
    // Apply random distortion effects
    if (Math.random() < 0.33) {
      // RGB shift
      const shiftX = (Math.random() * intensity) - (intensity / 2);
      const shiftY = (Math.random() * intensity) - (intensity / 2);
      element.style.filter = `
        hue-rotate(${Math.random() * 360}deg) 
        contrast(${1 + Math.random() * 0.4}) 
        saturate(${1 + Math.random() * 0.5})
      `;
      element.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
    }
    
    // Apply clip-path glitch
    if (Math.random() < 0.33) {
      const y1 = Math.random() * 100;
      const y2 = Math.random() * 100;
      element.style.clipPath = `polygon(0 ${y1}%, 100% ${y2}%, 100% 100%, 0 100%)`;
    }
    
    iterations++;
  }, 50);
  
  return interval;
};

// Page glitch effect - applies temporary glitches to the entire viewport
export const glitchScreen = (intensity = 3, duration = 300) => {
  const glitchOverlay = document.createElement('div');
  
  glitchOverlay.style.position = 'fixed';
  glitchOverlay.style.top = '0';
  glitchOverlay.style.left = '0';
  glitchOverlay.style.width = '100vw';
  glitchOverlay.style.height = '100vh';
  glitchOverlay.style.pointerEvents = 'none';
  glitchOverlay.style.zIndex = '999999';
  glitchOverlay.style.mixBlendMode = 'difference';
  glitchOverlay.style.animation = `glitchScreen ${duration}ms linear`;
  
  // Create keyframe animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes glitchScreen {
      0% { opacity: 0; background-color: transparent; }
      10% { opacity: 0.1; background-color: rgba(0, 255, 245, 0.1); transform: translateX(${(Math.random() - 0.5) * intensity * 10}px); }
      20% { opacity: 0; background-color: transparent; }
      30% { opacity: 0.1; background-color: rgba(255, 61, 61, 0.1); transform: translateY(${(Math.random() - 0.5) * intensity * 10}px); }
      40% { opacity: 0; background-color: transparent; }
      50% { opacity: 0.2; background-color: rgba(255, 255, 255, 0.2); clip-path: inset(${Math.random() * 100}% 0 0 0); }
      60% { opacity: 0; background-color: transparent; }
      70% { opacity: 0.15; background-color: rgba(0, 255, 245, 0.1); transform: scale(${1 + Math.random() * 0.1}); }
      80% { opacity: 0; background-color: transparent; }
      90% { opacity: 0.2; background-color: rgba(255, 61, 61, 0.1); transform: translateX(${(Math.random() - 0.5) * intensity * 5}px); }
      100% { opacity: 0; background-color: transparent; }
    }
  `;
  
  document.head.appendChild(style);
  document.body.appendChild(glitchOverlay);
  
  // Remove after animation completes
  setTimeout(() => {
    document.body.removeChild(glitchOverlay);
    document.head.removeChild(style);
  }, duration);
};

export default {
  glitchText,
  glitchImage,
  glitchScreen
};
</file>

<file path="frontend/src/animations/neonPulseAnimation.js">
/**
 * Neon pulse animation utilities
 * Functions for creating cyberpunk-style neon glow effects and pulsing animations
 */

// Create a pulsing neon glow effect on an element
export const createNeonPulse = (element, color = '#00fff5', intensity = 5, duration = 2000) => {
  if (!element) return;
  
  // Save original styles
  const originalStyles = {
    boxShadow: window.getComputedStyle(element).boxShadow,
    textShadow: window.getComputedStyle(element).textShadow,
    color: window.getComputedStyle(element).color,
    transition: window.getComputedStyle(element).transition
  };
  
  // Convert intensity to pixel values
  const minGlow = 2;
  const maxGlow = minGlow + intensity;
  
  // Set transition
  element.style.transition = `all ${duration / 2000}s ease-in-out`;
  
  // Check if element is text-only or has a border
  const isTextElement = element.children.length === 0 && element.textContent.trim() !== '';
  const hasBorder = window.getComputedStyle(element).border !== '0px none rgb(0, 0, 0)';
  
  // Start animation loop
  let isPulsing = true;
  let pulseIn = true;
  
  const pulseLoop = () => {
    if (!isPulsing) return;
    
    if (pulseIn) {
      // Pulse in (increase glow)
      if (isTextElement) {
        element.style.color = color;
        element.style.textShadow = `0 0 ${maxGlow}px ${color}, 0 0 ${maxGlow * 1.5}px ${color}`;
      }
      
      if (hasBorder) {
        element.style.boxShadow = `0 0 ${maxGlow}px ${color}, inset 0 0 ${maxGlow / 2}px ${color}`;
      }
    } else {
      // Pulse out (decrease glow)
      if (isTextElement) {
        element.style.textShadow = `0 0 ${minGlow}px ${color}, 0 0 ${minGlow * 1.5}px ${color}`;
      }
      
      if (hasBorder) {
        element.style.boxShadow = `0 0 ${minGlow}px ${color}, inset 0 0 ${minGlow / 2}px ${color}`;
      }
    }
    
    // Toggle pulse direction
    pulseIn = !pulseIn;
    
    // Schedule next pulse
    setTimeout(pulseLoop, duration / 2);
  };
  
  // Start the animation
  pulseLoop();
  
  // Return a function to stop the animation
  return () => {
    isPulsing = false;
    
    // Restore original styles
    element.style.boxShadow = originalStyles.boxShadow;
    element.style.textShadow = originalStyles.textShadow;
    element.style.color = originalStyles.color;
    element.style.transition = originalStyles.transition;
  };
};

// Apply neon highlight effect on hover
export const neonHoverEffect = (element, color = '#00fff5', intensity = 5) => {
  if (!element) return;
  
  // Save original styles
  const originalStyles = {
    boxShadow: element.style.boxShadow || '',
    textShadow: element.style.textShadow || '',
    color: element.style.color || '',
    borderColor: element.style.borderColor || '',
    transition: element.style.transition || ''
  };
  
  // Set up transition
  element.style.transition = 'all 0.3s ease';
  
  // Convert intensity to pixel values
  const glowSize = intensity * 2;
  
  // Mouse enter event - apply neon effect
  const mouseEnterHandler = () => {
    element.style.color = color;
    element.style.borderColor = color;
    element.style.boxShadow = `0 0 ${glowSize}px ${color}, inset 0 0 ${glowSize / 2}px ${color}`;
    element.style.textShadow = `0 0 ${glowSize / 2}px ${color}`;
  };
  
  // Mouse leave event - restore original styles
  const mouseLeaveHandler = () => {
    element.style.boxShadow = originalStyles.boxShadow;
    element.style.textShadow = originalStyles.textShadow;
    element.style.color = originalStyles.color;
    element.style.borderColor = originalStyles.borderColor;
  };
  
  // Add event listeners
  element.addEventListener('mouseenter', mouseEnterHandler);
  element.addEventListener('mouseleave', mouseLeaveHandler);
  
  // Return a cleanup function
  return () => {
    element.removeEventListener('mouseenter', mouseEnterHandler);
    element.removeEventListener('mouseleave', mouseLeaveHandler);
    
    // Restore original styles
    element.style.boxShadow = originalStyles.boxShadow;
    element.style.textShadow = originalStyles.textShadow;
    element.style.color = originalStyles.color;
    element.style.borderColor = originalStyles.borderColor;
    element.style.transition = originalStyles.transition;
  };
};

// Create a text neon sign effect with flickering
export const neonSignEffect = (element, color = '#00fff5', flickerIntensity = 0.05) => {
  if (!element) return;
  
  // Save original styles
  const originalStyles = {
    color: element.style.color || '',
    textShadow: element.style.textShadow || '',
    transition: element.style.transition || ''
  };
  
  // Apply base neon effect
  element.style.color = color;
  element.style.textShadow = `0 0 5px ${color}, 0 0 10px ${color}, 0 0 20px ${color}`;
  
  // Create random flicker
  let isFlickering = true;
  
  const flicker = () => {
    if (!isFlickering) return;
    
    // Random chance to flicker
    if (Math.random() < flickerIntensity) {
      // Turn off (brief flicker)
      element.style.opacity = 0.8;
      element.style.textShadow = 'none';
      
      // Randomly decide when to turn back on
      setTimeout(() => {
        element.style.opacity = 1;
        element.style.textShadow = `0 0 5px ${color}, 0 0 10px ${color}, 0 0 20px ${color}`;
      }, Math.random() * 100);
    }
    
    // Schedule next potential flicker
    setTimeout(flicker, 100 + Math.random() * 1000);
  };
  
  // Start flickering
  flicker();
  
  // Return cleanup function
  return () => {
    isFlickering = false;
    
    // Restore original styles
    element.style.color = originalStyles.color;
    element.style.textShadow = originalStyles.textShadow;
    element.style.transition = originalStyles.transition;
    element.style.opacity = 1;
  };
};

export default {
  createNeonPulse,
  neonHoverEffect,
  neonSignEffect
};
</file>

<file path="frontend/src/components/3d/CyberCity.jsx">
import React, { useRef, useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';
import * as THREE from 'three';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';

// City building component
const CityBuilding = ({ 
  position, 
  width = 1, 
  depth = 1, 
  height = 5, 
  color = '#00fff5',
  glowColor = '#00fff5',
  glowIntensity = 1,
  windowColor = '#ffffff',
  glitchIntensity = 0.2,
  pulseSpeed = 0.5
}) => {
  const buildingRef = useRef();
  const materialRef = useRef();
  const edgesRef = useRef();
  const [time, setTime] = useState(0);
  
  // Building geometry with dynamic windows
  const geometry = new THREE.BoxGeometry(width, height, depth);
  
  // Animate building
  useFrame((state, delta) => {
    if (!buildingRef.current || !materialRef.current) return;
    
    // Update time for animations
    setTime(prev => prev + delta);
    
    // Pulse glow effect
    const pulseValue = Math.sin(time * pulseSpeed) * 0.5 + 0.5;
    materialRef.current.emissiveIntensity = glowIntensity * pulseValue;
    
    // Random glitch effect
    if (Math.random() < glitchIntensity * delta * 10) {
      const glitchDuration = 100 + Math.random() * 200;
      const glitchHeight = height * (0.95 + Math.random() * 0.1);
      
      buildingRef.current.scale.y = glitchHeight / height;
      
      setTimeout(() => {
        if (buildingRef.current) {
          buildingRef.current.scale.y = 1;
        }
      }, glitchDuration);
    }
    
    // Edges glow effect
    if (edgesRef.current) {
      edgesRef.current.material.opacity = 0.3 + pulseValue * 0.7;
    }
  });
  
  return (
    <group position={position}>
      <mesh ref={buildingRef} castShadow receiveShadow>
        <boxGeometry args={[width, height, depth]} />
        <meshPhongMaterial 
          ref={materialRef}
          color={color}
          emissive={glowColor}
          emissiveIntensity={glowIntensity}
          transparent
          opacity={0.8}
          shininess={90}
        />
      </mesh>
      
      {/* Building edges */}
      <lineSegments ref={edgesRef}>
        <edgesGeometry args={[geometry]} />
        <lineBasicMaterial color={glowColor} transparent opacity={0.7} />
      </lineSegments>
      
      {/* Windows */}
      <Windows 
        width={width} 
        height={height} 
        depth={depth} 
        color={windowColor}
        time={time}
      />
    </group>
  );
};

// Building windows component
const Windows = ({ width, height, depth, color = '#ffffff', time = 0 }) => {
  const windowsRef = useRef();
  
  // Create window points
  const windowWidth = 0.1;
  const windowHeight = 0.15;
  const windowSpacingX = 0.3;
  const windowSpacingY = 0.5;
  const points = [];
  
  // Create window positions for front face
  for (let y = 0.5; y < height - 0.5; y += windowSpacingY) {
    for (let x = -width/2 + 0.3; x < width/2 - 0.3; x += windowSpacingX) {
      // Front face
      points.push(
        new THREE.Vector3(x, y, depth/2 + 0.01),
        new THREE.Vector3(x + windowWidth, y, depth/2 + 0.01),
        new THREE.Vector3(x + windowWidth, y + windowHeight, depth/2 + 0.01),
        new THREE.Vector3(x, y + windowHeight, depth/2 + 0.01)
      );
      
      // Back face
      points.push(
        new THREE.Vector3(x, y, -depth/2 - 0.01),
        new THREE.Vector3(x + windowWidth, y, -depth/2 - 0.01),
        new THREE.Vector3(x + windowWidth, y + windowHeight, -depth/2 - 0.01),
        new THREE.Vector3(x, y + windowHeight, -depth/2 - 0.01)
      );
    }
  }
  
  // Add windows on sides for wider buildings
  if (width > 1.5) {
    for (let y = 0.5; y < height - 0.5; y += windowSpacingY) {
      for (let z = -depth/2 + 0.3; z < depth/2 - 0.3; z += windowSpacingX) {
        // Left side
        points.push(
          new THREE.Vector3(-width/2 - 0.01, y, z),
          new THREE.Vector3(-width/2 - 0.01, y, z + windowWidth),
          new THREE.Vector3(-width/2 - 0.01, y + windowHeight, z + windowWidth),
          new THREE.Vector3(-width/2 - 0.01, y + windowHeight, z)
        );
        
        // Right side
        points.push(
          new THREE.Vector3(width/2 + 0.01, y, z),
          new THREE.Vector3(width/2 + 0.01, y, z + windowWidth),
          new THREE.Vector3(width/2 + 0.01, y + windowHeight, z + windowWidth),
          new THREE.Vector3(width/2 + 0.01, y + windowHeight, z)
        );
      }
    }
  }
  
  // Animate windows
  useFrame(() => {
    if (!windowsRef.current) return;
    
    // Random window flicker effect
    const windowVerts = windowsRef.current.geometry.attributes.position.array;
    
    for (let i = 0; i < windowVerts.length; i += 12) {
      // Each window has 4 vertices, each with 3 coordinates (x,y,z)
      const isOn = Math.random() > 0.2;
      const flicker = isOn ? (0.8 + Math.sin(time * 2 + i) * 0.2) : 0;
      
      // Update opacity of all 4 vertices of this window
      for (let j = 0; j < 4; j++) {
        windowsRef.current.geometry.attributes.color.array[i/3 + j*3 + 0] = flicker;
        windowsRef.current.geometry.attributes.color.array[i/3 + j*3 + 1] = flicker;
        windowsRef.current.geometry.attributes.color.array[i/3 + j*3 + 2] = flicker;
      }
    }
    
    windowsRef.current.geometry.attributes.color.needsUpdate = true;
  });
  
  // Create colors array
  const colors = new Float32Array(points.length * 3);
  
  // Initial random window colors
  for (let i = 0; i < colors.length; i += 12) {
    const isOn = Math.random() > 0.3;
    const brightness = isOn ? 1 : 0;
    
    // Set color for all 4 vertices of this window
    for (let j = 0; j < 4; j++) {
      colors[i + j*3 + 0] = brightness;
      colors[i + j*3 + 1] = brightness;
      colors[i + j*3 + 2] = brightness;
    }
  }
  
  return (
    <points ref={windowsRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={points.length}
          array={new Float32Array(points.flatMap(p => [p.x, p.y, p.z]))}
          itemSize={3}
        />
        <bufferAttribute
          attach="attributes-color"
          count={points.length}
          array={colors}
          itemSize={3}
        />
      </bufferGeometry>
      <pointsMaterial
        size={0.05}
        vertexColors
        color={color}
        transparent
        opacity={0.8}
      />
    </points>
  );
};

// Ground grid component
const GroundGrid = ({ size = 100, divisions = 100, color = '#00fff5', glowColor = '#00fff5' }) => {
  const gridRef = useRef();
  
  useFrame((state, delta) => {
    if (!gridRef.current) return;
    
    // Animating grid
    gridRef.current.material.opacity = 0.3 + Math.sin(state.clock.elapsedTime * 0.5) * 0.1;
  });
  
  return (
    <gridHelper
      ref={gridRef}
      args={[size, divisions, color, color]}
      position={[0, -0.1, 0]}
      material={
        new THREE.LineBasicMaterial({
          color: glowColor,
          transparent: true,
          opacity: 0.4
        })
      }
    />
  );
};

// Data stream effect
const DataStream = ({ count = 100, color = '#00fff5', speed = 1 }) => {
  const pointsRef = useRef();
  const [particles, setParticles] = useState([]);
  
  // Initialize particles
  useEffect(() => {
    const newParticles = [];
    
    for (let i = 0; i < count; i++) {
      newParticles.push({
        position: new THREE.Vector3(
          (Math.random() - 0.5) * 100,
          Math.random() * 50,
          (Math.random() - 0.5) * 100
        ),
        velocity: new THREE.Vector3(
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2
        ),
        size: 0.1 + Math.random() * 0.2,
        life: Math.random()
      });
    }
    
    setParticles(newParticles);
  }, [count]);
  
  // Animate particles
  useFrame((state, delta) => {
    if (!pointsRef.current || particles.length === 0) return;
    
    const positions = pointsRef.current.geometry.attributes.position.array;
    const sizes = pointsRef.current.geometry.attributes.size.array;
    
    let i = 0;
    
    particles.forEach((particle, idx) => {
      // Update position
      particle.position.add(
        particle.velocity.clone().multiplyScalar(delta * speed * 10)
      );
      
      // Increment life
      particle.life += delta * 0.2;
      if (particle.life > 1) particle.life = 0;
      
      // Calculate pulse
      const pulse = Math.sin(particle.life * Math.PI) * 0.5 + 0.5;
      
      // Update attributes
      positions[i*3] = particle.position.x;
      positions[i*3+1] = particle.position.y;
      positions[i*3+2] = particle.position.z;
      
      sizes[i] = particle.size * pulse;
      
      i++;
    });
    
    pointsRef.current.geometry.attributes.position.needsUpdate = true;
    pointsRef.current.geometry.attributes.size.needsUpdate = true;
  });
  
  return (
    <points ref={pointsRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          count={particles.length}
          array={new Float32Array(particles.length * 3)}
          itemSize={3}
        />
        <bufferAttribute
          attach="attributes-size"
          count={particles.length}
          array={new Float32Array(particles.length)}
          itemSize={1}
        />
      </bufferGeometry>
      <pointsMaterial
        size={0.1}
        color={color}
        transparent
        opacity={0.8}
        blending={THREE.AdditiveBlending}
      />
    </points>
  );
};

// Camera controller
const CameraController = ({ enableZoom = true, enableRotate = true, autoRotate = true }) => {
  const { camera, gl } = useThree();
  const controlsRef = useRef();
  
  useEffect(() => {
    if (controlsRef.current) {
      // Set initial camera position
      camera.position.set(15, 10, 15);
      camera.lookAt(0, 0, 0);
    }
  }, [camera]);
  
  useFrame(() => {
    if (controlsRef.current) {
      controlsRef.current.update();
    }
  });
  
  return (
    <OrbitControls
      ref={controlsRef}
      args={[camera, gl.domElement]}
      enableZoom={enableZoom}
      enableRotate={enableRotate}
      autoRotate={autoRotate}
      autoRotateSpeed={0.5}
      minDistance={5}
      maxDistance={50}
      minPolarAngle={0}
      maxPolarAngle={Math.PI / 2}
    />
  );
};

// Main city scene component
const CityScene = ({ buildingCount = 20, citySize = 40 }) => {
  const { theme } = useTheme();
  const [buildings, setBuildings] = useState([]);
  
  // Primary color based on theme
  const primaryColor = theme === 'dark' ? '#00fff5' : '#4d4dff';
  const secondaryColor = '#ff3d3d';
  
  // Generate city buildings
  useEffect(() => {
    const newBuildings = [];
    
    // Create buildings
    for (let i = 0; i < buildingCount; i++) {
      const size = 1 + Math.random() * 2;
      const height = 2 + Math.random() * 15;
      
      // Ensure buildings don't overlap too much
      let tooClose = true;
      let attempts = 0;
      let position;
      
      while (tooClose && attempts < 100) {
        position = new THREE.Vector3(
          (Math.random() - 0.5) * citySize,
          height / 2,
          (Math.random() - 0.5) * citySize
        );
        
        tooClose = false;
        
        for (const existing of newBuildings) {
          const minDistance = (size + existing.size) * 0.8;
          const actualDistance = position.distanceTo(existing.position);
          
          if (actualDistance < minDistance) {
            tooClose = true;
            break;
          }
        }
        
        attempts++;
      }
      
      // If we couldn't find a spot after 100 attempts, skip this building
      if (attempts >= 100) continue;
      
      // Randomly assign colors
      const useSecondary = Math.random() > 0.7;
      
      newBuildings.push({
        position,
        width: size,
        depth: size,
        height,
        color: useSecondary ? secondaryColor : primaryColor,
        glowColor: useSecondary ? secondaryColor : primaryColor,
        glowIntensity: 0.2 + Math.random() * 0.3,
        glitchIntensity: 0.05 + Math.random() * 0.2,
        pulseSpeed: 0.2 + Math.random() * 0.8,
        size
      });
    }
    
    setBuildings(newBuildings);
  }, [buildingCount, citySize, primaryColor, secondaryColor]);
  
  return (
    <>
      {/* City ambient lighting */}
      <ambientLight intensity={0.2} />
      
      {/* Main directional light */}
      <directionalLight 
        position={[10, 20, 10]} 
        intensity={0.7} 
        castShadow 
      />
      
      {/* Ground grid */}
      <GroundGrid 
        size={citySize} 
        divisions={citySize} 
        color={primaryColor}
        glowColor={primaryColor}
      />
      
      {/* Buildings */}
      {buildings.map((building, index) => (
        <CityBuilding 
          key={index}
          position={building.position}
          width={building.width}
          depth={building.depth}
          height={building.height}
          color={building.color}
          glowColor={building.glowColor}
          glowIntensity={building.glowIntensity}
          glitchIntensity={building.glitchIntensity}
          pulseSpeed={building.pulseSpeed}
        />
      ))}
      
      {/* Data stream particles */}
      <DataStream 
        count={200} 
        color={primaryColor}
        speed={1}
      />
      
      {/* Camera controller */}
      <CameraController 
        enableZoom={true}
        enableRotate={true}
        autoRotate={true}
      />
      
      {/* Fog for atmosphere */}
      <fog attach="fog" args={[theme === 'dark' ? '#000000' : '#ffffff', 10, 100]} />
    </>
  );
};

// Main CyberCity component
const CyberCity = ({
  width = '100%',
  height = '400px',
  buildingCount = 20,
  citySize = 40,
  enableZoom = true,
  enableRotate = true,
  autoRotate = true,
  className = '',
  style = {},
  ...props
}) => {
  return (
    <div
      className={`cyber-city ${className}`}
      style={{
        width,
        height,
        position: 'relative',
        overflow: 'hidden',
        ...style
      }}
      {...props}
    >
      <Canvas
        shadows
        camera={{ position: [15, 10, 15], fov: 60 }}
        style={{ background: 'transparent' }}
      >
        <CityScene 
          buildingCount={buildingCount} 
          citySize={citySize} 
        />
      </Canvas>
    </div>
  );
};

CyberCity.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  buildingCount: PropTypes.number,
  citySize: PropTypes.number,
  enableZoom: PropTypes.bool,
  enableRotate: PropTypes.bool,
  autoRotate: PropTypes.bool,
  className: PropTypes.string,
  style: PropTypes.object
};

export default CyberCity;
</file>

<file path="frontend/src/components/3d/HoloProfile.jsx">
import React, { useRef, useEffect, useState } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { useFBX, useTexture, Text, useGLTF } from '@react-three/drei';
import * as THREE from 'three';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useGlitch } from '../../hooks/useGlitch';

const HoloProfile = ({ 
  imageUrl = '/assets/profile.png', 
  rotation = [0, 0, 0], 
  position = [0, 0, 0],
  scale = 1,
  intensity = 1.2,
  glitchIntensity = 0.3,
  color = null,
  showInfo = true,
  animate = true,
  onClick = null
}) => {
  const meshRef = useRef();
  const glowRef = useRef();
  const infoRef = useRef();
  const { theme } = useTheme();
  const { viewport } = useThree();
  const [hovered, setHovered] = useState(false);
  const [clicked, setClicked] = useState(false);
  const [rotation_, setRotation] = useState(rotation);
  const [infoVisible, setInfoVisible] = useState(false);
  
  // Generate color based on theme if not provided
  const profileColor = color || (theme === 'dark' ? '#00fff5' : '#4d4dff');
  
  // Initialize texture
  const texture = useTexture(imageUrl);
  
  // Apply glitch effect
  const { startGlitch, stopGlitch } = useGlitch(meshRef, {
    intensity: glitchIntensity * 10,
    duration: 400,
    continuousGlitch: false
  });
  
  // Handle hover
  const handlePointerOver = () => {
    if (!hovered) {
      setHovered(true);
      startGlitch();
      if (showInfo) setInfoVisible(true);
    }
  };
  
  const handlePointerOut = () => {
    if (hovered) {
      setHovered(false);
      if (showInfo) setInfoVisible(false);
    }
  };
  
  // Handle click
  const handleClick = (e) => {
    e.stopPropagation();
    setClicked(!clicked);
    startGlitch();
    
    if (onClick) onClick();
  };
  
  // Animation loop
  useFrame((state, delta) => {
    if (!meshRef.current) return;
    
    // Rotate based on animation state
    if (animate) {
      meshRef.current.rotation.y += delta * 0.2;
      meshRef.current.rotation.x = Math.sin(state.clock.elapsedTime * 0.5) * 0.1;
    }
    
    // Pulse glow effect
    if (glowRef.current) {
      const pulse = 0.8 + Math.sin(state.clock.elapsedTime * 2) * 0.2;
      glowRef.current.material.opacity = pulse * (hovered ? 0.8 : 0.4);
      glowRef.current.scale.set(
        1 + pulse * 0.05, 
        1 + pulse * 0.05, 
        1 + pulse * 0.05
      );
    }
    
    // Update info panel position
    if (infoRef.current && infoVisible) {
      infoRef.current.lookAt(state.camera.position);
    }
  });
  
  // Load profile image as texture on plane geometry
  return (
    <group position={position} scale={scale} rotation={rotation_}>
      {/* Main profile mesh */}
      <mesh 
        ref={meshRef}
        onPointerOver={handlePointerOver}
        onPointerOut={handlePointerOut}
        onClick={handleClick}
      >
        <planeGeometry args={[1, 1, 32, 32]} />
        <meshBasicMaterial 
          map={texture} 
          transparent 
          opacity={0.9}
          side={THREE.DoubleSide}
        />
        
        {/* Grid overlay */}
        <mesh position={[0, 0, 0.01]}>
          <planeGeometry args={[1, 1, 32, 32]} />
          <meshBasicMaterial 
            color={profileColor}
            wireframe
            transparent
            opacity={0.2}
          />
        </mesh>
      </mesh>
      
      {/* Glow effect */}
      <mesh ref={glowRef} position={[0, 0, -0.05]}>
        <planeGeometry args={[1.2, 1.2]} />
        <meshBasicMaterial 
          color={profileColor}
          transparent
          opacity={0.4}
          side={THREE.DoubleSide}
        />
      </mesh>
      
      {/* Holographic scan line */}
      <mesh position={[0, 0, 0.02]}>
        <planeGeometry args={[1, 0.01]} />
        <meshBasicMaterial 
          color={profileColor}
          transparent
          opacity={0.7}
        >
          <animated 
            attach="opacity" 
            position={[0, 0, 0.02]}
            factor={0.7} 
            speed={1}
          />
        </meshBasicMaterial>
      </mesh>
      
      {/* Info panel that appears on hover */}
      {showInfo && infoVisible && (
        <group ref={infoRef} position={[0.7, 0, 0]}>
          <mesh position={[0, 0, 0]}>
            <planeGeometry args={[0.6, 0.3]} />
            <meshBasicMaterial
              color="#000000"
              transparent
              opacity={0.7}
            />
          </mesh>
          
          <Text
            position={[0, 0.08, 0.01]}
            fontSize={0.04}
            color={profileColor}
            anchorX="center"
            anchorY="middle"
            font="/assets/fonts/Orbitron-Bold.ttf"
          >
            CARTER RUSH PEREZ
          </Text>
          
          <Text
            position={[0, 0, 0.01]}
            fontSize={0.025}
            color="#ffffff"
            anchorX="center"
            anchorY="middle"
            font="/assets/fonts/Rajdhani-Regular.ttf"
          >
            SYSTEM INTEGRATION TECHNICIAN
          </Text>
          
          <Text
            position={[0, -0.08, 0.01]}
            fontSize={0.02}
            color={profileColor}
            anchorX="center"
            anchorY="middle"
            font="/assets/fonts/Fira_Code_Regular.ttf"
          >
            CYBERSECURITY SPECIALIST
          </Text>
        </group>
      )}
      
      {/* Decorative elements */}
      <mesh position={[-0.52, -0.52, 0]} rotation={[0, 0, Math.PI / 4]}>
        <boxGeometry args={[0.05, 0.05, 0.01]} />
        <meshBasicMaterial color={profileColor} />
      </mesh>
      
      <mesh position={[0.52, 0.52, 0]} rotation={[0, 0, Math.PI / 4]}>
        <boxGeometry args={[0.05, 0.05, 0.01]} />
        <meshBasicMaterial color={profileColor} />
      </mesh>
    </group>
  );
};

export default HoloProfile;
</file>

<file path="frontend/src/components/3d/ParticleNetwork.jsx">
import React, { useRef, useEffect } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { Points, PointMaterial } from '@react-three/drei';
import * as THREE from 'three';
import { useTheme } from '../../contexts/ThemeContext';

const ParticleNetwork = ({ count = 3000, connections = true, speed = 0.2, size = 0.02 }) => {
  const { theme } = useTheme();
  const pointsRef = useRef();
  const linesRef = useRef();
  const { size: viewSize } = useThree();
  
  // Generate random points in 3D space
  const particlesPosition = useRef();
  const particlesTarget = useRef();
  const linePositions = useRef();
  
  // Setup initial particles
  useEffect(() => {
    particlesPosition.current = new Float32Array(count * 3);
    particlesTarget.current = new Float32Array(count * 3);
    linePositions.current = new Float32Array(count * 6 * 5); // For up to 5 connections per particle
    
    // Generate initial positions and target positions
    for (let i = 0; i < count; i++) {
      const i3 = i * 3;
      particlesPosition.current[i3] = (Math.random() - 0.5) * 10;
      particlesPosition.current[i3 + 1] = (Math.random() - 0.5) * 10;
      particlesPosition.current[i3 + 2] = (Math.random() - 0.5) * 10;
      
      particlesTarget.current[i3] = particlesPosition.current[i3] + (Math.random() - 0.5) * 1;
      particlesTarget.current[i3 + 1] = particlesPosition.current[i3 + 1] + (Math.random() - 0.5) * 1;
      particlesTarget.current[i3 + 2] = particlesPosition.current[i3 + 2] + (Math.random() - 0.5) * 1;
    }
    
    if (pointsRef.current) {
      pointsRef.current.geometry.setAttribute(
        'position',
        new THREE.BufferAttribute(particlesPosition.current, 3)
      );
    }
  }, [count]);
  
  // Animation loop
  useFrame((state, delta) => {
    if (!pointsRef.current || !linesRef.current) return;
    
    // Update particles
    const positions = pointsRef.current.geometry.attributes.position.array;
    let lineIndex = 0;
    
    // First update positions
    for (let i = 0; i < count; i++) {
      const i3 = i * 3;
      
      // Move towards target with easing
      positions[i3] += (particlesTarget.current[i3] - positions[i3]) * speed * delta;
      positions[i3 + 1] += (particlesTarget.current[i3 + 1] - positions[i3 + 1]) * speed * delta;
      positions[i3 + 2] += (particlesTarget.current[i3 + 2] - positions[i3 + 2]) * speed * delta;
      
      // If particle reached target, create a new target
      if (
        Math.abs(positions[i3] - particlesTarget.current[i3]) < 0.01 &&
        Math.abs(positions[i3 + 1] - particlesTarget.current[i3 + 1]) < 0.01 &&
        Math.abs(positions[i3 + 2] - particlesTarget.current[i3 + 2]) < 0.01
      ) {
        particlesTarget.current[i3] = positions[i3] + (Math.random() - 0.5) * 2;
        particlesTarget.current[i3 + 1] = positions[i3 + 1] + (Math.random() - 0.5) * 2;
        particlesTarget.current[i3 + 2] = positions[i3 + 2] + (Math.random() - 0.5) * 2;
      }
    }
    
    // Mark positions as needing update
    pointsRef.current.geometry.attributes.position.needsUpdate = true;
    
    // Update connections if enabled
    if (connections) {
      const linesPositions = linesRef.current.geometry.attributes.position.array;
      lineIndex = 0;
      
      // Find closest particles to create connections
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const distances = [];
        
        // Calculate distances to all other particles
        for (let j = 0; j < count; j++) {
          if (i === j) continue;
          
          const j3 = j * 3;
          const dx = positions[i3] - positions[j3];
          const dy = positions[i3 + 1] - positions[j3 + 1];
          const dz = positions[i3 + 2] - positions[j3 + 2];
          const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
          
          if (distance < 2) {
            distances.push({ index: j, distance });
          }
        }
        
        // Sort by distance and take closest 5
        distances.sort((a, b) => a.distance - b.distance);
        const connectCount = Math.min(5, distances.length);
        
        // Create lines for closest connections
        for (let k = 0; k < connectCount; k++) {
          const j = distances[k].index;
          const j3 = j * 3;
          
          // Start point of line (current particle)
          linesPositions[lineIndex++] = positions[i3];
          linesPositions[lineIndex++] = positions[i3 + 1];
          linesPositions[lineIndex++] = positions[i3 + 2];
          
          // End point of line (connected particle)
          linesPositions[lineIndex++] = positions[j3];
          linesPositions[lineIndex++] = positions[j3 + 1];
          linesPositions[lineIndex++] = positions[j3 + 2];
        }
      }
      
      // Fill the rest with empty lines
      while (lineIndex < linesPositions.length) {
        linesPositions[lineIndex++] = 0;
      }
      
      linesRef.current.geometry.attributes.position.needsUpdate = true;
    }
  });
  
  return (
    <group>
      <Points ref={pointsRef} limit={count}>
        <PointMaterial
          transparent
          vertexColors
          size={size}
          sizeAttenuation={true}
          color={theme === 'dark' ? '#00fff5' : '#4d4dff'}
          depthWrite={false}
        />
      </Points>
      
      {connections && (
        <lineSegments ref={linesRef}>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={count * 6 * 5}
              array={linePositions.current}
              itemSize={3}
            />
          </bufferGeometry>
          <lineBasicMaterial
            attach="material"
            color={theme === 'dark' ? '#00fff5' : '#4d4dff'}
            transparent
            opacity={0.2}
            depthWrite={false}
          />
        </lineSegments>
      )}
    </group>
  );
};

export default ParticleNetwork;
</file>

<file path="frontend/src/components/common/CircuitLines.jsx">
import React, { useRef, useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import { useTheme } from '../../contexts/ThemeContext';

const CircuitLines = ({
  color = 'auto',
  density = 'medium',
  animate = true,
  pulse = true,
  speed = 'medium',
  width = '100%',
  height = '100%',
  className = '',
  style = {},
  ...props
}) => {
  const { theme } = useTheme();
  const canvasRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  
  // Convert props to actual values
  const actualColor = color === 'auto' 
    ? theme === 'dark' ? 'var(--accent-cyan)' : 'var(--accent-blue)'
    : color;
  
  const actualDensity = getDensityValue(density);
  const actualSpeed = getSpeedValue(speed);
  
  // Set canvas dimensions on mount and resize
  useEffect(() => {
    const updateDimensions = () => {
      if (!canvasRef.current) return;
      
      const canvas = canvasRef.current;
      const rect = canvas.getBoundingClientRect();
      
      // Set canvas dimensions with device pixel ratio for sharpness
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      
      // Store dimensions for calculations
      setDimensions({
        width: rect.width,
        height: rect.height,
        dpr
      });
    };
    
    window.addEventListener('resize', updateDimensions);
    updateDimensions();
    
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);
  
  // Draw circuit pattern
  useEffect(() => {
    if (!canvasRef.current || !dimensions.width || !dimensions.height) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const { width, height, dpr } = dimensions;
    
    // Scale context for retina/high-DPI displays
    ctx.scale(dpr, dpr);
    
    // Circuit pattern parameters
    const nodeSize = 2;
    const lineWidth = 1;
    const nodeSpacing = Math.max(20, 100 - actualDensity * 5); // More density = less spacing
    
    // Calculate grid parameters
    const cols = Math.ceil(width / nodeSpacing);
    const rows = Math.ceil(height / nodeSpacing);
    
    // Generate nodes
    const nodes = [];
    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        // Add some randomness to node positions
        const randomOffsetX = Math.random() * (nodeSpacing * 0.3);
        const randomOffsetY = Math.random() * (nodeSpacing * 0.3);
        
        // Only add some nodes based on density
        if (Math.random() < actualDensity / 100) {
          nodes.push({
            x: i * nodeSpacing + randomOffsetX,
            y: j * nodeSpacing + randomOffsetY,
            connections: [],
            active: Math.random() < 0.2, // Some nodes start active
            pulsePhase: Math.random() * Math.PI * 2, // Random phase for pulsing
            pulseFactor: 0.7 + Math.random() * 0.6 // Randomize pulse strength
          });
        }
      }
    }
    
    // Connect nodes - each node connects to nearest nodes
    nodes.forEach(node => {
      // Find nearby nodes to connect to
      const maxConnections = 2 + Math.floor(Math.random() * 2); // 2-3 connections per node
      
      // Calculate distances to all other nodes
      const nodeDistances = nodes
        .filter(otherNode => otherNode !== node)
        .map(otherNode => {
          const dx = node.x - otherNode.x;
          const dy = node.y - otherNode.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          return { node: otherNode, distance };
        })
        .filter(item => item.distance < nodeSpacing * 2) // Only connect to nearby nodes
        .sort((a, b) => a.distance - b.distance); // Sort by distance
      
      // Connect to nearest nodes
      for (let i = 0; i < Math.min(maxConnections, nodeDistances.length); i++) {
        const otherNode = nodeDistances[i].node;
        
        // Avoid duplicate connections
        if (!node.connections.includes(otherNode) && !otherNode.connections.includes(node)) {
          node.connections.push(otherNode);
        }
      }
    });
    
    // Add some long distance connections for visual interest
    const longConnectionCount = Math.floor(nodes.length * 0.05); // 5% of nodes get long connections
    for (let i = 0; i < longConnectionCount; i++) {
      const nodeA = nodes[Math.floor(Math.random() * nodes.length)];
      const nodeB = nodes[Math.floor(Math.random() * nodes.length)];
      
      if (nodeA !== nodeB && !nodeA.connections.includes(nodeB) && !nodeB.connections.includes(nodeA)) {
        nodeA.connections.push(nodeB);
      }
    }
    
    // Create data packets that will travel along the connections
    const createDataPacket = () => {
      // Select random node to start from
      const startNode = nodes[Math.floor(Math.random() * nodes.length)];
      if (!startNode.connections.length) return null;
      
      // Select random connection
      const endNode = startNode.connections[Math.floor(Math.random() * startNode.connections.length)];
      
      return {
        startNode,
        endNode,
        progress: 0,
        speed: 0.005 + Math.random() * 0.01 * actualSpeed / 5,
        color: startNode.active && endNode.active 
          ? getHighlightColor(actualColor) 
          : actualColor,
        size: 1.5 + Math.random()
      };
    };
    
    // Animation parameters
    let dataPackets = [];
    const maxDataPackets = Math.max(5, Math.floor(nodes.length * 0.1)); // Up to 10% of nodes have packets
    
    // Initial data packets
    for (let i = 0; i < maxDataPackets / 3; i++) {
      const packet = createDataPacket();
      if (packet) dataPackets.push(packet);
    }
    
    // Animation loop
    let animationId;
    let lastTime = 0;
    
    const animate = (timestamp) => {
      if (!animate) {
        cancelAnimationFrame(animationId);
        return;
      }
      
      // Calculate time delta
      const delta = timestamp - lastTime;
      lastTime = timestamp;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Set line properties
      ctx.lineWidth = lineWidth;
      
      // Draw connections
      for (const node of nodes) {
        for (const connectedNode of node.connections) {
          // Determine line color
          const isActive = node.active && connectedNode.active;
          const lineColor = isActive 
            ? getHighlightColor(actualColor)
            : getRgbaFromVar(actualColor, 0.3);
          
          ctx.strokeStyle = lineColor;
          
          // Draw line
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(connectedNode.x, connectedNode.y);
          ctx.stroke();
        }
      }
      
      // Draw nodes
      for (const node of nodes) {
        // Update node pulse if enabled
        if (pulse) {
          node.pulsePhase += 0.02 * delta / 16;
          if (node.pulsePhase > Math.PI * 2) node.pulsePhase -= Math.PI * 2;
          
          // Calculate pulse factor
          const pulseFactor = node.pulseFactor * (0.7 + 0.3 * Math.sin(node.pulsePhase));
          
          // Draw glow
          if (node.active) {
            const glowSize = nodeSize * 3;
            const gradient = ctx.createRadialGradient(
              node.x, node.y, nodeSize,
              node.x, node.y, glowSize
            );
            
            const glowColor = getHighlightColor(actualColor);
            gradient.addColorStop(0, glowColor);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(node.x, node.y, glowSize * pulseFactor, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Draw node
        ctx.fillStyle = node.active 
          ? getHighlightColor(actualColor)
          : getRgbaFromVar(actualColor, 0.5);
        
        ctx.beginPath();
        ctx.arc(node.x, node.y, nodeSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Update and draw data packets
      for (let i = dataPackets.length - 1; i >= 0; i--) {
        const packet = dataPackets[i];
        
        // Update progress
        packet.progress += packet.speed * delta / 16;
        
        // Remove if complete
        if (packet.progress >= 1) {
          // Activate end node when packet arrives
          packet.endNode.active = true;
          
          // Remove packet
          dataPackets.splice(i, 1);
          continue;
        }
        
        // Calculate position
        const x = packet.startNode.x + (packet.endNode.x - packet.startNode.x) * packet.progress;
        const y = packet.startNode.y + (packet.endNode.y - packet.startNode.y) * packet.progress;
        
        // Draw packet
        ctx.fillStyle = packet.color;
        ctx.beginPath();
        ctx.arc(x, y, packet.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw glow
        const glowSize = packet.size * 3;
        const gradient = ctx.createRadialGradient(
          x, y, packet.size,
          x, y, glowSize
        );
        
        gradient.addColorStop(0, packet.color);
        gradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, glowSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Add new data packets occasionally
      if (animate && Math.random() < 0.05 * actualSpeed / 5 && dataPackets.length < maxDataPackets) {
        const packet = createDataPacket();
        if (packet) dataPackets.push(packet);
      }
      
      // Schedule next frame
      animationId = requestAnimationFrame(animate);
    };
    
    // Start animation if enabled
    if (animate) {
      animationId = requestAnimationFrame(animate);
    } else {
      // Just draw once
      animate(0);
    }
    
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [dimensions, actualColor, actualDensity, actualSpeed, theme, animate, pulse]);
  
  return (
    <div 
      className={`circuit-lines ${className}`}
      style={{ 
        width, 
        height, 
        position: 'relative',
        overflow: 'hidden',
        ...style
      }}
      {...props}
    >
      <canvas 
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%'
        }}
      />
    </div>
  );
};

// Helper functions
function getDensityValue(density) {
  switch (density) {
    case 'low':
      return 20;
    case 'medium':
      return 50;
    case 'high':
      return 80;
    default:
      return parseInt(density, 10) || 50;
  }
}

function getSpeedValue(speed) {
  switch (speed) {
    case 'slow':
      return 1;
    case 'medium':
      return 5;
    case 'fast':
      return 10;
    default:
      return parseInt(speed, 10) || 5;
  }
}

function getRgbaFromVar(cssVar, alpha = 1) {
  // Check if already rgba or rgb
  if (cssVar.startsWith('rgba(') || cssVar.startsWith('rgb(')) {
    return cssVar;
  }
  
  // Check if it's a CSS variable
  if (cssVar.startsWith('var(')) {
    // For demo purposes, return a fallback since we can't access CSS variables here
    if (cssVar.includes('accent-cyan')) {
      return `rgba(0, 255, 245, ${alpha})`;
    } else if (cssVar.includes('accent-blue')) {
      return `rgba(77, 77, 255, ${alpha})`;
    } else if (cssVar.includes('accent-magenta')) {
      return `rgba(255, 61, 61, ${alpha})`;
    }
    
    // Default fallback
    return `rgba(0, 255, 245, ${alpha})`;
  }
  
  // Default for regular color strings like #00fff5
  return cssVar;
}

function getHighlightColor(color) {
  // Check if already rgba or rgb
  if (color.startsWith('rgba(') || color.startsWith('rgb(')) {
    return color;
  }
  
  // Check if it's a CSS variable
  if (color.startsWith('var(')) {
    // For demo purposes, return a fallback since we can't access CSS variables here
    if (color.includes('accent-cyan')) {
      return 'rgba(0, 255, 245, 1)';
    } else if (color.includes('accent-blue')) {
      return 'rgba(77, 77, 255, 1)';
    } else if (color.includes('accent-magenta')) {
      return 'rgba(255, 61, 61, 1)';
    }
    
    // Default fallback
    return 'rgba(0, 255, 245, 1)';
  }
  
  // Default for regular color strings like #00fff5
  return color;
}

CircuitLines.propTypes = {
  color: PropTypes.string,
  density: PropTypes.oneOfType([
    PropTypes.oneOf(['low', 'medium', 'high']),
    PropTypes.number,
    PropTypes.string
  ]),
  animate: PropTypes.bool,
  pulse: PropTypes.bool,
  speed: PropTypes.oneOfType([
    PropTypes.oneOf(['slow', 'medium', 'fast']),
    PropTypes.number,
    PropTypes.string
  ]),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  className: PropTypes.string,
  style: PropTypes.object
};

export default CircuitLines;
</file>

<file path="frontend/src/components/common/CyberLoader.jsx">
import React, { useEffect, useState } from 'react';
import { useTheme } from '../../contexts/ThemeContext';

const CyberLoader = ({ message = 'LOADING NEURAL INTERFACE', fullScreen = true }) => {
  const { theme } = useTheme();
  const [loadingText, setLoadingText] = useState(message);
  const [dots, setDots] = useState('');
  const [progress, setProgress] = useState(0);
  const [glitchActive, setGlitchActive] = useState(false);

  // Simulate loading progress
  useEffect(() => {
    if (progress >= 100) return;

    const interval = setInterval(() => {
      setProgress(prev => {
        const increment = Math.random() * 3 + 1;
        return Math.min(prev + increment, 100);
      });
    }, 150);

    return () => clearInterval(interval);
  }, [progress]);

  // Animate loading dots
  useEffect(() => {
    const interval = setInterval(() => {
      setDots(prev => {
        if (prev.length >= 3) {
          return '';
        }
        return prev + '.';
      });
    }, 400);

    return () => clearInterval(interval);
  }, []);

  // Randomly trigger glitch effect
  useEffect(() => {
    const interval = setInterval(() => {
      setGlitchActive(true);
      
      setTimeout(() => {
        setGlitchActive(false);
      }, 200);
    }, 3000);

    return () => clearInterval(interval);
  }, []);

  // Generate random loading messages
  useEffect(() => {
    const messages = [
      'LOADING NEURAL INTERFACE',
      'CALIBRATING DIGITAL CORTEX',
      'SYNCING QUANTUM DATA',
      'BOOTSTRAPPING CYBERNETIC MODULES',
      'INITIALIZING REALITY MATRIX',
      'COMPILING NEURAL NETWORKS',
      'RENDERING DIGITAL ENVIRONMENT',
      'PROCESSING QUANTUM ALGORITHMS',
      'DECRYPTING NEURAL PATHWAYS'
    ];

    const interval = setInterval(() => {
      const randomMessage = messages[Math.floor(Math.random() * messages.length)];
      setLoadingText(randomMessage);
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  // Format progress as hex
  const hexProgress = Math.floor(progress).toString(16).padStart(2, '0').toUpperCase();

  return (
    <div className={`cyber-loader-container ${fullScreen ? 'fullscreen' : ''}`}>
      <div className="cyber-loader-content">
        <div className="cyber-loading">
          <div></div>
          <div></div>
          <div></div>
        </div>
        
        <div className={`cyber-loader-text ${glitchActive ? 'glitch-text' : ''}`} data-text={`${loadingText}${dots}`}>
          {loadingText}{dots}
        </div>
        
        <div className="cyber-loader-progress-container">
          <div className="cyber-loader-progress-bar">
            <div 
              className="cyber-loader-progress-fill"
              style={{ width: `${progress}%` }}
            ></div>
          </div>
          <div className="cyber-loader-progress-text">
            SYSTEM BOOT: <span className="hex-value">{hexProgress}</span> / FF
          </div>
        </div>
        
        <div className="cyber-loader-status">
          <div className={`cyber-loader-status-light ${progress < 100 ? 'active' : ''}`}></div>
          <div className="cyber-loader-status-text">
            {progress < 100 ? 'INITIALIZING' : 'COMPLETE'}
          </div>
        </div>
      </div>
      
      <style jsx>{`
        .cyber-loader-container {
          display: flex;
          justify-content: center;
          align-items: center;
          background-color: var(--bg-primary);
          z-index: 100;
        }
        
        .cyber-loader-container.fullscreen {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
        }
        
        .cyber-loader-content {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          max-width: 400px;
          padding: 2rem;
          border: 1px solid var(--accent-cyan);
          border-radius: 4px;
          background-color: rgba(0, 0, 0, 0.8);
          box-shadow: 0 0 20px rgba(0, 255, 245, 0.3);
          position: relative;
          overflow: hidden;
        }
        
        .cyber-loader-content::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-image: 
            linear-gradient(rgba(0, 255, 245, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 255, 245, 0.1) 1px, transparent 1px);
          background-size: 20px 20px;
          pointer-events: none;
        }
        
        .cyber-loader-text {
          font-family: var(--font-mono);
          font-size: 1rem;
          color: var(--accent-cyan);
          margin: 1.5rem 0;
          text-align: center;
          letter-spacing: 1px;
        }
        
        .cyber-loader-progress-container {
          width: 100%;
          margin-bottom: 1rem;
        }
        
        .cyber-loader-progress-bar {
          width: 100%;
          height: 4px;
          background-color: rgba(255, 255, 255, 0.1);
          border-radius: 2px;
          overflow: hidden;
          margin-bottom: 0.5rem;
        }
        
        .cyber-loader-progress-fill {
          height: 100%;
          background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
          border-radius: 2px;
          transition: width 0.2s ease;
        }
        
        .cyber-loader-progress-text {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--text-secondary);
          text-align: right;
        }
        
        .hex-value {
          color: var(--accent-cyan);
        }
        
        .cyber-loader-status {
          display: flex;
          align-items: center;
          margin-top: 1rem;
        }
        
        .cyber-loader-status-light {
          width: 10px;
          height: 10px;
          border-radius: 50%;
          background-color: var(--accent-magenta);
          margin-right: 0.5rem;
        }
        
        .cyber-loader-status-light.active {
          animation: blink 1s infinite;
        }
        
        .cyber-loader-status-text {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--accent-magenta);
        }
        
        @keyframes blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.3; }
        }
        
        /* Theme specific adjustments */
        .light-theme .cyber-loader-content {
          background-color: rgba(245, 245, 245, 0.9);
          border-color: var(--accent-blue);
          box-shadow: 0 0 20px rgba(77, 77, 255, 0.3);
        }
        
        .light-theme .cyber-loader-content::before {
          background-image: 
            linear-gradient(rgba(77, 77, 255, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(77, 77, 255, 0.1) 1px, transparent 1px);
        }
      `}</style>
    </div>
  );
};

export default CyberLoader;
</file>

<file path="frontend/src/components/common/DataStream.jsx">
import React, { useRef, useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useDataStream } from '../../hooks/useDataStream';

const DataStream = ({
  width = '100%',
  height = '100px',
  color = 'auto',
  density = 'medium',
  speed = 'medium',
  direction = 'right', // right, left, up, down
  mode = 'continuous', // continuous, wave, pulse
  className = '',
  style = {},
  children,
  ...props
}) => {
  const { theme } = useTheme();
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  
  // Generate primary color based on theme if color is set to auto
  const primaryColor = color === 'auto'
    ? theme === 'dark' ? 'var(--accent-cyan)' : 'var(--accent-blue)'
    : color;
  
  // Secondary color for contrast effects
  const secondaryColor = theme === 'dark' ? 'var(--accent-magenta)' : 'var(--accent-magenta)';
  
  // Convert props to actual values
  const actualDensity = typeof density === 'string' 
    ? getDensityValue(density) 
    : density;
    
  const actualSpeed = typeof speed === 'string'
    ? getSpeedValue(speed)
    : speed;
  
  // Initialize data stream with useDataStream hook
  const { startStream, stopStream, updateStreamConfig } = useDataStream(canvasRef, {
    density: actualDensity,
    speed: actualSpeed,
    direction,
    mode,
    primaryColor,
    secondaryColor
  });
  
  // Set canvas dimensions on mount and resize
  useEffect(() => {
    const updateDimensions = () => {
      if (!containerRef.current) return;
      
      const rect = containerRef.current.getBoundingClientRect();
      setDimensions({
        width: rect.width,
        height: rect.height
      });
    };
    
    window.addEventListener('resize', updateDimensions);
    updateDimensions();
    
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);
  
  // Start/stop data stream and update config when props change
  useEffect(() => {
    if (dimensions.width && dimensions.height) {
      updateStreamConfig({
        density: actualDensity,
        speed: actualSpeed,
        direction,
        mode,
        primaryColor,
        secondaryColor
      });
      
      startStream();
    }
    
    return () => stopStream();
  }, [
    dimensions,
    actualDensity,
    actualSpeed,
    direction,
    mode,
    primaryColor,
    secondaryColor,
    startStream,
    stopStream,
    updateStreamConfig
  ]);
  
  return (
    <motion.div
      ref={containerRef}
      className={`data-stream ${className}`}
      style={{
        width,
        height,
        position: 'relative',
        overflow: 'hidden',
        ...style
      }}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.5 }}
      {...props}
    >
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          zIndex: 0
        }}
      />
      
      {children && (
        <div className="data-stream-content" style={{
          position: 'relative',
          zIndex: 1,
          height: '100%',
          width: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          {children}
        </div>
      )}
    </motion.div>
  );
};

// Helper functions
function getDensityValue(density) {
  switch (density) {
    case 'low':
      return 30;
    case 'medium':
      return 70;
    case 'high':
      return 120;
    default:
      return 70;
  }
}

function getSpeedValue(speed) {
  switch (speed) {
    case 'slow':
      return 2;
    case 'medium':
      return 5;
    case 'fast':
      return 10;
    default:
      return 5;
  }
}

DataStream.propTypes = {
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
  density: PropTypes.oneOfType([
    PropTypes.oneOf(['low', 'medium', 'high']),
    PropTypes.number
  ]),
  speed: PropTypes.oneOfType([
    PropTypes.oneOf(['slow', 'medium', 'fast']),
    PropTypes.number
  ]),
  direction: PropTypes.oneOf(['right', 'left', 'up', 'down']),
  mode: PropTypes.oneOf(['continuous', 'wave', 'pulse']),
  className: PropTypes.string,
  style: PropTypes.object,
  children: PropTypes.node
};

export default DataStream;
</file>

<file path="frontend/src/components/common/GlitchText.jsx">
import React, { useState, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';
import { motion } from 'framer-motion';
import { useGlitch } from '../../hooks/useGlitch';

const GlitchText = ({
  text,
  color = 'var(--accent-cyan)',
  secondaryColor = 'var(--accent-magenta)',
  size = 'medium',
  intensity = 'medium',
  className = '',
  onHover = false,
  onClick = null,
  glitchOnMount = false,
  ...props
}) => {
  const [isGlitching, setIsGlitching] = useState(glitchOnMount);
  const textRef = useRef(null);
  const { startGlitch, stopGlitch } = useGlitch(textRef, {
    intensity: getIntensityValue(intensity),
    duration: 1500,
    continuousGlitch: isGlitching
  });
  
  // Convert size prop to CSS class
  const sizeClass = getSizeClass(size);
  
  // Apply initial glitch effect on mount if enabled
  useEffect(() => {
    if (glitchOnMount) {
      startGlitch();
    }
    
    return () => stopGlitch();
  }, [glitchOnMount, startGlitch, stopGlitch]);
  
  // Handle hover events if onHover is true
  const handleMouseEnter = () => {
    if (onHover) {
      setIsGlitching(true);
      startGlitch();
    }
  };
  
  const handleMouseLeave = () => {
    if (onHover) {
      setIsGlitching(false);
      stopGlitch();
    }
  };
  
  // Handle click events
  const handleClick = (e) => {
    // Trigger a short glitch effect on click
    startGlitch({ duration: 500 });
    
    // Call onClick prop if provided
    if (onClick) {
      onClick(e);
    }
  };
  
  return (
    <motion.div
      ref={textRef}
      className={`glitch-text-container ${className}`}
      data-text={text}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      onClick={handleClick}
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
      {...props}
    >
      <span className={`glitch-text ${sizeClass}`} style={{ color }}>
        {text}
      </span>
      
      <style jsx>{`
        .glitch-text-container {
          position: relative;
          display: inline-block;
          cursor: ${onClick ? 'pointer' : 'default'};
        }
        
        .glitch-text {
          position: relative;
          display: inline-block;
          font-family: var(--font-display);
          font-weight: 700;
          letter-spacing: 1px;
        }
        
        .glitch-text-size-small {
          font-size: 1rem;
        }
        
        .glitch-text-size-medium {
          font-size: 1.5rem;
        }
        
        .glitch-text-size-large {
          font-size: 2.5rem;
        }
        
        .glitch-text-size-xlarge {
          font-size: 4rem;
        }
        
        .glitch-text-container::before,
        .glitch-text-container::after {
          content: attr(data-text);
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          color: ${color};
          opacity: 0.8;
          clip: rect(0, 0, 0, 0);
        }
        
        .glitch-text-container::before {
          left: -2px;
          text-shadow: 1px 0 ${secondaryColor};
          animation: ${isGlitching ? 'glitch-anim-1 3s infinite linear alternate-reverse' : 'none'};
        }
        
        .glitch-text-container::after {
          left: 2px;
          text-shadow: -1px 0 ${color};
          animation: ${isGlitching ? 'glitch-anim-2 2s infinite linear alternate-reverse' : 'none'};
        }
        
        @keyframes glitch-anim-1 {
          0%, 100% { clip: rect(0, 9999px, 5px, 0); transform: skewX(0.2deg); }
          20% { clip: rect(0, 9999px, 51px, 0); transform: skewX(0.1deg); }
          40% { clip: rect(0, 9999px, 32px, 0); transform: skewX(0.2deg); }
          60% { clip: rect(0, 9999px, 92px, 0); transform: skewX(-0.1deg); }
          80% { clip: rect(0, 9999px, 18px, 0); transform: skewX(-0.2deg); }
        }
        
        @keyframes glitch-anim-2 {
          0%, 100% { clip: rect(0, 9999px, 24px, 0); transform: skewX(0.3deg); }
          20% { clip: rect(0, 9999px, 63px, 0); transform: skewX(-0.1deg); }
          40% { clip: rect(0, 9999px, 79px, 0); transform: skewX(0.1deg); }
          60% { clip: rect(0, 9999px, 35px, 0); transform: skewX(0.4deg); }
          80% { clip: rect(0, 9999px, 46px, 0); transform: skewX(0deg); }
        }
      `}</style>
    </motion.div>
  );
};

// Helper functions
function getIntensityValue(intensity) {
  switch (intensity) {
    case 'low':
      return 3;
    case 'medium':
      return 5;
    case 'high':
      return 8;
    case 'extreme':
      return 10;
    default:
      return parseInt(intensity, 10) || 5;
  }
}

function getSizeClass(size) {
  switch (size) {
    case 'small':
      return 'glitch-text-size-small';
    case 'medium':
      return 'glitch-text-size-medium';
    case 'large':
      return 'glitch-text-size-large';
    case 'xlarge':
      return 'glitch-text-size-xlarge';
    default:
      return 'glitch-text-size-medium';
  }
}

GlitchText.propTypes = {
  text: PropTypes.string.isRequired,
  color: PropTypes.string,
  secondaryColor: PropTypes.string,
  size: PropTypes.oneOfType([
    PropTypes.oneOf(['small', 'medium', 'large', 'xlarge']),
    PropTypes.string
  ]),
  intensity: PropTypes.oneOfType([
    PropTypes.oneOf(['low', 'medium', 'high', 'extreme']),
    PropTypes.number,
    PropTypes.string
  ]),
  className: PropTypes.string,
  onHover: PropTypes.bool,
  onClick: PropTypes.func,
  glitchOnMount: PropTypes.bool
};

export default GlitchText;
</file>

<file path="frontend/src/components/common/HolographicCard.jsx">
import React, { useRef, useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useHolographicEffect } from '../../hooks/useHolographicEffect';

const HolographicCard = ({
  children,
  width = '100%',
  height = 'auto',
  color = 'auto',
  borderSize = 'medium',
  glowIntensity = 'medium',
  interactive = true,
  glassEffect = true,
  corners = 'standard',
  header,
  footer,
  className = '',
  style = {},
  ...props
}) => {
  const { theme } = useTheme();
  const cardRef = useRef(null);
  const [isHovered, setIsHovered] = useState(false);
  
  // Generate color based on theme if color is set to auto
  const cardColor = color === 'auto'
    ? theme === 'dark' ? 'var(--accent-cyan)' : 'var(--accent-blue)'
    : color;
  
  // Convert props to CSS values
  const borderWidth = getBorderSize(borderSize);
  const borderRadius = getCornerSize(corners);
  const glowSize = getGlowIntensity(glowIntensity);
  
  // Initialize holographic effect
  const { 
    startHolographicEffect,
    stopHolographicEffect,
    updateHolographicConfig 
  } = useHolographicEffect(cardRef, {
    color: cardColor,
    intensity: getNumberFromIntensity(glowIntensity),
    interactive
  });
  
  // Apply holographic effect when card is mounted
  useEffect(() => {
    if (interactive) {
      startHolographicEffect();
    }
    
    return () => stopHolographicEffect();
  }, [interactive, startHolographicEffect, stopHolographicEffect]);
  
  // Update effect config when props change
  useEffect(() => {
    updateHolographicConfig({
      color: cardColor,
      intensity: getNumberFromIntensity(glowIntensity)
    });
  }, [cardColor, glowIntensity, updateHolographicConfig]);
  
  // Handle hover events
  const handleMouseEnter = () => {
    if (interactive) {
      setIsHovered(true);
    }
  };
  
  const handleMouseLeave = () => {
    if (interactive) {
      setIsHovered(false);
    }
  };
  
  return (
    <motion.div
      ref={cardRef}
      className={`holographic-card ${className} ${glassEffect ? 'glass-effect' : ''}`}
      style={{
        width,
        height,
        borderWidth,
        borderRadius,
        borderColor: cardColor,
        boxShadow: `0 0 ${glowSize}px ${isHovered ? glowSize * 2 : glowSize}px ${cardColor}`,
        ...style
      }}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      {...props}
    >
      {header && (
        <div className="holographic-card-header">
          {header}
        </div>
      )}
      
      <div className="holographic-card-content">
        {children}
      </div>
      
      {footer && (
        <div className="holographic-card-footer">
          {footer}
        </div>
      )}
      
      <style jsx>{`
        .holographic-card {
          position: relative;
          border-style: solid;
          background-color: ${theme === 'dark' 
            ? 'rgba(10, 10, 10, 0.7)' 
            : 'rgba(245, 245, 245, 0.7)'};
          overflow: hidden;
          transition: all 0.3s ease-out;
          display: flex;
          flex-direction: column;
          transform-style: preserve-3d;
          perspective: 1000px;
        }
        
        .holographic-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(
            135deg,
            transparent 0%,
            rgba(${cardColor === 'var(--accent-cyan)' 
              ? '0, 255, 245' 
              : cardColor === 'var(--accent-blue)' 
                ? '77, 77, 255' 
                : '0, 255, 245'}, 0.1) 50%,
            transparent 100%
          );
          z-index: 1;
          pointer-events: none;
          transform: translateZ(1px);
          opacity: ${isHovered ? 0.8 : 0.3};
          transition: opacity 0.3s ease;
        }
        
        .holographic-card.glass-effect::after {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          backdrop-filter: blur(8px);
          z-index: -1;
        }
        
        .holographic-card-header {
          padding: 1rem;
          border-bottom: 1px solid ${cardColor};
          z-index: 2;
        }
        
        .holographic-card-content {
          padding: 1rem;
          flex: 1;
          z-index: 2;
          position: relative;
        }
        
        .holographic-card-footer {
          padding: 1rem;
          border-top: 1px solid ${cardColor};
          z-index: 2;
        }
      `}</style>
    </motion.div>
  );
};

// Helper functions
function getBorderSize(size) {
  switch (size) {
    case 'none':
      return '0';
    case 'small':
      return '1px';
    case 'medium':
      return '2px';
    case 'large':
      return '3px';
    default:
      return size;
  }
}

function getCornerSize(corners) {
  switch (corners) {
    case 'sharp':
      return '0';
    case 'standard':
      return 'var(--border-radius-md)';
    case 'rounded':
      return 'var(--border-radius-lg)';
    case 'circular':
      return '50%';
    default:
      return corners;
  }
}

function getGlowIntensity(intensity) {
  switch (intensity) {
    case 'none':
      return '0';
    case 'low':
      return '5px';
    case 'medium':
      return '10px';
    case 'high':
      return '20px';
    case 'extreme':
      return '30px';
    default:
      return intensity;
  }
}

function getNumberFromIntensity(intensity) {
  switch (intensity) {
    case 'none':
      return 0;
    case 'low':
      return 3;
    case 'medium':
      return 5;
    case 'high':
      return 8;
    case 'extreme':
      return 10;
    default:
      return 5;
  }
}

HolographicCard.propTypes = {
  children: PropTypes.node.isRequired,
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  color: PropTypes.string,
  borderSize: PropTypes.oneOfType([
    PropTypes.oneOf(['none', 'small', 'medium', 'large']),
    PropTypes.string
  ]),
  glowIntensity: PropTypes.oneOfType([
    PropTypes.oneOf(['none', 'low', 'medium', 'high', 'extreme']),
    PropTypes.string
  ]),
  interactive: PropTypes.bool,
  glassEffect: PropTypes.bool,
  corners: PropTypes.oneOfType([
    PropTypes.oneOf(['sharp', 'standard', 'rounded', 'circular']),
    PropTypes.string
  ]),
  header: PropTypes.node,
  footer: PropTypes.node,
  className: PropTypes.string,
  style: PropTypes.object
};

export default HolographicCard;
</file>

<file path="frontend/src/components/common/NeonButton.jsx">
import React, { useState, useRef, useEffect } from 'react';
import PropTypes from 'prop-types';
import { motion } from 'framer-motion';
import { useAudio } from '../../contexts/AudioContext';

const NeonButton = ({
  children,
  color = 'var(--accent-cyan)',
  size = 'medium',
  variant = 'primary',
  onClick,
  disabled = false,
  href,
  className = '',
  type = 'button',
  animate = true,
  icon,
  iconPosition = 'left',
  ...props
}) => {
  const { playSound } = useAudio();
  const [isHovered, setIsHovered] = useState(false);
  const [isPressed, setIsPressed] = useState(false);
  const buttonRef = useRef(null);
  
  // Handle button interactions
  const handleMouseEnter = () => {
    if (!disabled) {
      setIsHovered(true);
      playSound('hover');
    }
  };
  
  const handleMouseLeave = () => {
    if (!disabled) {
      setIsHovered(false);
    }
  };
  
  const handleMouseDown = () => {
    if (!disabled) {
      setIsPressed(true);
    }
  };
  
  const handleMouseUp = () => {
    if (!disabled) {
      setIsPressed(false);
    }
  };
  
  const handleClick = (e) => {
    if (!disabled) {
      playSound('click');
      if (onClick) {
        onClick(e);
      }
    }
  };
  
  // Add neon glow animation effect
  useEffect(() => {
    if (!buttonRef.current || !animate || disabled) return;
    
    const button = buttonRef.current;
    
    // Create keyframe animation for glow effect
    const pulseAnimation = button.animate(
      [
        { boxShadow: `0 0 5px ${color}, 0 0 10px ${color}` },
        { boxShadow: `0 0 10px ${color}, 0 0 20px ${color}` },
        { boxShadow: `0 0 5px ${color}, 0 0 10px ${color}` }
      ],
      {
        duration: 2000,
        iterations: Infinity,
        easing: 'ease-in-out'
      }
    );
    
    // Pause animation by default if not hovered
    if (!isHovered) {
      pulseAnimation.pause();
    } else {
      pulseAnimation.play();
    }
    
    return () => {
      pulseAnimation.cancel();
    };
  }, [animate, color, disabled, isHovered]);
  
  // Get size and variant classes
  const sizeClass = getSizeClass(size);
  const variantClass = getVariantClass(variant);
  
  // Determine component (button or anchor)
  const Component = href ? 'a' : 'button';
  
  // Generate dynamic styles based on props
  const dynamicStyles = {
    '--button-color': color,
    '--button-hover-color': color,
    '--button-active-color': color,
  };
  
  // Animation variants for motion
  const buttonVariants = {
    hover: { 
      y: -2,
      boxShadow: `0 0 15px ${color}, 0 0 5px ${color}`,
      transition: { duration: 0.2 }
    },
    pressed: { 
      y: 1, 
      boxShadow: `0 0 5px ${color}`,
      transition: { duration: 0.1 }
    },
    disabled: {
      opacity: 0.6,
      boxShadow: 'none',
      cursor: 'not-allowed'
    }
  };
  
  return (
    <motion.div
      className={`neon-button-container ${className}`}
      initial={false}
      animate={
        disabled 
          ? 'disabled' 
          : isPressed 
            ? 'pressed' 
            : isHovered 
              ? 'hover' 
              : 'initial'
      }
      variants={buttonVariants}
      style={dynamicStyles}
      onHoverStart={handleMouseEnter}
      onHoverEnd={handleMouseLeave}
    >
      <Component
        ref={buttonRef}
        className={`neon-button ${sizeClass} ${variantClass} ${disabled ? 'disabled' : ''}`}
        onClick={handleClick}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        href={href}
        disabled={disabled}
        type={!href ? type : undefined}
        {...props}
      >
        {icon && iconPosition === 'left' && (
          <span className="neon-button-icon left">{icon}</span>
        )}
        
        <span className="neon-button-text">{children}</span>
        
        {icon && iconPosition === 'right' && (
          <span className="neon-button-icon right">{icon}</span>
        )}
        
        <span className="neon-button-glow"></span>
        <span className="neon-button-border"></span>
      </Component>
      
      <style jsx>{`
        .neon-button-container {
          position: relative;
          display: inline-block;
          overflow: hidden;
          border-radius: var(--border-radius-sm);
        }
        
        .neon-button {
          position: relative;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          font-family: var(--font-display);
          text-transform: uppercase;
          letter-spacing: 1px;
          transition: all var(--transition-normal);
          background-color: transparent;
          border: none;
          color: var(--button-color);
          outline: none;
          cursor: none;
          overflow: hidden;
          text-decoration: none;
          width: 100%;
          z-index: 1;
        }
        
        .neon-button::before {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(
            90deg,
            transparent 0%,
            rgba(var(--button-color-rgb), 0.2) 50%,
            transparent 100%
          );
          transition: left var(--transition-normal);
          z-index: -1;
        }
        
        .neon-button:hover::before {
          left: 100%;
        }
        
        .neon-button.disabled::before {
          display: none;
        }
        
        .neon-button-text {
          position: relative;
          z-index: 2;
        }
        
        .neon-button-icon {
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 2;
        }
        
        .neon-button-icon.left {
          margin-right: var(--space-xs);
        }
        
        .neon-button-icon.right {
          margin-left: var(--space-xs);
        }
        
        .neon-button-glow {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: -1;
          opacity: 0;
          transition: opacity var(--transition-normal);
          background: radial-gradient(
            circle at center,
            rgba(var(--button-color-rgb), 0.3) 0%,
            transparent 70%
          );
        }
        
        .neon-button:hover .neon-button-glow {
          opacity: 1;
        }
        
        .neon-button-border {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border: 1px solid var(--button-color);
          border-radius: var(--border-radius-sm);
          z-index: 0;
        }
        
        /* Size variants */
        .neon-button-size-small {
          padding: 0.5rem 1rem;
          font-size: 0.8rem;
          min-width: 100px;
        }
        
        .neon-button-size-medium {
          padding: 0.75rem 1.5rem;
          font-size: 1rem;
          min-width: 150px;
        }
        
        .neon-button-size-large {
          padding: 1rem 2rem;
          font-size: 1.2rem;
          min-width: 200px;
        }
        
        /* Style variants */
        .neon-button-variant-primary {
          background-color: rgba(var(--button-color-rgb), 0.1);
        }
        
        .neon-button-variant-outline {
          background-color: transparent;
        }
        
        .neon-button-variant-ghost {
          background-color: transparent;
        }
        
        .neon-button-variant-ghost .neon-button-border {
          border-style: dashed;
          opacity: 0.7;
        }
        
        .neon-button-variant-filled {
          background-color: var(--button-color);
          color: var(--bg-primary);
        }
        
        .neon-button-variant-filled:hover {
          background-color: transparent;
          color: var(--button-color);
        }
        
        /* Disabled state */
        .neon-button.disabled {
          opacity: 0.6;
          cursor: not-allowed;
          pointer-events: none;
        }
      `}</style>
    </motion.div>
  );
};

// Helper functions
function getSizeClass(size) {
  switch (size) {
    case 'small':
      return 'neon-button-size-small';
    case 'medium':
      return 'neon-button-size-medium';
    case 'large':
      return 'neon-button-size-large';
    default:
      return 'neon-button-size-medium';
  }
}

function getVariantClass(variant) {
  switch (variant) {
    case 'primary':
      return 'neon-button-variant-primary';
    case 'outline':
      return 'neon-button-variant-outline';
    case 'ghost':
      return 'neon-button-variant-ghost';
    case 'filled':
      return 'neon-button-variant-filled';
    default:
      return 'neon-button-variant-primary';
  }
}

NeonButton.propTypes = {
  children: PropTypes.node.isRequired,
  color: PropTypes.string,
  size: PropTypes.oneOf(['small', 'medium', 'large']),
  variant: PropTypes.oneOf(['primary', 'outline', 'ghost', 'filled']),
  onClick: PropTypes.func,
  disabled: PropTypes.bool,
  href: PropTypes.string,
  className: PropTypes.string,
  type: PropTypes.string,
  animate: PropTypes.bool,
  icon: PropTypes.node,
  iconPosition: PropTypes.oneOf(['left', 'right'])
};

export default NeonButton;
</file>

<file path="frontend/src/components/common/ParticleGridBackground.jsx">
import React, { useEffect, useRef } from 'react';
import { useTheme } from '../../contexts/ThemeContext';

const ParticleGridBackground = ({ 
  density = 'medium',
  speed = 'medium',
  direction = 'right', // 'right', 'left', 'up', 'down'
  opacity = 0.5,
  className = '',
  style = {},
  ...props
}) => {
  const canvasRef = useRef(null);
  const { theme } = useTheme();
  
  // Convert props to actual values
  const particleDensity = getDensityValue(density);
  const animationSpeed = getSpeedValue(speed);
  
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Resize handler
    const handleResize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    
    window.addEventListener('resize', handleResize);
    handleResize();
    
    // Colors based on theme
    const primaryColor = theme === 'dark' ? 'rgba(0, 255, 245, 0.7)' : 'rgba(77, 77, 255, 0.7)';
    const secondaryColor = 'rgba(255, 61, 61, 0.7)';
    const gridColor = theme === 'dark' ? 'rgba(30, 30, 40, 0.3)' : 'rgba(180, 180, 240, 0.3)';
    
    // Create grid
    const gridSize = 40;
    const cols = Math.ceil(canvas.width / gridSize) + 1; // +1 to allow smooth scrolling
    const rows = Math.ceil(canvas.height / gridSize) + 1;
    
    // Create particles
    const particles = [];
    const particleCount = Math.floor(particleDensity * (canvas.width * canvas.height) / 8000);
    
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 2 + 1,
        color: Math.random() > 0.8 ? secondaryColor : primaryColor,
        opacity: 0.3 + Math.random() * 0.5,
        speed: Math.random() * 0.5 + 0.5
      });
    }
    
    // Calculate movement direction
    const getDirectionVector = () => {
      switch (direction) {
        case 'right': return { x: 1, y: 0 };
        case 'left': return { x: -1, y: 0 };
        case 'up': return { x: 0, y: -1 };
        case 'down': return { x: 0, y: 1 };
        default: return { x: 1, y: 0 };
      }
    };
    
    const dirVector = getDirectionVector();
    
    // Animation variables
    let gridOffset = 0;
    let animationId;
    
    const animate = () => {
      // Clear the canvas with a semi-transparent background for trail effect
      ctx.fillStyle = theme === 'dark' 
        ? 'rgba(5, 5, 5, 0.1)' 
        : 'rgba(245, 245, 245, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Update grid offset for scrolling effect
      gridOffset = (gridOffset + animationSpeed * 0.2) % gridSize;
      
      // Draw grid
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      
      // Vertical lines with scrolling
      for (let x = 0; x < cols; x++) {
        const posX = x * gridSize - gridOffset * dirVector.x;
        ctx.beginPath();
        ctx.moveTo(posX, 0);
        ctx.lineTo(posX, canvas.height);
        ctx.stroke();
      }
      
      // Horizontal lines with scrolling
      for (let y = 0; y < rows; y++) {
        const posY = y * gridSize - gridOffset * dirVector.y;
        ctx.beginPath();
        ctx.moveTo(0, posY);
        ctx.lineTo(canvas.width, posY);
        ctx.stroke();
      }
      
      // Update and draw particles
      for (const particle of particles) {
        // Move particle
        particle.x += dirVector.x * particle.speed * animationSpeed;
        particle.y += dirVector.y * particle.speed * animationSpeed;
        
        // Wrap around edges
        if (particle.x < -particle.size) particle.x = canvas.width + particle.size;
        if (particle.x > canvas.width + particle.size) particle.x = -particle.size;
        if (particle.y < -particle.size) particle.y = canvas.height + particle.size;
        if (particle.y > canvas.height + particle.size) particle.y = -particle.size;
        
        // Draw particle
        ctx.globalAlpha = particle.opacity * opacity;
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      // Continue animation
      animationId = requestAnimationFrame(animate);
    };
    
    // Start animation
    animate();
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationId);
    };
  }, [theme, particleDensity, animationSpeed, direction, opacity]);
  
  return (
    <canvas
      ref={canvasRef}
      className={`particle-grid-background ${className}`}
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        zIndex: 0,
        ...style
      }}
      {...props}
    />
  );
};

// Helper functions
function getDensityValue(density) {
  switch (density) {
    case 'low': return 0.5;
    case 'medium': return 1;
    case 'high': return 2;
    default: return typeof density === 'number' ? density : 1;
  }
}

function getSpeedValue(speed) {
  switch (speed) {
    case 'slow': return 0.5;
    case 'medium': return 1;
    case 'fast': return 2;
    default: return typeof speed === 'number' ? speed : 1;
  }
}

export default ParticleGridBackground;
</file>

<file path="frontend/src/components/layout/DigitalFooter.jsx">
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { useTheme } from '../../contexts/ThemeContext';
import { useAudio } from '../../contexts/AudioContext';

const DigitalFooter = () => {
  const { theme } = useTheme();
  const { playSound } = useAudio();
  const [currentTime, setCurrentTime] = useState(new Date());
  const [performanceStats, setPerformanceStats] = useState({
    fps: 0,
    memory: 0,
    latency: 0
  });

  // Update current time every second
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  // Simulate performance monitoring
  useEffect(() => {
    let frameCount = 0;
    let lastTime = performance.now();
    let frameId;

    const updateStats = () => {
      const now = performance.now();
      const elapsed = now - lastTime;
      
      if (elapsed >= 1000) {
        // Calculate FPS
        const fps = Math.round((frameCount * 1000) / elapsed);
        
        // Simulate memory usage (in MB)
        const memory = Math.round(100 + Math.random() * 50);
        
        // Simulate network latency (in ms)
        const latency = Math.round(20 + Math.random() * 30);
        
        setPerformanceStats({
          fps,
          memory,
          latency
        });
        
        frameCount = 0;
        lastTime = now;
      }
      
      frameCount++;
      frameId = requestAnimationFrame(updateStats);
    };

    frameId = requestAnimationFrame(updateStats);

    return () => cancelAnimationFrame(frameId);
  }, []);

  // Format time as HH:MM:SS
  const formatTime = (date) => {
    return date.toLocaleTimeString('en-US', { 
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  };

  // Format date as YYYY.MM.DD
  const formatDate = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    
    return `${year}.${month}.${day}`;
  };

  // Footer links
  const footerLinks = [
    { text: 'Home', path: '/' },
    { text: 'Projects', path: '/projects' },
    { text: 'Contact', path: '/contact' },
    { text: 'Privacy', path: '/privacy' }
  ];

  // Social links
  const socialLinks = [
    { text: 'GitHub', url: 'https://github.com/username', icon: 'G' },
    { text: 'LinkedIn', url: 'https://linkedin.com/in/username', icon: 'L' },
    { text: 'Twitter', url: 'https://twitter.com/username', icon: 'T' }
  ];

  return (
    <footer className="digital-footer">
      <div className="footer-background"></div>
      
      <div className="footer-container">
        <div className="footer-left">
          <div className="system-stats">
            <div className="stat-item">
              <span className="stat-label">FPS</span>
              <span className="stat-value">{performanceStats.fps}</span>
            </div>
            <div className="stat-item">
              <span className="stat-label">MEM</span>
              <span className="stat-value">{performanceStats.memory}MB</span>
            </div>
            <div className="stat-item">
              <span className="stat-label">NET</span>
              <span className="stat-value">{performanceStats.latency}ms</span>
            </div>
          </div>
        </div>
        
        <div className="footer-center">
          <div className="footer-links">
            {footerLinks.map((link, index) => (
              <React.Fragment key={index}>
                <Link 
                  to={link.path}
                  className="footer-link"
                  onClick={() => playSound('click')}
                >
                  {link.text}
                </Link>
                {index < footerLinks.length - 1 && <span className="divider">|</span>}
              </React.Fragment>
            ))}
          </div>
          
          <div className="copyright">
            <span className="copyright-symbol">Â©</span> {new Date().getFullYear()} CYBERPUNK PORTFOLIO
          </div>
        </div>
        
        <div className="footer-right">
          <div className="time-display">
            <div className="time-value">{formatTime(currentTime)}</div>
            <div className="date-value">{formatDate(currentTime)}</div>
          </div>
          
          <div className="social-links">
            {socialLinks.map((link, index) => (
              <a 
                key={index} 
                href={link.url} 
                target="_blank" 
                rel="noopener noreferrer"
                className="social-link"
                onClick={() => playSound('click')}
              >
                <span className="social-icon">{link.icon}</span>
              </a>
            ))}
          </div>
        </div>
      </div>
      
      <style jsx>{`
        .digital-footer {
          position: fixed;
          bottom: 0;
          left: 0;
          width: 100%;
          height: var(--footer-height);
          z-index: var(--z-dropdown);
          font-family: var(--font-mono);
          font-size: 0.8rem;
        }
        
        .footer-background {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(10, 10, 10, 0.8);
          backdrop-filter: blur(10px);
          border-top: 1px solid var(--accent-cyan);
          z-index: -1;
          overflow: hidden;
        }
        
        .footer-background::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 1px;
          background: linear-gradient(90deg, 
            transparent, 
            var(--accent-cyan), 
            transparent
          );
          animation: footer-scan 4s linear infinite;
        }
        
        .footer-container {
          display: flex;
          justify-content: space-between;
          align-items: center;
          height: 100%;
          padding: 0 1.5rem;
        }
        
        .footer-left,
        .footer-center,
        .footer-right {
          display: flex;
          align-items: center;
          height: 100%;
        }
        
        .footer-center {
          flex-direction: column;
          justify-content: center;
        }
        
        .footer-right {
          flex-direction: column;
          align-items: flex-end;
          justify-content: center;
          min-width: 120px; /* Ensure minimum width for time display */
        }
        
        .system-stats {
          display: flex;
          align-items: center;
        }
        
        .stat-item {
          display: flex;
          align-items: center;
          margin-right: 1rem;
        }
        
        .stat-label {
          color: var(--text-secondary);
          margin-right: 0.5rem;
        }
        
        .stat-value {
          color: var(--accent-cyan);
          font-weight: 500;
        }
        
        .footer-links {
          display: flex;
          align-items: center;
          margin-bottom: 0.5rem;
        }
        
        .footer-link {
          color: var(--text-secondary);
          transition: color 0.3s ease;
        }
        
        .footer-link:hover {
          color: var(--accent-cyan);
        }
        
        .footer-link::after {
          display: none;
        }
        
        .divider {
          margin: 0 0.5rem;
          color: var(--text-tertiary);
        }
        
        .copyright {
          color: var(--text-tertiary);
          font-size: 0.7rem;
        }
        
        .copyright-symbol {
          color: var(--accent-cyan);
        }
        
        .time-display {
          text-align: right;
          margin-bottom: 0.5rem;
          width: 100%;
          padding-right: 5px;
        }
        
        .time-value {
          color: var(--accent-cyan);
          font-weight: 500;
          font-size: 0.9rem; /* Slightly smaller font to fit */
          white-space: nowrap; /* Prevent line breaks */
        }
        
        .date-value {
          color: var(--text-secondary);
          font-size: 0.7rem;
          white-space: nowrap; /* Prevent line breaks */
        }
        
        .social-links {
          display: flex;
          align-items: center;
        }
        
        .social-link {
          display: flex;
          align-items: center;
          justify-content: center;
          width: 24px;
          height: 24px;
          border-radius: 50%;
          background-color: rgba(0, 255, 245, 0.1);
          color: var(--accent-cyan);
          margin-left: 0.5rem;
          transition: all 0.3s ease;
        }
        
        .social-link:hover {
          background-color: var(--accent-cyan);
          color: var(--bg-primary);
          transform: translateY(-2px);
        }
        
        .social-link::after {
          display: none;
        }
        
        .social-icon {
          font-size: 0.8rem;
          font-weight: 700;
        }
        
        /* Light theme styles */
        .light-theme .footer-background {
          background-color: rgba(245, 245, 245, 0.8);
          border-top: 1px solid var(--accent-blue);
        }
        
        .light-theme .footer-background::before {
          background: linear-gradient(90deg, 
            transparent, 
            var(--accent-blue), 
            transparent
          );
        }
        
        .light-theme .stat-value,
        .light-theme .time-value,
        .light-theme .copyright-symbol {
          color: var(--accent-blue);
        }
        
        .light-theme .footer-link:hover {
          color: var(--accent-blue);
        }
        
        .light-theme .social-link {
          background-color: rgba(77, 77, 255, 0.1);
          color: var(--accent-blue);
        }
        
        .light-theme .social-link:hover {
          background-color: var(--accent-blue);
          color: var(--bg-primary);
        }
        
        @keyframes footer-scan {
          0%, 100% {
            transform: translateX(-100%);
          }
          50% {
            transform: translateX(100%);
          }
        }
        
        /* Media queries */
        @media (max-width: 768px) {
          .footer-container {
            padding: 0 1rem;
          }
          
          .system-stats {
            display: none;
          }
          
          .footer-right {
            min-width: 100px;
          }
        }
        
        @media (max-width: 480px) {
          .digital-footer {
            height: auto;
            min-height: var(--footer-height);
          }
          
          .footer-container {
            flex-direction: column;
            padding: 0.8rem 1rem;
            height: auto;
          }
          
          .footer-left,
          .footer-center,
          .footer-right {
            width: 100%;
            justify-content: center;
            margin-bottom: 0.5rem;
          }
          
          .footer-right {
            align-items: center;
          }
          
          .time-display {
            text-align: center;
            padding-right: 0;
          }
        }
      `}</style>
    </footer>
  );
};

export default DigitalFooter;
</file>

<file path="frontend/src/components/layout/HolographicNav.jsx">
import React, { useState, useEffect, useRef } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useAudio } from '../../contexts/AudioContext';

const HolographicNav = () => {
  const { theme, toggleTheme } = useTheme();
  const { audioEnabled, toggleAudio, playSound } = useAudio();
  const [isOpen, setIsOpen] = useState(false);
  const [menuHoveredItem, setMenuHoveredItem] = useState(null);
  const navRef = useRef(null);
  const location = useLocation();

  // Close menu when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (navRef.current && !navRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // Close menu when route changes
  useEffect(() => {
    setIsOpen(false);
  }, [location.pathname]);

  // Toggle the menu
  const toggleMenu = () => {
    setIsOpen((prev) => !prev);
    playSound('click');
  };

  // Handle hover on menu items
  const handleMenuHover = (index) => {
    setMenuHoveredItem(index);
  };

  // Navigation items
  const navItems = [
    { title: 'HOME', path: '/', icon: 'âŒ‚' },
    { title: 'PROJECTS', path: '/projects', icon: 'âš™' },
    { title: 'EXPERIENCE', path: '/experience', icon: 'âš¡' },
    { title: 'TECH STACK', path: '/tech-stack', icon: 'âš›' },
    { title: 'TERMINAL', path: '/terminal', icon: '>' },
    { title: 'RESUME', path: '/resume', icon: 'âŠž' },
    { title: 'CONTACT', path: '/contact', icon: 'âœ‰' },
  ];

  // Animation variants for the menu
  const menuVariants = {
    closed: {
      opacity: 0,
      x: -20,
      transition: {
        staggerChildren: 0.05,
        staggerDirection: -1,
      },
    },
    open: {
      opacity: 1,
      x: 0,
      transition: {
        staggerChildren: 0.1,
        delayChildren: 0.2,
      },
    },
  };

  const itemVariants = {
    closed: { opacity: 0, x: -20 },
    open: { opacity: 1, x: 0 },
  };

  return (
    <header className="holographic-nav" ref={navRef}>
      <div className="nav-container">
        <div className="nav-logo">
          <Link to="/" onClick={() => playSound('click')}>
            <div className="logo-container">
              <div className="logo-symbol">C</div>
              <div className="logo-text">PORTFOLIO</div>
            </div>
          </Link>
        </div>

        <div className="nav-controls">
          <button 
            className="theme-toggle" 
            onClick={() => {
              toggleTheme();
              playSound('click');
            }}
            aria-label={`Switch to ${theme === 'dark' ? 'light' : 'dark'} mode`}
          >
            {theme === 'dark' ? 'â˜€' : 'â˜¾'}
          </button>
          
          <button 
            className="audio-toggle" 
            onClick={() => {
              toggleAudio();
              playSound('click');
            }}
            aria-label={`${audioEnabled ? 'Disable' : 'Enable'} audio`}
          >
            {audioEnabled ? 'â™«' : 'â™ª'}
          </button>
          
          <button 
            className={`menu-toggle ${isOpen ? 'active' : ''}`} 
            onClick={toggleMenu}
            aria-expanded={isOpen}
            aria-label="Toggle navigation menu"
          >
            <div className="menu-toggle-line"></div>
            <div className="menu-toggle-line"></div>
            <div className="menu-toggle-line"></div>
          </button>
        </div>
      </div>
      
      <AnimatePresence>
        {isOpen && (
          <motion.nav 
            className="nav-menu"
            initial="closed"
            animate="open"
            exit="closed"
            variants={menuVariants}
          >
            <div className="menu-background holographic"></div>
            <div className="menu-content">
              {navItems.map((item, index) => {
                const isActive = location.pathname === item.path;
                
                return (
                  <motion.div 
                    key={index}
                    className={`menu-item ${isActive ? 'active' : ''}`}
                    variants={itemVariants}
                    onMouseEnter={() => handleMenuHover(index)}
                    onMouseLeave={() => handleMenuHover(null)}
                  >
                    <Link 
                      to={item.path} 
                      className={`menu-link ${menuHoveredItem === index ? 'hovered' : ''}`}
                      onClick={() => playSound('click')}
                    >
                      <span className="menu-icon">{item.icon}</span>
                      <span className="menu-title">{item.title}</span>
                      {isActive && (
                        <span className="menu-active-indicator"></span>
                      )}
                    </Link>
                    {menuHoveredItem === index && (
                      <div className="menu-hover-effect"></div>
                    )}
                  </motion.div>
                );
              })}
            </div>
          </motion.nav>
        )}
      </AnimatePresence>
      
      <style jsx>{`
        .holographic-nav {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          z-index: var(--z-dropdown);
          font-family: var(--font-display);
        }
        
        .nav-container {
          display: flex;
          justify-content: space-between;
          align-items: center;
          height: var(--header-height);
          padding: 0 1.5rem;
          background-color: rgba(10, 10, 10, 0.8);
          backdrop-filter: blur(10px);
          border-bottom: 1px solid var(--accent-cyan);
          position: relative;
          overflow: hidden;
        }
        
        .nav-container::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient(90deg, transparent, rgba(0, 255, 245, 0.1), transparent);
          animation: nav-glow 8s linear infinite;
          pointer-events: none;
        }
        
        .nav-logo {
          display: flex;
          align-items: center;
        }
        
        .logo-container {
          display: flex;
          align-items: center;
        }
        
        .logo-symbol {
          font-size: 1.8rem;
          font-weight: 700;
          color: var(--accent-cyan);
          text-shadow: 0 0 10px rgba(0, 255, 245, 0.7);
          margin-right: 0.5rem;
          position: relative;
        }
        
        .logo-symbol::before {
          content: 'C';
          position: absolute;
          top: 0;
          left: 0;
          color: var(--accent-magenta);
          filter: blur(4px);
          opacity: 0.7;
          animation: logo-glitch 5s infinite alternate;
        }
        
        .logo-text {
          font-size: 1.2rem;
          font-weight: 500;
          color: var(--text-primary);
          letter-spacing: 2px;
        }
        
        .nav-controls {
          display: flex;
          align-items: center;
        }
        
        .theme-toggle,
        .audio-toggle,
        .menu-toggle {
          background: transparent;
          border: none;
          color: var(--text-primary);
          font-size: 1.2rem;
          margin-left: 1rem;
          cursor: none;
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: all 0.3s ease;
        }
        
        .theme-toggle:hover,
        .audio-toggle:hover {
          background-color: rgba(0, 255, 245, 0.1);
          color: var(--accent-cyan);
          transform: translateY(-2px);
        }
        
        .menu-toggle {
          flex-direction: column;
          justify-content: space-between;
          padding: 10px;
          position: relative;
        }
        
        .menu-toggle-line {
          width: 100%;
          height: 2px;
          background-color: var(--text-primary);
          transition: all 0.3s ease;
        }
        
        .menu-toggle.active .menu-toggle-line:nth-child(1) {
          transform: translateY(8px) rotate(45deg);
          background-color: var(--accent-cyan);
        }
        
        .menu-toggle.active .menu-toggle-line:nth-child(2) {
          opacity: 0;
        }
        
        .menu-toggle.active .menu-toggle-line:nth-child(3) {
          transform: translateY(-8px) rotate(-45deg);
          background-color: var(--accent-cyan);
        }
        
        .menu-toggle:hover .menu-toggle-line {
          background-color: var(--accent-cyan);
        }
        
        .nav-menu {
          position: absolute;
          top: var(--header-height);
          right: 0;
          width: 250px;
          background-color: rgba(10, 10, 10, 0.95);
          border-left: 1px solid var(--accent-cyan);
          border-bottom: 1px solid var(--accent-cyan);
          max-height: calc(100vh - var(--header-height));
          overflow-y: auto;
          backdrop-filter: blur(10px);
        }
        
        .menu-background {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: -1;
        }
        
        .menu-content {
          padding: 1rem 0;
          position: relative;
          z-index: 1;
        }
        
        .menu-item {
          position: relative;
        }
        
        .menu-link {
          display: flex;
          align-items: center;
          padding: 0.8rem 1.5rem;
          color: var(--text-primary);
          transition: all 0.3s ease;
          position: relative;
        }
        
        .menu-link::after {
          display: none;
        }
        
        .menu-icon {
          margin-right: 1rem;
          font-size: 1.2rem;
          color: var(--accent-cyan);
          transition: all 0.3s ease;
        }
        
        .menu-title {
          font-size: 0.9rem;
          letter-spacing: 1px;
        }
        
        .menu-active-indicator {
          position: absolute;
          left: 0;
          top: 0;
          width: 4px;
          height: 100%;
          background-color: var(--accent-cyan);
          box-shadow: 0 0 10px rgba(0, 255, 245, 0.7);
        }
        
        .menu-link.hovered {
          color: var(--text-primary);
          background-color: rgba(0, 255, 245, 0.1);
          transform: translateX(5px);
        }
        
        .menu-link.hovered .menu-icon {
          color: var(--accent-magenta);
        }
        
        .menu-hover-effect {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient(90deg, 
            rgba(0, 255, 245, 0.05) 0%, 
            rgba(0, 255, 245, 0.02) 40%, 
            transparent 100%);
          pointer-events: none;
        }
        
        /* Light theme styles */
        .light-theme .nav-container {
          background-color: rgba(245, 245, 245, 0.8);
          border-bottom: 1px solid var(--accent-blue);
        }
        
        .light-theme .nav-container::before {
          background: linear-gradient(90deg, transparent, rgba(77, 77, 255, 0.1), transparent);
        }
        
        .light-theme .logo-symbol {
          color: var(--accent-blue);
          text-shadow: 0 0 10px rgba(77, 77, 255, 0.7);
        }
        
        .light-theme .logo-symbol::before {
          color: var(--accent-magenta);
        }
        
        .light-theme .menu-toggle-line {
          background-color: var(--text-primary);
        }
        
        .light-theme .menu-toggle.active .menu-toggle-line:nth-child(1),
        .light-theme .menu-toggle.active .menu-toggle-line:nth-child(3),
        .light-theme .menu-toggle:hover .menu-toggle-line {
          background-color: var(--accent-blue);
        }
        
        .light-theme .nav-menu {
          background-color: rgba(245, 245, 245, 0.95);
          border-left: 1px solid var(--accent-blue);
          border-bottom: 1px solid var(--accent-blue);
        }
        
        .light-theme .menu-icon {
          color: var(--accent-blue);
        }
        
        .light-theme .menu-active-indicator {
          background-color: var(--accent-blue);
          box-shadow: 0 0 10px rgba(77, 77, 255, 0.7);
        }
        
        .light-theme .menu-link.hovered {
          background-color: rgba(77, 77, 255, 0.1);
        }
        
        .light-theme .menu-hover-effect {
          background: linear-gradient(90deg, 
            rgba(77, 77, 255, 0.05) 0%, 
            rgba(77, 77, 255, 0.02) 40%, 
            transparent 100%);
        }
        
        @keyframes nav-glow {
          0%, 100% {
            transform: translateX(-100%);
          }
          50% {
            transform: translateX(100%);
          }
        }
        
        @keyframes logo-glitch {
          0%, 100% {
            transform: translate(0);
            opacity: 0.7;
          }
          20% {
            transform: translate(-1px, 1px);
            opacity: 0.5;
          }
          40% {
            transform: translate(1px, -1px);
            opacity: 0.7;
          }
          60% {
            transform: translate(-1px, -1px);
            opacity: 0.5;
          }
          80% {
            transform: translate(1px, 1px);
            opacity: 0.7;
          }
        }
        
        /* Media queries */
        @media (max-width: 768px) {
          .nav-container {
            padding: 0 1rem;
          }
          
          .logo-text {
            font-size: 1rem;
          }
        }
        
        @media (max-width: 480px) {
          .logo-text {
            display: none;
          }
        }
      `}</style>
    </header>
  );
};

export default HolographicNav;
</file>

<file path="frontend/src/components/sections/AITerminal.jsx">
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useAudio } from '../../contexts/AudioContext';

// Terminal commands
const COMMANDS = {
  HELP: 'help',
  CLEAR: 'clear',
  ABOUT: 'about',
  SKILLS: 'skills',
  PROJECTS: 'projects',
  CONTACT: 'contact',
  EXPERIENCE: 'experience',
  EDUCATION: 'education',
  CERTIFICATIONS: 'certifications',
  GITHUB: 'github',
  LINKEDIN: 'linkedin',
  RESUME: 'resume',
  ECHO: 'echo',
  WHOIS: 'whois',
  LS: 'ls',
  DATE: 'date',
  TIME: 'time',
  ASK: 'ask',
  EXIT: 'exit',
  THEME: 'theme',
  MATRIX: 'matrix',
  HACK: 'hack',
  QUOTE: 'quote'
};

// Terminal history entries
const WELCOME_MESSAGE = `
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘
â•šâ•â•â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•   â•šâ•â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘
â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•    â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•
                                                     
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     
â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     
   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     
   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     
   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
                                                                  
v1.0.0 - Neural Interface Active

Welcome to the Interactive Neural Terminal.
This terminal allows direct communication with the portfolio system.
Type 'help' to see available commands or 'ask' followed by a question.

[System] Connection established. Terminal ready.
`;

// Cyber quotes array
const CYBER_QUOTES = [
  "The future is already here â€“ it's just not evenly distributed. - William Gibson",
  "Information wants to be free. - Stewart Brand",
  "In the face of ambiguity, refuse the temptation to guess. - The Zen of Python",
  "Any sufficiently advanced technology is indistinguishable from magic. - Arthur C. Clarke",
  "The best way to predict the future is to invent it. - Alan Kay",
  "Security is always excessive until it's not enough. - Robbie Sinclair",
  "Privacy is not something that I'm merely entitled to, it's an absolute prerequisite. - Marlon Brando",
  "The quieter you become, the more you can hear. - Ram Dass",
  "There is no security on this earth; there is only opportunity. - Douglas MacArthur",
  "Simplicity is the ultimate sophistication. - Leonardo da Vinci"
];

const AITerminal = () => {
  const { theme, toggleTheme } = useTheme();
  const { playSound } = useAudio();
  const [input, setInput] = useState('');
  const [history, setHistory] = useState([{ type: 'system', content: WELCOME_MESSAGE }]);
  const [isLoading, setIsLoading] = useState(false);
  const [showHackProgress, setShowHackProgress] = useState(false);
  const [hackProgress, setHackProgress] = useState(0);
  const [showMatrix, setShowMatrix] = useState(false);
  const [matrixCharacters, setMatrixCharacters] = useState([]);
  const inputRef = useRef(null);
  const historyRef = useRef(null);
  
  // Focus input on component mount
  useEffect(() => {
    setTimeout(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, 500);
  }, []);
  
  // Auto-scroll to bottom when history changes
  useEffect(() => {
    if (historyRef.current) {
      historyRef.current.scrollTop = historyRef.current.scrollHeight;
    }
  }, [history]);
  
  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!input.trim()) return;
    
    // Add user input to history
    const userInput = input.trim();
    setHistory(prev => [...prev, { type: 'user', content: userInput }]);
    setInput('');
    playSound('click');
    
    // Process command
    await processCommand(userInput);
  };
  
  // Process terminal commands
  const processCommand = async (command) => {
    // Convert to lowercase and split into parts
    const parts = command.toLowerCase().split(' ');
    const mainCommand = parts[0];
    const args = parts.slice(1).join(' ');
    
    // Simulate processing time
    setIsLoading(true);
    await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 700));
    setIsLoading(false);
    
    // Process based on command
    switch (mainCommand) {
      case COMMANDS.HELP:
        displayHelp();
        break;
      case COMMANDS.CLEAR:
        clearTerminal();
        break;
      case COMMANDS.ABOUT:
        displayAbout();
        break;
      case COMMANDS.SKILLS:
        displaySkills();
        break;
      case COMMANDS.PROJECTS:
        displayProjects();
        break;
      case COMMANDS.CONTACT:
        displayContact();
        break;
      case COMMANDS.EXPERIENCE:
        displayExperience();
        break;
      case COMMANDS.EDUCATION:
        displayEducation();
        break;
      case COMMANDS.CERTIFICATIONS:
        displayCertifications();
        break;
      case COMMANDS.GITHUB:
        openLink('https://github.com/username');
        break;
      case COMMANDS.LINKEDIN:
        openLink('https://linkedin.com/in/username');
        break;
      case COMMANDS.RESUME:
        displayResume();
        break;
      case COMMANDS.ECHO:
        echoText(args);
        break;
      case COMMANDS.WHOIS:
        displayWhois();
        break;
      case COMMANDS.LS:
        displayLs();
        break;
      case COMMANDS.DATE:
      case COMMANDS.TIME:
        displayDateTime();
        break;
      case COMMANDS.ASK:
        await handleAskCommand(args);
        break;
      case COMMANDS.EXIT:
        handleExit();
        break;
      case COMMANDS.THEME:
        handleTheme();
        break;
      case COMMANDS.MATRIX:
        startMatrix();
        break;
      case COMMANDS.HACK:
        startHack(args);
        break;
      case COMMANDS.QUOTE:
        displayQuote();
        break;
      default:
        displayUnknownCommand(mainCommand);
    }
  };
  
  // Terminal command handlers
  
  const displayHelp = () => {
    const helpMessage = `
Available commands:

NAVIGATION & INFO:
  help              - Display this help message
  about             - About the developer
  skills            - List technical skills
  projects          - View featured projects
  experience        - Show work experience
  education         - Display educational background
  certifications    - Show earned certifications
  
CONTACT & LINKS:
  contact           - Display contact information
  github            - Open GitHub profile
  linkedin          - Open LinkedIn profile
  resume            - View resume information
  
TERMINAL CONTROLS:
  clear             - Clear terminal screen
  echo [text]       - Echo text back to terminal
  whois             - Display information about the system
  ls                - List available sections
  date / time       - Display current date and time
  ask [question]    - Ask a question about me (AI-powered)
  theme             - Toggle light/dark theme
  exit              - Exit terminal mode
  
FUN COMMANDS:
  matrix            - Display Matrix effect (type any key to exit)
  hack [target]     - Simulate hacking (for fun)
  quote             - Display a random cyber quote
`;
    setHistory(prev => [...prev, { type: 'system', content: helpMessage }]);
  };
  
  const clearTerminal = () => {
    setHistory([{ type: 'system', content: 'Terminal cleared.' }]);
  };
  
  const displayAbout = () => {
    const aboutMessage = `
=== ABOUT ME ===

Name: Carter Rush Perez
Age: 21
Location: Annapolis, MD

I am a system integration technician with a passion for cybersecurity, 
currently working at Sealing Technologies. I focus on building and 
configuring custom cybersecurity and defense systems, ensuring they 
meet client needs and perform reliably under demanding conditions.

With expertise in both hardware integration and software development, 
I bring a holistic approach to creating secure technological solutions. 
My background in multiple CompTIA certifications and ongoing education 
in cybersecurity reinforces my commitment to staying at the forefront 
of the rapidly evolving security landscape.

When not working on technological challenges, I enjoy strength training, 
swimming, and the occasional cliff jumping for an adrenaline rush.
`;
    setHistory(prev => [...prev, { type: 'system', content: aboutMessage }]);
  };
  
  const displaySkills = () => {
    const skillsMessage = `
=== TECHNICAL SKILLS ===

CYBERSECURITY:
  â€¢ Risk Assessment and Threat Mitigation
  â€¢ Compliance with ISO 27001 and 9001:2015
  â€¢ Role-Based Access Controls
  â€¢ Encryption Best Practices
  â€¢ Incident Response Planning

DEVELOPMENT:
  â€¢ Languages: Python, JavaScript, HTML, CSS, Shell Scripting
  â€¢ Frameworks: React, Flask
  â€¢ Databases: MongoDB
  â€¢ Containerization: Docker
  â€¢ Web Servers: Nginx, Apache

NETWORKING:
  â€¢ TCP/IP, DNS, DHCP
  â€¢ Firewalls (UFW, iptables)
  â€¢ Secure Network Configurations
  â€¢ SSH Encryption
  â€¢ Virtual Private Networks (VPNs)

CLOUD:
  â€¢ AWS Security (EC2, S3, WAF, Shield, ACM)
  â€¢ Cloud Resource Optimization
  â€¢ TLS/SSL Implementation

ADDITIONAL:
  â€¢ System Hardening and Security
  â€¢ DevOps/DevSecOps Pipelines
  â€¢ Log Analysis (Splunk)
  â€¢ Virtualization
`;
    setHistory(prev => [...prev, { type: 'system', content: skillsMessage }]);
  };
  
  const displayProjects = () => {
    const projectsMessage = `
=== FEATURED PROJECTS ===

1. ProxyAuthRequired.com
   A centralized cybersecurity platform integrating AI-driven simulations
   and learning modules. Features include GRC Wizard for compliance questions,
   Log Analysis for real-time practice, and scenario-based exercises 
   for incident response.
   [Technologies: React, Python, Flask, MongoDB, Docker]

2. CertsGamified
   A gamified platform for certification preparation. Follow structured
   roadmaps to learn, practice, and master certifications like CompTIA.
   Earn XP, unlock badges, and track your progress.
   [Technologies: React, Node.js, MongoDB, Express]

3. Cyber Labs
   Hands-on labs for penetration testing and system hardening, providing
   practical training environments for cybersecurity enthusiasts.
   [Technologies: Docker, Kali Linux, Python, Bash]

4. AutoApplication
   An automated application bot for Indeed and LinkedIn, streamlining the
   job application process with web automation and scripting.
   [Technologies: Python, Selenium, BeautifulSoup]

Type 'projects [number]' to get more details about a specific project.
`;
    setHistory(prev => [...prev, { type: 'system', content: projectsMessage }]);
  };
  
  const displayContact = () => {
    const contactMessage = `
=== CONTACT INFORMATION ===

Email: CarterPerez-dev@ProxyAuthRequired.com
Phone: 443-510-0866

Social Links:
  â€¢ GitHub:   https://github.com/CarterPerez-dev
  â€¢ LinkedIn: https://www.linkedin.com/in/carter-perez-ProxyAuthRequired/

Preferred Contact Method: Email

Feel free to reach out for collaboration opportunities, consulting,
or just to connect about cybersecurity and development topics.
`;
    setHistory(prev => [...prev, { type: 'system', content: contactMessage }]);
  };
  
  const displayExperience = () => {
    const experienceMessage = `
=== WORK EXPERIENCE ===

SYSTEM INTEGRATION TECHNICIAN II | Sealing Technologies
2024 - Present | Annapolis, MD
â€¢ Build and configure custom cybersecurity and defense systems
â€¢ Perform quality assurance testing and system optimization
â€¢ Collaborate with cross-functional teams for solution delivery
â€¢ Maintain detailed documentation for all build processes

GENERAL MANAGER | Jimmy John's
2022 - 2024 | Severna Park, MD
â€¢ Managed daily operations and supervised staff
â€¢ Ensured efficient workflows and high customer satisfaction
â€¢ Maintained network and POS systems functionality
â€¢ Implemented new inventory procedures to reduce waste

GENERAL MANAGER | Jimmy John's
2022 - 2022 | Annapolis, MD
â€¢ Diagnosed Network & POS issues
â€¢ Oversaw staff scheduling and training
â€¢ Ensured compliance with company standards
`;
    setHistory(prev => [...prev, { type: 'system', content: experienceMessage }]);
  };
  
  const displayEducation = () => {
    const educationMessage = `
=== EDUCATION ===

MASTER'S DEGREE IN CYBERSECURITY
University of Maryland Global Campus | 2024 - Present
â€¢ Focus on advanced security protocols and threat intelligence
â€¢ Maintaining a 3.9 GPA while working full-time
â€¢ Participating in cybersecurity research initiatives

ASSOCIATE'S DEGREE IN CYBERSECURITY
Anne Arundel Community College | 2022 - 2024
â€¢ Graduated with honors (3.8 GPA)
â€¢ Focused on network security and ethical hacking principles
â€¢ Participated in capture-the-flag competitions
â€¢ Assisted professors with lab setup for security courses

SOUTH RIVER HIGH SCHOOL
2018 - 2022
â€¢ Focus on science and mathematics
â€¢ Participated in STEM-related extracurriculars
`;
    setHistory(prev => [...prev, { type: 'system', content: educationMessage }]);
  };
  
  const displayCertifications = () => {
    const certificationsMessage = `
=== CERTIFICATIONS ===

COMPTIA CERTIFICATIONS:
â€¢ CompTIA A+
â€¢ CompTIA Network+
â€¢ CompTIA Security+
â€¢ CompTIA CySA+
â€¢ CompTIA PenTest+
â€¢ CompTIA CASP+

ADDITIONAL CERTIFICATIONS:
â€¢ PCEP (Certified Entry-Level Python Programmer)

All CompTIA certifications were achieved within a nine-month period,
with an average of two weeks study time for each.

STUDY METHODS:
â€¢ Watching Professor Messer's tutorials
â€¢ Using ChatGPT to enhance understanding
â€¢ Employing the PQR method
â€¢ Maintaining confidence throughout the process
`;
    setHistory(prev => [...prev, { type: 'system', content: certificationsMessage }]);
  };
  
  const openLink = (url) => {
    const linkMessage = `Opening ${url} in a new tab...`;
    setHistory(prev => [...prev, { type: 'system', content: linkMessage }]);
    window.open(url, '_blank');
  };
  
  const displayResume = () => {
    const resumeMessage = `
=== RESUME INFORMATION ===

My resume includes detailed information about my:
â€¢ Work experience
â€¢ Educational background
â€¢ Technical skills
â€¢ Certifications
â€¢ Projects
â€¢ Contact details

You can view or download my complete resume by:
1. Clicking the "RESUME" link in the navigation menu
2. Visiting: /assets/CarterPerez.pdf directly
3. Using the command 'open resume' to open it in a new tab

The resume is available in PDF format and showcases my
qualifications for cybersecurity and technical roles.
`;
    setHistory(prev => [...prev, { type: 'system', content: resumeMessage }]);
  };
  
  const echoText = (text) => {
    if (!text) {
      setHistory(prev => [...prev, { type: 'system', content: 'Usage: echo [text]' }]);
      return;
    }
    
    setHistory(prev => [...prev, { type: 'system', content: text }]);
  };
  
  const displayWhois = () => {
    const whoisMessage = `
=== SYSTEM INFORMATION ===

Terminal: Neural Interface Terminal v1.0.0
Developer: Carter Rush Perez
Framework: React v18.3.1
Architecture: Cyberpunk-inspired Single Page Application
Creation Date: 2025
Purpose: Interactive portfolio demonstration
Features: Dynamic command processing, AI interaction, visual effects

Current Status: ONLINE
Server Location: AWS us-east-1
Security Protocol: TLS 1.3, HSTS Enabled
Last Updated: ${new Date().toLocaleDateString()}
`;
    setHistory(prev => [...prev, { type: 'system', content: whoisMessage }]);
  };
  
  const displayLs = () => {
    const lsMessage = `
DIRECTORY CONTENTS:

drwxr-xr-x  about/
drwxr-xr-x  projects/
drwxr-xr-x  skills/
drwxr-xr-x  experience/
drwxr-xr-x  education/
drwxr-xr-x  certifications/
drwxr-xr-x  contact/
-rw-r--r--  resume.pdf
-rw-r--r--  README.md
-rw-r--r--  .terminal_config
-rw-r--r--  .env
`;
    setHistory(prev => [...prev, { type: 'system', content: lsMessage }]);
  };
  
  const displayDateTime = () => {
    const now = new Date();
    const dateTimeMessage = `Current Date & Time: ${now.toLocaleString()}`;
    setHistory(prev => [...prev, { type: 'system', content: dateTimeMessage }]);
  };
  
  const handleAskCommand = async (question) => {
    if (!question) {
      setHistory(prev => [...prev, { 
        type: 'system', 
        content: 'Usage: ask [question]\nExample: ask What are your favorite programming languages?' 
      }]);
      return;
    }
    
    // Show loading
    setHistory(prev => [...prev, { type: 'loading', content: 'Processing your question...' }]);
    
    try {
      // Make API call to backend
      const response = await fetch('/api/portfolio/ask_about_me', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ question }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to get response');
      }
      
      const data = await response.json();
      
      // Remove loading message and add AI response
      setHistory(prev => {
        const filtered = prev.filter(item => item.type !== 'loading');
        return [...filtered, { type: 'ai', content: data.answer }];
      });
      
    } catch (error) {
      // Handle error
      console.error('Error fetching AI response:', error);
      
      // Remove loading message and add error message
      setHistory(prev => {
        const filtered = prev.filter(item => item.type !== 'loading');
        return [...filtered, { 
          type: 'error', 
          content: 'Sorry, I encountered an error processing your question. Please try again later.' 
        }];
      });
    }
  };
  
  const handleExit = () => {
    const exitMessage = 'Exiting terminal mode. Redirecting to home page...';
    setHistory(prev => [...prev, { type: 'system', content: exitMessage }]);
    
    // Redirect after delay
    setTimeout(() => {
      window.location.href = '/';
    }, 1500);
  };
  
  const handleTheme = () => {
    toggleTheme();
    const themeMessage = `Theme switched to ${theme === 'dark' ? 'light' : 'dark'} mode.`;
    setHistory(prev => [...prev, { type: 'system', content: themeMessage }]);
  };
  
  const startMatrix = () => {
    setShowMatrix(true);
    
    // Generate initial matrix characters
    const chars = [];
    const columns = Math.floor(window.innerWidth / 20);
    
    for (let i = 0; i < columns; i++) {
      chars.push({
        x: i * 20,
        y: Math.floor(Math.random() * -100),
        speed: Math.random() * 10 + 5,
        value: getRandomMatrixChar()
      });
    }
    
    setMatrixCharacters(chars);
    
    // Add exit message to history
    setHistory(prev => [...prev, { 
      type: 'system', 
      content: 'Matrix mode activated. Press any key to exit.' 
    }]);
  };
  
  const getRandomMatrixChar = () => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
    return chars.charAt(Math.floor(Math.random() * chars.length));
  };
  
  const startHack = (target) => {
    if (!target) {
      setHistory(prev => [...prev, { 
        type: 'system', 
        content: 'Usage: hack [target]\nExample: hack firewall' 
      }]);
      return;
    }
    
    setShowHackProgress(true);
    setHackProgress(0);
    
    const hackMessages = [
      `Initiating hack on ${target}...`,
      `Scanning ${target} for vulnerabilities...`,
      `Vulnerabilities found. Exploiting entry points...`,
      `Bypassing security protocols...`,
      `Injecting payload into ${target}...`,
      `Establishing backdoor connection...`,
      `Extracting data from ${target}...`,
      `Covering tracks and removing logs...`,
      `Hack successful. Access granted to ${target}.`
    ];
    
    // Add initial message
    setHistory(prev => [...prev, { type: 'system', content: hackMessages[0] }]);
    
    // Progress simulation
    let currentMessage = 1;
    const intervalId = setInterval(() => {
      setHackProgress(prev => {
        const newProgress = prev + (Math.random() * 5) + 2;
        
        // Add new message at certain progress points
        if (currentMessage < hackMessages.length && newProgress >= (currentMessage * 100) / hackMessages.length) {
          setHistory(prev => [...prev, { type: 'system', content: hackMessages[currentMessage] }]);
          currentMessage++;
        }
        
        // Complete hack
        if (newProgress >= 100) {
          clearInterval(intervalId);
          setTimeout(() => {
            setShowHackProgress(false);
            
            // Add completion message if not already added
            if (currentMessage < hackMessages.length) {
              setHistory(prev => [...prev, { type: 'system', content: hackMessages[hackMessages.length - 1] }]);
            }
          }, 500);
          return 100;
        }
        
        return newProgress;
      });
    }, 300);
  };
  
  const displayQuote = () => {
    const randomQuote = CYBER_QUOTES[Math.floor(Math.random() * CYBER_QUOTES.length)];
    setHistory(prev => [...prev, { type: 'system', content: randomQuote }]);
  };
  
  const displayUnknownCommand = (command) => {
    const unknownMessage = `Command not found: ${command}\nType 'help' to see available commands.`;
    setHistory(prev => [...prev, { type: 'error', content: unknownMessage }]);
  };
  
  // Handle matrix animation
  useEffect(() => {
    if (!showMatrix) return;
    
    const animateMatrix = () => {
      setMatrixCharacters(prevChars => {
        return prevChars.map(char => {
          // Update y position
          let y = char.y + char.speed;
          
          // Reset if off-screen
          if (y > window.innerHeight) {
            y = Math.random() * -100;
          }
          
          // Occasionally change character
          const newChar = Math.random() > 0.9 ? getRandomMatrixChar() : char.value;
          
          return {
            ...char,
            y,
            value: newChar
          };
        });
      });
    };
    
    const intervalId = setInterval(animateMatrix, 100);
    
    // Exit matrix mode on any keypress
    const handleKeyPress = () => {
      setShowMatrix(false);
      setHistory(prev => [...prev, { type: 'system', content: 'Matrix mode deactivated.' }]);
    };
    
    window.addEventListener('keydown', handleKeyPress);
    
    return () => {
      clearInterval(intervalId);
      window.removeEventListener('keydown', handleKeyPress);
    };
  }, [showMatrix]);
  
  return (
    <section className="terminal-section" id="terminal">
      <div className="container">
        <motion.h1 
          className="page-title"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          Neural Interface Terminal
        </motion.h1>
        
        <motion.div 
          className="terminal-container"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          <div className="terminal-header">
            <div className="terminal-title">system.terminal</div>
            <div className="terminal-controls">
              <div className="terminal-control terminal-minimize"></div>
              <div className="terminal-control terminal-maximize"></div>
              <div className="terminal-control terminal-close"></div>
            </div>
          </div>
          
          <div className="terminal-window" ref={historyRef}>
            {history.map((entry, index) => (
              <div 
                key={index} 
                className={`terminal-entry terminal-${entry.type}`}
              >
                {entry.type === 'user' ? (
                  <>
                    <span className="terminal-prompt">
                      <span className="prompt-user">user</span>
                      <span className="prompt-at">@</span>
                      <span className="prompt-host">neural-terminal</span>
                      <span className="prompt-colon">:</span>
                      <span className="prompt-path">~</span>
                      <span className="prompt-dollar">$</span>
                    </span>
                    <span className="terminal-command">{entry.content}</span>
                  </>
                ) : entry.type === 'loading' ? (
                  <div className="terminal-loading">
                    <span>{entry.content}</span>
                    <span className="loading-dots">...</span>
                  </div>
                ) : (
                  <pre className="terminal-output">{entry.content}</pre>
                )}
              </div>
            ))}
            
            {isLoading && (
              <div className="terminal-entry terminal-loading">
                <span className="loading-text">Processing</span>
                <span className="loading-dots">...</span>
              </div>
            )}
          </div>
          
          <form onSubmit={handleSubmit} className="terminal-input-form">
            <span className="terminal-prompt">
              <span className="prompt-user">user</span>
              <span className="prompt-at">@</span>
              <span className="prompt-host">neural-terminal</span>
              <span className="prompt-colon">:</span>
              <span className="prompt-path">~</span>
              <span className="prompt-dollar">$</span>
            </span>
            <input 
              type="text" 
              value={input}
              onChange={(e) => setInput(e.target.value)}
              className="terminal-input"
              ref={inputRef}
              autoFocus
              disabled={isLoading || showMatrix}
            />
          </form>
          
          {showHackProgress && (
            <div className="hack-progress-container">
              <div className="hack-progress-label">
                <span>HACK PROGRESS:</span>
                <span className="hack-progress-percent">{Math.floor(hackProgress)}%</span>
              </div>
              <div className="hack-progress-bar">
                <div 
                  className="hack-progress-fill"
                  style={{ width: `${hackProgress}%` }}
                ></div>
              </div>
            </div>
          )}
        </motion.div>
        
        {showMatrix && (
          <div className="matrix-overlay">
            {matrixCharacters.map((char, index) => (
              <div 
                key={index}
                className="matrix-char"
                style={{
                  left: `${char.x}px`,
                  top: `${char.y}px`
                }}
              >
                {char.value}
              </div>
            ))}
          </div>
        )}
      </div>
      
      <style jsx>{`
        .terminal-section {
          padding: var(--space-xxl) 0;
          min-height: 100vh;
          position: relative;
          display: flex;
          align-items: center;
        }
        
        .page-title {
          text-align: center;
          margin-bottom: var(--space-xl);
          color: var(--accent-cyan);
          font-size: 3rem;
          position: relative;
        }
        
        .page-title::after {
          content: '';
          position: absolute;
          bottom: -10px;
          left: 50%;
          transform: translateX(-50%);
          width: 100px;
          height: 3px;
          background: linear-gradient(
            90deg,
            transparent,
            var(--accent-cyan),
            transparent
          );
        }
        
        .terminal-container {
          width: 100%;
          height: 70vh;
          max-height: 600px;
          background-color: rgba(16, 16, 16, 0.95);
          border: 1px solid var(--accent-cyan);
          border-radius: var(--border-radius-md);
          overflow: hidden;
          box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), 0 0 15px rgba(0, 255, 245, 0.3);
          display: flex;
          flex-direction: column;
        }
        
        .terminal-header {
          height: 30px;
          background-color: rgba(0, 0, 0, 0.8);
          border-bottom: 1px solid var(--accent-cyan);
          display: flex;
          align-items: center;
          padding: 0 var(--space-sm);
        }
        
        .terminal-title {
          flex: 1;
          color: var(--accent-cyan);
          font-family: var(--font-mono);
          font-size: 0.8rem;
          text-align: center;
        }
        
        .terminal-controls {
          display: flex;
          gap: 6px;
        }
        
        .terminal-control {
          width: 12px;
          height: 12px;
          border-radius: 50%;
          cursor: pointer;
        }
        
        .terminal-minimize {
          background-color: #ffbd2e;
        }
        
        .terminal-maximize {
          background-color: #28c940;
        }
        
        .terminal-close {
          background-color: #ff5f56;
        }
        
        .terminal-window {
          flex: 1;
          overflow-y: auto;
          padding: var(--space-md);
          font-family: var(--font-mono);
          font-size: 0.9rem;
          line-height: 1.4;
          color: var(--text-primary);
        }
        
        .terminal-window::-webkit-scrollbar {
          width: 8px;
        }
        
        .terminal-window::-webkit-scrollbar-track {
          background: rgba(0, 0, 0, 0.3);
        }
        
        .terminal-window::-webkit-scrollbar-thumb {
          background: var(--accent-cyan);
          border-radius: 4px;
        }
        
        .terminal-entry {
          margin-bottom: var(--space-sm);
          white-space: pre-wrap;
          word-break: break-word;
        }
        
        .terminal-prompt {
          display: inline-block;
          margin-right: var(--space-xs);
        }
        
        .prompt-user {
          color: var(--accent-green);
        }
        
        .prompt-at {
          color: var(--text-primary);
        }
        
        .prompt-host {
          color: var(--accent-magenta);
        }
        
        .prompt-colon,
        .prompt-dollar {
          color: var(--text-primary);
        }
        
        .prompt-path {
          color: var(--accent-blue);
        }
        
        .terminal-command {
          color: var(--text-primary);
        }
        
        .terminal-output {
          color: var(--text-secondary);
          margin: var(--space-xs) 0 0;
          font-family: var(--font-mono);
          font-size: 0.9rem;
        }
        
        .terminal-system .terminal-output {
          color: var(--text-secondary);
        }
        
        .terminal-ai .terminal-output {
          color: var(--accent-cyan);
        }
        
        .terminal-error .terminal-output {
          color: #ff5f56;
        }
        
        .terminal-loading {
          color: var(--accent-purple);
          display: flex;
          align-items: center;
          gap: 5px;
        }
        
        .loading-dots {
          animation: loading-dots 1.5s infinite;
        }
        
        .terminal-input-form {
          display: flex;
          align-items: center;
          padding: var(--space-sm) var(--space-md);
          background-color: rgba(0, 0, 0, 0.3);
          border-top: 1px solid rgba(0, 255, 245, 0.2);
        }
        
        .terminal-input {
          flex: 1;
          background-color: transparent;
          border: none;
          outline: none;
          color: var(--text-primary);
          font-family: var(--font-mono);
          font-size: 0.9rem;
          caret-color: var(--accent-cyan);
        }
        
        .hack-progress-container {
          padding: var(--space-sm) var(--space-md);
          background-color: rgba(0, 0, 0, 0.5);
          border-top: 1px solid rgba(255, 61, 61, 0.2);
        }
        
        .hack-progress-label {
          display: flex;
          justify-content: space-between;
          margin-bottom: var(--space-xs);
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--accent-magenta);
        }
        
        .hack-progress-percent {
          font-weight: bold;
        }
        
        .hack-progress-bar {
          height: 6px;
          background-color: rgba(255, 255, 255, 0.1);
          border-radius: 3px;
          overflow: hidden;
        }
        
        .hack-progress-fill {
          height: 100%;
          background-color: var(--accent-magenta);
          border-radius: 3px;
          transition: width 0.3s ease-out;
        }
        
        .matrix-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.9);
          z-index: 100;
          overflow: hidden;
        }
        
        .matrix-char {
          position: absolute;
          color: var(--accent-green);
          font-family: var(--font-mono);
          font-size: 1.2rem;
          text-shadow: 0 0 5px var(--accent-green);
        }
        
        /* Light theme styles */
        .light-theme .terminal-container {
          background-color: rgba(235, 235, 235, 0.95);
          border-color: var(--accent-blue);
          box-shadow: 0 0 30px rgba(0, 0, 0, 0.2), 0 0 15px rgba(77, 77, 255, 0.3);
        }
        
        .light-theme .terminal-header {
          background-color: rgba(200, 200, 200, 0.8);
          border-color: var(--accent-blue);
        }
        
        .light-theme .terminal-title {
          color: var(--accent-blue);
        }
        
        .light-theme .terminal-window::-webkit-scrollbar-thumb {
          background: var(--accent-blue);
        }
        
        .light-theme .terminal-input-form,
        .light-theme .hack-progress-container {
          background-color: rgba(200, 200, 200, 0.3);
        }
        
        .light-theme .terminal-input-form {
          border-color: rgba(77, 77, 255, 0.2);
        }
        
        /* Animations */
        @keyframes loading-dots {
          0%, 20% {
            content: ".";
          }
          40% {
            content: "..";
          }
          60%, 80% {
            content: "...";
          }
          100% {
            content: "";
          }
        }
        
        /* Media queries */
        @media (max-width: 768px) {
          .terminal-container {
            height: 60vh;
          }
          
          .page-title {
            font-size: 2.5rem;
          }
          
          .terminal-window {
            font-size: 0.8rem;
          }
          
          .terminal-input {
            font-size: 0.8rem;
          }
        }
        
        @media (max-width: 480px) {
          .terminal-container {
            height: 50vh;
          }
          
          .page-title {
            font-size: 2rem;
          }
          
          .terminal-window {
            padding: var(--space-sm);
            font-size: 0.7rem;
          }
          
          .terminal-input-form {
            padding: var(--space-xs) var(--space-sm);
          }
          
          .terminal-input {
            font-size: 0.7rem;
          }
          
          .terminal-prompt {
            font-size: 0.7rem;
          }
        }
      `}</style>
    </section>
  );
};

export default AITerminal;
</file>

<file path="frontend/src/components/sections/ContactPortal.jsx">
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useAudio } from '../../contexts/AudioContext';

const ContactPortal = () => {
  const { theme } = useTheme();
  const { playSound } = useAudio();
  const canvasRef = useRef(null);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    subject: '',
    message: ''
  });
  const [focusedField, setFocusedField] = useState(null);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showSuccess, setShowSuccess] = useState(false);
  const [showFailure, setShowFailure] = useState(false);
  const [securityCode, setSecurityCode] = useState('');
  
  // Generate random security code
  useEffect(() => {
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    setSecurityCode(code);
  }, []);
  
  // Handle input change
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
    
    // Clear error for this field if it exists
    if (errors[name]) {
      setErrors({
        ...errors,
        [name]: null
      });
    }
  };
  
  // Handle input focus
  const handleFocus = (field) => {
    setFocusedField(field);
    playSound('hover');
  };
  
  // Handle input blur
  const handleBlur = () => {
    setFocusedField(null);
  };
  
  // Validate form
  const validateForm = () => {
    const newErrors = {};
    let isValid = true;
    
    // Name validation
    if (!formData.name.trim()) {
      newErrors.name = 'Name is required';
      isValid = false;
    }
    
    // Email validation
    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
      isValid = false;
    } else if (!emailPattern.test(formData.email)) {
      newErrors.email = 'Please enter a valid email address';
      isValid = false;
    }
    
    // Subject validation
    if (!formData.subject.trim()) {
      newErrors.subject = 'Subject is required';
      isValid = false;
    }
    
    // Message validation
    if (!formData.message.trim()) {
      newErrors.message = 'Message is required';
      isValid = false;
    } else if (formData.message.length < 10) {
      newErrors.message = 'Message must be at least 10 characters';
      isValid = false;
    }
    
    setErrors(newErrors);
    return isValid;
  };
  
  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    playSound('click');
    
    // Validate form
    if (!validateForm()) {
      return;
    }
    
    // Show submitting state
    setIsSubmitting(true);
    
    // Simulate form submission
    try {
      // In a real implementation, this would be a fetch call to backend
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Show success message
      setShowSuccess(true);
      
      // Reset form after delay
      setTimeout(() => {
        setFormData({
          name: '',
          email: '',
          subject: '',
          message: ''
        });
        setIsSubmitting(false);
        setShowSuccess(false);
        
        // Generate new security code
        const newCode = Math.floor(100000 + Math.random() * 900000).toString();
        setSecurityCode(newCode);
      }, 3000);
      
    } catch (error) {
      console.error('Form submission error:', error);
      
      // Show error message
      setShowFailure(true);
      
      // Hide error message after delay
      setTimeout(() => {
        setIsSubmitting(false);
        setShowFailure(false);
      }, 3000);
    }
  };
  
  // Digital connection animation
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    const setCanvasDimensions = () => {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };
    
    window.addEventListener('resize', setCanvasDimensions);
    setCanvasDimensions();
    
    // Connection points (input fields + submit button)
    const getConnectionPoints = () => {
      const formElement = canvas.parentElement;
      if (!formElement) return [];
      
      const points = [];
      
      // Get positions of form elements
      const inputElements = formElement.querySelectorAll('.connection-point');
      
      inputElements.forEach(el => {
        const rect = el.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        // Calculate position relative to canvas
        const x = rect.left - canvasRect.left + rect.width / 2;
        const y = rect.top - canvasRect.top + rect.height / 2;
        
        // Add connection point with active state
        const fieldName = el.dataset.field;
        const isActive = fieldName === focusedField || 
                        (el.classList.contains('submit-button') && isSubmitting);
        
        points.push({
          x,
          y,
          active: isActive,
          pulseRadius: 0,
          pulseOpacity: 1,
          field: fieldName
        });
      });
      
      return points;
    };
    
    // Data flow particles
    let particles = [];
    
    // Create particle between two points
    const createParticle = (startPoint, endPoint) => {
      const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
      const distance = Math.sqrt(
        Math.pow(endPoint.x - startPoint.x, 2) + 
        Math.pow(endPoint.y - startPoint.y, 2)
      );
      
      // Create multiple particles along the path
      const particleCount = Math.max(1, Math.floor(distance / 50));
      
      for (let i = 0; i < particleCount; i++) {
        const position = Math.random();
        
        particles.push({
          x: startPoint.x + (endPoint.x - startPoint.x) * position,
          y: startPoint.y + (endPoint.y - startPoint.y) * position,
          angle,
          speed: 1 + Math.random() * 3,
          distance,
          progress: position,
          size: 2 + Math.random() * 3,
          color: theme === 'dark' ? 
            (Math.random() > 0.3 ? 'rgba(0, 255, 245, 0.7)' : 'rgba(255, 61, 61, 0.7)') :
            (Math.random() > 0.3 ? 'rgba(77, 77, 255, 0.7)' : 'rgba(255, 61, 61, 0.7)'),
          startPoint,
          endPoint
        });
      }
    };
    
    // Draw connections and animate particles
    const drawConnections = () => {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Get connection points
      const points = getConnectionPoints();
      if (points.length === 0) return;
      
      // Submit button is the last point
      const submitPoint = points[points.length - 1];
      
      // Connect form fields to submit button
      for (let i = 0; i < points.length - 1; i++) {
        const startPoint = points[i];
        const endPoint = submitPoint;
        
        // Draw connection line
        ctx.beginPath();
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(endPoint.x, endPoint.y);
        
        const gradient = ctx.createLinearGradient(
          startPoint.x, startPoint.y,
          endPoint.x, endPoint.y
        );
        
        const primaryColor = theme === 'dark' ? 
          'rgba(0, 255, 245, 0.2)' : 'rgba(77, 77, 255, 0.2)';
        const secondaryColor = 'rgba(255, 61, 61, 0.2)';
        
        gradient.addColorStop(0, startPoint.active ? primaryColor : secondaryColor);
        gradient.addColorStop(1, submitPoint.active ? primaryColor : secondaryColor);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = startPoint.active || submitPoint.active ? 2 : 1;
        ctx.stroke();
        
        // Create particles if field is active
        if (startPoint.active && Math.random() > 0.7) {
          createParticle(startPoint, endPoint);
        }
      }
      
      // Draw connection points
      points.forEach(point => {
        // Draw point
        ctx.beginPath();
        ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = point.active ? 
          (theme === 'dark' ? 'rgba(0, 255, 245, 0.8)' : 'rgba(77, 77, 255, 0.8)') : 
          'rgba(255, 255, 255, 0.5)';
        ctx.fill();
        
        // Draw pulse if active
        if (point.active) {
          // Update pulse
          point.pulseRadius = (point.pulseRadius + 0.5) % 20;
          point.pulseOpacity = 1 - point.pulseRadius / 20;
          
          // Draw pulse
          ctx.beginPath();
          ctx.arc(point.x, point.y, point.pulseRadius + 4, 0, Math.PI * 2);
          ctx.strokeStyle = theme === 'dark' ? 
            `rgba(0, 255, 245, ${point.pulseOpacity})` : 
            `rgba(77, 77, 255, ${point.pulseOpacity})`;
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });
      
      // Update and draw particles
      const updatedParticles = [];
      
      for (const particle of particles) {
        // Update progress
        particle.progress += particle.speed / particle.distance;
        
        // Calculate new position
        particle.x = particle.startPoint.x + 
          (particle.endPoint.x - particle.startPoint.x) * particle.progress;
        particle.y = particle.startPoint.y + 
          (particle.endPoint.y - particle.startPoint.y) * particle.progress;
        
        // Keep if still active
        if (particle.progress < 1) {
          updatedParticles.push(particle);
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fillStyle = particle.color;
          ctx.fill();
        }
      }
      
      // Update particles array
      particles = updatedParticles;
      
      // Generate more particles when submitting
      if (isSubmitting) {
        points.forEach(point => {
          if (point !== submitPoint && Math.random() > 0.7) {
            createParticle(point, submitPoint);
          }
        });
      }
    };
    
    // Animation loop
    let animationId;
    const animate = () => {
      drawConnections();
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Clean up
    return () => {
      window.removeEventListener('resize', setCanvasDimensions);
      cancelAnimationFrame(animationId);
    };
  }, [theme, focusedField, isSubmitting]);
  
  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };
  
  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { type: 'spring', stiffness: 100 }
    }
  };
  
  return (
    <section className="contact-section" id="contact">
      <div className="container">
        <motion.h1 
          className="page-title"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          Neural Communication Channel
        </motion.h1>
        
        <motion.div 
          className="contact-container"
          variants={containerVariants}
          initial="hidden"
          animate="visible"
        >
          <canvas 
            ref={canvasRef} 
            className="contact-canvas"
            aria-hidden="true"
          ></canvas>
          
          <div className="contact-columns">
            <motion.div 
              className="contact-info"
              variants={itemVariants}
            >
              <div className="info-container">
                <h2 className="info-title">Communication Vectors</h2>
                
                <div className="info-section">
                  <h3 className="info-section-title">Physical Location</h3>
                  <p className="info-text">Annapolis, Maryland</p>
                </div>
                
                <div className="info-section">
                  <h3 className="info-section-title">Neural Bandwidth</h3>
                  <p className="info-text">
                    <a href="mailto:CarterPerez-dev@ProxyAuthRequired.com" className="info-link">
                      CarterPerez-dev@ProxyAuthRequired.com
                    </a>
                  </p>
                </div>
                
                <div className="info-section">
                  <h3 className="info-section-title">Frequency Channel</h3>
                  <p className="info-text">+1 443-510-0866</p>
                </div>
                
                <div className="info-section">
                  <h3 className="info-section-title">Digital Nexus Points</h3>
                  <div className="social-links">
                    <a 
                      href="https://github.com/CarterPerez-dev" 
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="social-link"
                      onClick={() => playSound('click')}
                    >
                      GitHub
                    </a>
                    <a 
                      href="https://www.linkedin.com/in/carter-perez-ProxyAuthRequired/" 
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="social-link"
                      onClick={() => playSound('click')}
                    >
                      LinkedIn
                    </a>
                  </div>
                </div>
                
                <div className="contact-data">
                  <div className="data-item">
                    <div className="data-label">STATUS</div>
                    <div className="data-value available">AVAILABLE</div>
                  </div>
                  
                  <div className="data-item">
                    <div className="data-label">RESPONSE TIME</div>
                    <div className="data-value">24-48 HRS</div>
                  </div>
                  
                  <div className="data-item">
                    <div className="data-label">PRIORITY CHANNELS</div>
                    <div className="data-value">EMAIL / FORM</div>
                  </div>
                </div>
              </div>
            </motion.div>
            
            <motion.div 
              className="contact-form-container"
              variants={itemVariants}
            >
              <form className="contact-form" onSubmit={handleSubmit}>
                <div className="form-header">
                  <h2 className="form-title">Establish Connection</h2>
                  <div className="form-subtitle">Send a direct message to my neural interface</div>
                </div>
                
                <div className="form-body">
                  <div className="form-group">
                    <label htmlFor="name" className="form-label">Identifier</label>
                    <input 
                      type="text" 
                      id="name" 
                      name="name" 
                      value={formData.name}
                      onChange={handleChange}
                      onFocus={() => handleFocus('name')}
                      onBlur={handleBlur}
                      className={`form-input connection-point ${errors.name ? 'error' : ''}`}
                      data-field="name"
                      placeholder="Your name"
                      disabled={isSubmitting}
                    />
                    {errors.name && <div className="error-message">{errors.name}</div>}
                  </div>
                  
                  <div className="form-group">
                    <label htmlFor="email" className="form-label">Neural Address</label>
                    <input 
                      type="email" 
                      id="email" 
                      name="email" 
                      value={formData.email}
                      onChange={handleChange}
                      onFocus={() => handleFocus('email')}
                      onBlur={handleBlur}
                      className={`form-input connection-point ${errors.email ? 'error' : ''}`}
                      data-field="email"
                      placeholder="Your email"
                      disabled={isSubmitting}
                    />
                    {errors.email && <div className="error-message">{errors.email}</div>}
                  </div>
                  
                  <div className="form-group">
                    <label htmlFor="subject" className="form-label">Transmission Subject</label>
                    <input 
                      type="text" 
                      id="subject" 
                      name="subject" 
                      value={formData.subject}
                      onChange={handleChange}
                      onFocus={() => handleFocus('subject')}
                      onBlur={handleBlur}
                      className={`form-input connection-point ${errors.subject ? 'error' : ''}`}
                      data-field="subject"
                      placeholder="Message subject"
                      disabled={isSubmitting}
                    />
                    {errors.subject && <div className="error-message">{errors.subject}</div>}
                  </div>
                  
                  <div className="form-group">
                    <label htmlFor="message" className="form-label">Signal Content</label>
                    <textarea 
                      id="message" 
                      name="message" 
                      value={formData.message}
                      onChange={handleChange}
                      onFocus={() => handleFocus('message')}
                      onBlur={handleBlur}
                      className={`form-textarea connection-point ${errors.message ? 'error' : ''}`}
                      data-field="message"
                      placeholder="Your message"
                      rows="5"
                      disabled={isSubmitting}
                    ></textarea>
                    {errors.message && <div className="error-message">{errors.message}</div>}
                  </div>
                  
                  <div className="form-security">
                    <div className="security-code">
                      <span className="security-label">SECURITY CODE:</span>
                      <span className="security-value">{securityCode}</span>
                    </div>
                    
                    <div className="security-message">
                      Human verification complete. You are authorized to proceed.
                    </div>
                  </div>
                </div>
                
                <div className="form-footer">
                  <button 
                    type="submit" 
                    className="submit-button connection-point"
                    data-field="submit"
                    disabled={isSubmitting}
                  >
                    {isSubmitting ? (
                      <span className="button-text">
                        <span className="loading-icon"></span>
                        TRANSMITTING...
                      </span>
                    ) : (
                      <span className="button-text">INITIATE TRANSMISSION</span>
                    )}
                  </button>
                </div>
              </form>
              
              {showSuccess && (
                <div className="form-notification success">
                  <div className="notification-icon">âœ“</div>
                  <div className="notification-content">
                    <div className="notification-title">TRANSMISSION SUCCESSFUL</div>
                    <div className="notification-message">
                      Your message has been received. I will respond through your provided neural address.
                    </div>
                  </div>
                </div>
              )}
              
              {showFailure && (
                <div className="form-notification error">
                  <div className="notification-icon">!</div>
                  <div className="notification-content">
                    <div className="notification-title">TRANSMISSION FAILED</div>
                    <div className="notification-message">
                      A neural interference occurred. Please try again or use an alternate communication vector.
                    </div>
                  </div>
                </div>
              )}
            </motion.div>
          </div>
        </motion.div>
      </div>
      
      <style jsx>{`
        .contact-section {
          padding: var(--space-xxl) 0;
          position: relative;
          min-height: 100vh;
          display: flex;
          align-items: center;
        }
        
        .page-title {
          text-align: center;
          margin-bottom: var(--space-xl);
          color: var(--accent-cyan);
          font-size: 3rem;
          position: relative;
        }
        
        .page-title::after {
          content: '';
          position: absolute;
          bottom: -10px;
          left: 50%;
          transform: translateX(-50%);
          width: 100px;
          height: 3px;
          background: linear-gradient(
            90deg,
            transparent,
            var(--accent-cyan),
            transparent
          );
        }
        
        .contact-container {
          position: relative;
          width: 100%;
          min-height: 600px;
          border-radius: var(--border-radius-lg);
          overflow: hidden;
        }
        
        .contact-canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 0;
          pointer-events: none;
        }
        
        .contact-columns {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xl);
          position: relative;
          z-index: 1;
        }
        
        .contact-info {
          flex: 1;
          min-width: 300px;
        }
        
        .info-container {
          background-color: rgba(10, 10, 10, 0.75);
          border: 1px solid var(--accent-cyan);
          border-radius: var(--border-radius-md);
          padding: var(--space-lg);
          height: 100%;
          display: flex;
          flex-direction: column;
          backdrop-filter: blur(5px);
        }
        
        .info-title {
          font-size: 1.5rem;
          color: var(--accent-cyan);
          margin-bottom: var(--space-lg);
          position: relative;
        }
        
        .info-title::after {
          content: '';
          position: absolute;
          bottom: -10px;
          left: 0;
          width: 60px;
          height: 2px;
          background-color: var(--accent-cyan);
        }
        
        .info-section {
          margin-bottom: var(--space-lg);
        }
        
        .info-section-title {
          font-size: 0.9rem;
          font-family: var(--font-mono);
          color: var(--accent-magenta);
          margin-bottom: var(--space-xs);
          letter-spacing: 1px;
        }
        
        .info-text {
          color: var(--text-primary);
          font-size: 1.1rem;
        }
        
        .info-link {
          color: var(--accent-cyan);
          position: relative;
          transition: all var(--transition-normal);
        }
        
        .info-link:hover {
          color: var(--accent-blue);
        }
        
        .social-links {
          display: flex;
          gap: var(--space-md);
          margin-top: var(--space-xs);
        }
        
        .social-link {
          display: inline-block;
          padding: var(--space-xs) var(--space-md);
          background-color: rgba(0, 255, 245, 0.1);
          border: 1px solid var(--accent-cyan);
          border-radius: var(--border-radius-sm);
          color: var(--accent-cyan);
          font-family: var(--font-mono);
          font-size: 0.9rem;
          transition: all var(--transition-normal);
        }
        
        .social-link:hover {
          background-color: var(--accent-cyan);
          color: var(--bg-primary);
          transform: translateY(-2px);
        }
        
        .contact-data {
          margin-top: auto;
          background-color: rgba(0, 0, 0, 0.3);
          border-radius: var(--border-radius-sm);
          padding: var(--space-md);
        }
        
        .data-item {
          display: flex;
          justify-content: space-between;
          margin-bottom: var(--space-xs);
        }
        
        .data-item:last-child {
          margin-bottom: 0;
        }
        
        .data-label {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--text-secondary);
        }
        
        .data-value {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--accent-cyan);
        }
        
        .data-value.available {
          color: var(--accent-green);
        }
        
        .contact-form-container {
          flex: 1.5;
          min-width: 400px;
          position: relative;
        }
        
        .contact-form {
          background-color: rgba(10, 10, 10, 0.75);
          border: 1px solid var(--accent-cyan);
          border-radius: var(--border-radius-md);
          overflow: hidden;
          display: flex;
          flex-direction: column;
          height: 100%;
          backdrop-filter: blur(5px);
        }
        
        .form-header {
          padding: var(--space-md) var(--space-lg);
          background-color: rgba(0, 0, 0, 0.3);
          border-bottom: 1px solid rgba(0, 255, 245, 0.2);
        }
        
        .form-title {
          font-size: 1.5rem;
          color: var(--accent-cyan);
          margin-bottom: var(--space-xs);
        }
        
        .form-subtitle {
          color: var(--text-secondary);
          font-size: 0.9rem;
        }
        
        .form-body {
          padding: var(--space-lg);
          flex: 1;
        }
        
        .form-group {
          margin-bottom: var(--space-lg);
        }
        
        .form-label {
          display: block;
          font-family: var(--font-mono);
          font-size: 0.9rem;
          color: var(--text-secondary);
          margin-bottom: var(--space-xs);
        }
        
        .form-input,
        .form-textarea {
          width: 100%;
          background-color: rgba(0, 0, 0, 0.3);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: var(--border-radius-sm);
          padding: var(--space-sm) var(--space-md);
          color: var(--text-primary);
          font-family: var(--font-body);
          font-size: 1rem;
          transition: all var(--transition-normal);
        }
        
        .form-input:focus,
        .form-textarea:focus {
          border-color: var(--accent-cyan);
          box-shadow: 0 0 10px rgba(0, 255, 245, 0.2);
          outline: none;
        }
        
        .form-input.error,
        .form-textarea.error {
          border-color: var(--accent-magenta);
          box-shadow: 0 0 10px rgba(255, 61, 61, 0.2);
        }
        
        .error-message {
          color: var(--accent-magenta);
          font-size: 0.8rem;
          margin-top: var(--space-xs);
          font-family: var(--font-mono);
        }
        
        .form-security {
          display: flex;
          align-items: center;
          justify-content: space-between;
          background-color: rgba(0, 0, 0, 0.3);
          border-radius: var(--border-radius-sm);
          padding: var(--space-sm) var(--space-md);
          margin-bottom: var(--space-md);
        }
        
        .security-code {
          display: flex;
          align-items: center;
          gap: var(--space-xs);
        }
        
        .security-label {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--text-secondary);
        }
        
        .security-value {
          font-family: var(--font-mono);
          font-size: 1rem;
          color: var(--accent-cyan);
          letter-spacing: 1px;
        }
        
        .security-message {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--accent-green);
        }
        
        .form-footer {
          padding: var(--space-md) var(--space-lg);
          background-color: rgba(0, 0, 0, 0.3);
          border-top: 1px solid rgba(0, 255, 245, 0.2);
          display: flex;
          justify-content: flex-end;
        }
        
        .submit-button {
          padding: var(--space-sm) var(--space-xl);
          background-color: rgba(0, 255, 245, 0.1);
          border: 1px solid var(--accent-cyan);
          border-radius: var(--border-radius-sm);
          color: var(--accent-cyan);
          font-family: var(--font-mono);
          font-size: 0.9rem;
          letter-spacing: 1px;
          transition: all var(--transition-normal);
          cursor: none;
          position: relative;
          overflow: hidden;
        }
        
        .submit-button::before {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(
            90deg,
            transparent,
            rgba(0, 255, 245, 0.2),
            transparent
          );
          transition: left 0.5s ease;
        }
        
        .submit-button:hover {
          background-color: rgba(0, 255, 245, 0.2);
          transform: translateY(-2px);
        }
        
        .submit-button:hover::before {
          left: 100%;
        }
        
        .submit-button:disabled {
          opacity: 0.7;
          cursor: not-allowed;
        }
        
        .submit-button:disabled:hover {
          transform: none;
        }
        
        .button-text {
          display: flex;
          align-items: center;
          justify-content: center;
          gap: var(--space-xs);
        }
        
        .loading-icon {
          display: inline-block;
          width: 16px;
          height: 16px;
          border: 2px solid rgba(0, 255, 245, 0.3);
          border-top: 2px solid var(--accent-cyan);
          border-radius: 50%;
          animation: loading-spin 1s linear infinite;
        }
        
        .form-notification {
          position: absolute;
          bottom: var(--space-md);
          left: 0;
          right: 0;
          width: 80%;
          margin: 0 auto;
          padding: var(--space-md);
          border-radius: var(--border-radius-md);
          display: flex;
          align-items: center;
          gap: var(--space-md);
          animation: slide-up 0.5s ease-out;
        }
        
        .form-notification.success {
          background-color: rgba(0, 255, 165, 0.1);
          border: 1px solid var(--accent-green);
        }
        
        .form-notification.error {
          background-color: rgba(255, 61, 61, 0.1);
          border: 1px solid var(--accent-magenta);
        }
        
        .notification-icon {
          display: flex;
          align-items: center;
          justify-content: center;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          font-size: 1.2rem;
          font-weight: bold;
        }
        
        .success .notification-icon {
          background-color: rgba(0, 255, 165, 0.2);
          color: var(--accent-green);
        }
        
        .error .notification-icon {
          background-color: rgba(255, 61, 61, 0.2);
          color: var(--accent-magenta);
        }
        
        .notification-content {
          flex: 1;
        }
        
        .notification-title {
          font-family: var(--font-mono);
          font-size: 1rem;
          margin-bottom: var(--space-xs);
        }
        
        .success .notification-title {
          color: var(--accent-green);
        }
        
        .error .notification-title {
          color: var(--accent-magenta);
        }
        
        .notification-message {
          color: var(--text-secondary);
          font-size: 0.9rem;
        }
        
        /* Light theme styles */
        .light-theme .info-container,
        .light-theme .contact-form {
          background-color: rgba(245, 245, 245, 0.75);
          border-color: var(--accent-blue);
        }
        
        .light-theme .form-header,
        .light-theme .form-footer {
          background-color: rgba(220, 220, 220, 0.3);
          border-color: rgba(77, 77, 255, 0.2);
        }
        
        .light-theme .info-title,
        .light-theme .form-title,
        .light-theme .data-value,
        .light-theme .security-value {
          color: var(--accent-blue);
        }
        
        .light-theme .info-title::after {
          background-color: var(--accent-blue);
        }
        
        .light-theme .form-input,
        .light-theme .form-textarea {
          background-color: rgba(255, 255, 255, 0.3);
          border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-theme .form-input:focus,
        .light-theme .form-textarea:focus {
          border-color: var(--accent-blue);
          box-shadow: 0 0 10px rgba(77, 77, 255, 0.2);
        }
        
        .light-theme .contact-data,
        .light-theme .form-security {
          background-color: rgba(220, 220, 220, 0.3);
        }
        
        .light-theme .social-link {
          background-color: rgba(77, 77, 255, 0.1);
          border-color: var(--accent-blue);
          color: var(--accent-blue);
        }
        
        .light-theme .social-link:hover {
          background-color: var(--accent-blue);
          color: white;
        }
        
        .light-theme .submit-button {
          background-color: rgba(77, 77, 255, 0.1);
          border-color: var(--accent-blue);
          color: var(--accent-blue);
        }
        
        .light-theme .submit-button::before {
          background: linear-gradient(
            90deg,
            transparent,
            rgba(77, 77, 255, 0.2),
            transparent
          );
        }
        
        .light-theme .submit-button:hover {
          background-color: rgba(77, 77, 255, 0.2);
        }
        
        .light-theme .loading-icon {
          border-color: rgba(77, 77, 255, 0.3);
          border-top-color: var(--accent-blue);
        }
        
        /* Animations */
        @keyframes loading-spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        @keyframes slide-up {
          0% { transform: translateY(20px); opacity: 0; }
          100% { transform: translateY(0); opacity: 1; }
        }
        
        /* Media queries */
        @media (max-width: 1200px) {
          .contact-columns {
            flex-direction: column;
          }
          
          .contact-info,
          .contact-form-container {
            width: 100%;
          }
        }
        
        @media (max-width: 768px) {
          .page-title {
            font-size: 2.5rem;
          }
          
          .info-title,
          .form-title {
            font-size: 1.3rem;
          }
          
          .form-security {
            flex-direction: column;
            align-items: flex-start;
            gap: var(--space-xs);
          }
          
          .security-message {
            font-size: 0.7rem;
          }
        }
        
        @media (max-width: 480px) {
          .page-title {
            font-size: 2rem;
          }
          
          .contact-form-container {
            min-width: 100%;
          }
          
          .form-body,
          .info-container {
            padding: var(--space-md);
          }
          
          .form-header,
          .form-footer {
            padding: var(--space-sm) var(--space-md);
          }
          
          .submit-button {
            width: 100%;
          }
          
          .form-notification {
            width: 90%;
          }
        }
      `}</style>
    </section>
  );
};

export default ContactPortal;
</file>

<file path="frontend/src/components/sections/HolographicTimeline.jsx">
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useAudio } from '../../contexts/AudioContext';

// Timeline data
const TIMELINE_DATA = [
  {
    id: 1,
    title: 'System Integration Technician II',
    company: 'Sealing Technologies',
    location: 'Annapolis, MD',
    date: '2024 - Present',
    description: 'Building and configuring custom cybersecurity and defense systems, ensuring they meet client needs and perform reliably under demanding conditions. Responsibilities include system assembly, optimization, testing, and maintenance, as well as collaborating with cross-functional teams to deliver comprehensive solutions.',
    achievements: [
      'Completed over 50 custom system builds with a 99.8% pass rate on quality assurance tests',
      'Implemented new cable management techniques that reduced setup time by 15%',
      'Authored a company blog post on efficient quality assurance processes',
      'Reduced RMA rates by 22% through improved assembly procedures'
    ],
    skills: ['System Integration', 'Quality Assurance', 'Hardware Configuration', 'Technical Documentation'],
    category: 'work'
  },
  {
    id: 2,
    title: "Master's Degree in Cybersecurity",
    company: 'University of Maryland Global Campus',
    location: 'Adelphi, MD',
    date: '2024 - Present',
    description: 'Currently pursuing a master\'s degree with advanced studies in cybersecurity strategies and threat management.',
    achievements: [
      'Maintaining a 3.9 GPA while working full-time',
      'Specializing in advanced security protocols and threat intelligence',
      'Participating in cybersecurity research projects',
      'Member of the Cybersecurity Club'
    ],
    skills: ['Advanced Cybersecurity', 'Threat Intelligence', 'Security Research', 'Risk Management'],
    category: 'education'
  },
  {
    id: 3,
    title: 'Developed ProxyAuthRequired.com',
    company: 'Personal Project',
    location: 'Remote',
    date: 'December, 2024',
    description: 'Developed a centralized cybersecurity platform integrating AI-driven simulations and learning modules. Features include GRC Wizard for compliance questions, Log Analysis for real-time practice, and scenario-based exercises for incident response.',
    achievements: [
      'Built a secure, scalable platform leveraging Docker containers and multi-stage builds',
      'Integrated advanced log analysis and compliance tools',
      'Created an educational hub tailored for CompTIA certifications',
      'Successfully launched with positive user feedback'
    ],
    skills: ['React', 'Python', 'Flask', 'MongoDB', 'Docker', 'AI Integration'],
    category: 'project'
  },
  {
    id: 4,
    title: 'CompTIA Certification Path',
    company: 'CompTIA',
    location: 'Remote',
    date: '2024',
    description: 'Completed the full CompTIA cybersecurity path within nine months, acquiring seven certifications including A+, Network+, Security+, CySA+, PenTest+, and CASP+.',
    achievements: [
      'Achieved all certifications on first attempt',
      'Completed certifications in record time',
      'Developed efficient study techniques for rapid certification',
      'Presented study methods at ISSA UMBC chapter'
    ],
    skills: ['Cybersecurity Fundamentals', 'Network Security', 'Penetration Testing', 'Security Analysis'],
    category: 'certification'
  },
  {
    id: 5,
    title: 'General Manager',
    company: "Jimmy John's",
    location: 'Severna Park, MD',
    date: '2022 - 2024',
    description: 'Managed daily operations, supervised staff, and ensured customer satisfaction. Optimized workflows and enhanced team performance while troubleshooting technical issues with network and point-of-sale systems.',
    achievements: [
      'Increased store revenue by 18% through operational improvements',
      'Reduced employee turnover by 35% through improved training',
      'Maintained network and POS systems with 99.7% uptime',
      'Implemented new inventory system reducing waste by 12%'
    ],
    skills: ['Team Management', 'Operations', 'Customer Service', 'Technical Support'],
    category: 'work'
  },
  {
    id: 6,
    title: 'Associates in Cybersecurity',
    company: 'Anne Arundel Community College',
    location: 'Arnold, MD',
    date: '2022 - 2024',
    description: 'Completed foundational courses in cybersecurity, focusing on network security and ethical hacking.',
    achievements: [
      'Graduated with honors (3.8 GPA)',
      'Participated in capture-the-flag competitions',
      'Completed independent study on cloud security',
      'Assisted professors with lab setup for security courses'
    ],
    skills: ['Network Security', 'Ethical Hacking', 'Information Security', 'Risk Assessment'],
    category: 'education'
  },
  {
    id: 7,
    title: 'AutoApplication Development',
    company: 'Personal Project',
    location: 'Remote',
    date: 'July, 2024',
    description: 'Created an automated application bot for Indeed and LinkedIn, streamlining the job application process with web automation and scripting.',
    achievements: [
      'Developed Python-based automation using Selenium',
      'Implemented custom resume parsing and matching algorithms',
      'Reduced application time by 90% compared to manual process',
      'Built flexible configuration for different job search criteria'
    ],
    skills: ['Python', 'Selenium', 'Web Scraping', 'Process Automation'],
    category: 'project'
  }
];

// Category settings
const CATEGORIES = [
  { id: 'all', name: 'ALL', icon: 'âš¡' },
  { id: 'work', name: 'WORK', icon: 'ðŸ’¼' },
  { id: 'education', name: 'EDUCATION', icon: 'ðŸŽ“' },
  { id: 'project', name: 'PROJECTS', icon: 'ðŸš€' },
  { id: 'certification', name: 'CERTIFICATIONS', icon: 'ðŸ“œ' }
];

const HolographicTimeline = ({ fullPage = false }) => {
  const { theme } = useTheme();
  const { playSound } = useAudio();
  const canvasRef = useRef(null);
  const timelineRef = useRef(null);
  const [activeCategory, setActiveCategory] = useState('all');
  const [filteredItems, setFilteredItems] = useState([]);
  const [expandedItem, setExpandedItem] = useState(null);
  const [hoveredItem, setHoveredItem] = useState(null);
  const [scrollPosition, setScrollPosition] = useState(0);
  
  // Apply filter
  useEffect(() => {
    if (activeCategory === 'all') {
      setFilteredItems([...TIMELINE_DATA].sort((a, b) => {
        const dateA = parseDate(a.date);
        const dateB = parseDate(b.date);
        return dateB - dateA; // Most recent first
      }));
    } else {
      setFilteredItems(
        [...TIMELINE_DATA]
          .filter(item => item.category === activeCategory)
          .sort((a, b) => {
            const dateA = parseDate(a.date);
            const dateB = parseDate(b.date);
            return dateB - dateA; // Most recent first
          })
      );
    }
  }, [activeCategory]);
  
  // Handle category change
  const handleCategoryChange = (categoryId) => {
    setActiveCategory(categoryId);
    setExpandedItem(null);
    playSound('click');
  };
  
  // Handle item click
  const handleItemClick = (itemId) => {
    setExpandedItem(expandedItem === itemId ? null : itemId);
    playSound('click');
  };
  
  // Holographic grid effect animation
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    const setCanvasDimensions = () => {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };
    
    window.addEventListener('resize', setCanvasDimensions);
    setCanvasDimensions();
    
    // Grid parameters
    const gridSize = 30;
    
    // Render holographic grid
    const renderGrid = () => {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Set color based on theme
      const primaryColor = theme === 'dark' ? 
        'rgba(0, 255, 245, 0.4)' : 'rgba(77, 77, 255, 0.4)';
      const secondaryColor = 'rgba(255, 61, 61, 0.2)';
      
      // Draw vertical lines
      for (let x = 0; x < canvas.width; x += gridSize) {
        const opacity = 0.1 + Math.sin(x * 0.01 + scrollPosition * 0.002) * 0.05;
        
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.strokeStyle = x % (gridSize * 2) === 0 ? 
          primaryColor.replace('0.4', opacity) : 
          secondaryColor.replace('0.2', opacity * 0.5);
        ctx.lineWidth = x % (gridSize * 3) === 0 ? 1.5 : 0.5;
        ctx.stroke();
      }
      
      // Draw horizontal lines
      for (let y = 0; y < canvas.height; y += gridSize) {
        const opacity = 0.1 + Math.cos(y * 0.01 + scrollPosition * 0.002) * 0.05;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.strokeStyle = y % (gridSize * 2) === 0 ? 
          primaryColor.replace('0.4', opacity) : 
          secondaryColor.replace('0.2', opacity * 0.5);
        ctx.lineWidth = y % (gridSize * 3) === 0 ? 1.5 : 0.5;
        ctx.stroke();
      }
      
      // Draw glow effect for hover or expanded item
      if (hoveredItem !== null || expandedItem !== null) {
        const itemId = hoveredItem !== null ? hoveredItem : expandedItem;
        const index = filteredItems.findIndex(item => item.id === itemId);
        
        if (index !== -1) {
          const itemElement = document.getElementById(`timeline-item-${itemId}`);
          
          if (itemElement) {
            const rect = itemElement.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            const x = rect.left - canvasRect.left + rect.width / 2;
            const y = rect.top - canvasRect.top + rect.height / 2;
            const radius = Math.max(rect.width, rect.height) * 0.7;
            
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, `rgba(0, 255, 245, ${hoveredItem !== null ? 0.3 : 0.2})`);
            gradient.addColorStop(1, 'rgba(0, 255, 245, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
      }
    };
    
    // Update scroll position
    const handleScroll = () => {
      if (timelineRef.current) {
        setScrollPosition(timelineRef.current.scrollTop);
      }
    };
    
    timelineRef.current?.addEventListener('scroll', handleScroll);
    
    // Animation loop
    let animationId;
    const animate = () => {
      renderGrid();
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Clean up
    return () => {
      window.removeEventListener('resize', setCanvasDimensions);
      timelineRef.current?.removeEventListener('scroll', handleScroll);
      cancelAnimationFrame(animationId);
    };
  }, [theme, hoveredItem, expandedItem, filteredItems, scrollPosition]);
  
  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.05
      }
    }
  };
  
  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { type: 'spring', stiffness: 100 }
    }
  };
  
  // Helper function to parse date strings (for sorting)
  function parseDate(dateStr) {
    // Handle ranges like "2022 - 2024" or "2024 - Present"
    if (dateStr.includes('-')) {
      const parts = dateStr.split('-');
      const endPart = parts[1].trim();
      
      // If end date is "Present", use current date
      if (endPart === 'Present') {
        return new Date();
      }
      
      // Otherwise use the end year
      return new Date(endPart, 0);
    }
    
    // Handle months like "December, 2024"
    if (dateStr.includes(',')) {
      return new Date(dateStr);
    }
    
    // Handle just years like "2024"
    return new Date(dateStr, 0);
  }
  
  // Get category icon and styling
  const getCategoryStyle = (category) => {
    switch (category) {
      case 'work':
        return { icon: 'ðŸ’¼', color: 'var(--accent-cyan)' };
      case 'education':
        return { icon: 'ðŸŽ“', color: 'var(--accent-blue)' };
      case 'project':
        return { icon: 'ðŸš€', color: 'var(--accent-magenta)' };
      case 'certification':
        return { icon: 'ðŸ“œ', color: 'var(--accent-green)' };
      default:
        return { icon: 'âš¡', color: 'var(--accent-purple)' };
    }
  };
  
  return (
    <section className={`timeline-section ${fullPage ? 'full-page' : ''}`} id="experience">
      <div className="container">
        {!fullPage && (
          <motion.h2 
            className="section-title"
            initial={{ opacity: 0, y: -20 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true, margin: "-100px" }}
            transition={{ duration: 0.5 }}
          >
            Experience Timeline
          </motion.h2>
        )}
        
        {fullPage && (
          <motion.h1 
            className="page-title"
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            Chronological Matrix
          </motion.h1>
        )}
        
        <motion.div 
          className="category-selector"
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true, margin: "-100px" }}
          transition={{ duration: 0.5, delay: 0.1 }}
        >
          {CATEGORIES.map((category) => (
            <button
              key={category.id}
              className={`category-button ${activeCategory === category.id ? 'active' : ''}`}
              onClick={() => handleCategoryChange(category.id)}
            >
              <span className="category-icon">{category.icon}</span>
              <span className="category-name">{category.name}</span>
            </button>
          ))}
        </motion.div>
        
        <div className="timeline-container">
          <canvas 
            ref={canvasRef} 
            className="timeline-grid"
            aria-hidden="true"
          ></canvas>
          
          <motion.div 
            className="timeline-items"
            ref={timelineRef}
            variants={containerVariants}
            initial="hidden"
            whileInView="visible"
            viewport={{ once: true, margin: "-100px" }}
          >
            {filteredItems.length > 0 ? (
              filteredItems.map((item, index) => {
                const categoryStyle = getCategoryStyle(item.category);
                const isExpanded = expandedItem === item.id;
                
                return (
                  <motion.div 
                    key={item.id}
                    id={`timeline-item-${item.id}`}
                    className={`timeline-item ${isExpanded ? 'expanded' : ''} ${hoveredItem === item.id ? 'hovered' : ''}`}
                    variants={itemVariants}
                    onClick={() => handleItemClick(item.id)}
                    onMouseEnter={() => setHoveredItem(item.id)}
                    onMouseLeave={() => setHoveredItem(null)}
                    style={{
                      '--timeline-color': categoryStyle.color
                    }}
                  >
                    <div className="timeline-item-header">
                      <div className="timeline-icon" style={{ backgroundColor: categoryStyle.color }}>
                        {categoryStyle.icon}
                      </div>
                      
                      <div className="timeline-header-content">
                        <h3 className="timeline-title">{item.title}</h3>
                        <div className="timeline-subtitle">
                          <span className="timeline-company">{item.company}</span>
                          <span className="timeline-separator">|</span>
                          <span className="timeline-location">{item.location}</span>
                        </div>
                      </div>
                      
                      <div className="timeline-date">{item.date}</div>
                    </div>
                    
                    <div className="timeline-content">
                      <p className="timeline-description">{item.description}</p>
                      
                      {isExpanded && (
                        <div className="timeline-details">
                          <div className="timeline-section">
                            <h4 className="timeline-section-title">Key Achievements</h4>
                            <ul className="timeline-achievements">
                              {item.achievements.map((achievement, idx) => (
                                <li key={idx} className="timeline-achievement-item">
                                  {achievement}
                                </li>
                              ))}
                            </ul>
                          </div>
                          
                          <div className="timeline-section">
                            <h4 className="timeline-section-title">Skills Applied</h4>
                            <div className="timeline-skills">
                              {item.skills.map((skill, idx) => (
                                <span key={idx} className="timeline-skill">
                                  {skill}
                                </span>
                              ))}
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                    
                    <div className="timeline-connector">
                      <div className="timeline-line"></div>
                      <div className="timeline-dot"></div>
                    </div>
                  </motion.div>
                );
              })
            ) : (
              <motion.div 
                className="no-items-message"
                variants={itemVariants}
              >
                <div className="no-items-icon">ðŸ”</div>
                <h3>NO TIMELINE ENTRIES FOUND</h3>
                <p>Try selecting a different category filter.</p>
              </motion.div>
            )}
          </motion.div>
        </div>
      </div>
      
      <style jsx>{`
        .timeline-section {
          position: relative;
          padding: var(--space-xxl) 0;
          min-height: ${fullPage ? '100vh' : 'auto'};
        }
        
        .timeline-section.full-page {
          padding-top: calc(var(--header-height) + var(--space-xl));
        }
        
        .section-title,
        .page-title {
          text-align: center;
          margin-bottom: var(--space-xl);
          color: var(--accent-cyan);
          position: relative;
          display: inline-block;
          width: 100%;
        }
        
        .page-title {
          font-size: 3rem;
        }
        
        .section-title::after,
        .page-title::after {
          content: '';
          position: absolute;
          bottom: -10px;
          left: 50%;
          transform: translateX(-50%);
          width: 100px;
          height: 3px;
          background: linear-gradient(
            90deg,
            transparent,
            var(--accent-cyan),
            transparent
          );
        }
        
        .category-selector {
          display: flex;
          justify-content: center;
          gap: var(--space-md);
          margin-bottom: var(--space-xl);
          flex-wrap: wrap;
        }
        
        .category-button {
          display: flex;
          align-items: center;
          gap: var(--space-xs);
          padding: var(--space-sm) var(--space-md);
          background-color: rgba(10, 10, 10, 0.5);
          border: 1px solid var(--border-primary);
          border-radius: var(--border-radius-sm);
          color: var(--text-secondary);
          transition: all var(--transition-normal);
          cursor: none;
        }
        
        .category-button:hover {
          transform: translateY(-2px);
          border-color: var(--accent-cyan);
          box-shadow: 0 0 10px rgba(0, 255, 245, 0.2);
        }
        
        .category-button.active {
          background-color: rgba(0, 255, 245, 0.1);
          border-color: var(--accent-cyan);
          color: var(--accent-cyan);
          box-shadow: 0 0 15px rgba(0, 255, 245, 0.3);
        }
        
        .category-icon {
          font-size: 1.2rem;
        }
        
        .category-name {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          letter-spacing: 1px;
        }
        
        .timeline-container {
          position: relative;
          width: 100%;
          height: 600px;
          background-color: rgba(10, 10, 10, 0.5);
          border-radius: var(--border-radius-lg);
          overflow: hidden;
          border: 1px solid var(--border-primary);
        }
        
        .timeline-grid {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 1;
          pointer-events: none;
        }
        
        .timeline-items {
          position: relative;
          z-index: 2;
          height: 100%;
          overflow-y: auto;
          padding: var(--space-lg);
        }
        
        .timeline-items::-webkit-scrollbar {
          width: 6px;
        }
        
        .timeline-items::-webkit-scrollbar-track {
          background: rgba(0, 0, 0, 0.2);
          border-radius: 3px;
        }
        
        .timeline-items::-webkit-scrollbar-thumb {
          background: var(--accent-cyan);
          border-radius: 3px;
        }
        
        .timeline-item {
          position: relative;
          background-color: rgba(20, 20, 20, 0.7);
          border-radius: var(--border-radius-md);
          margin-bottom: var(--space-lg);
          overflow: hidden;
          backdrop-filter: blur(5px);
          border: 1px solid rgba(255, 255, 255, 0.1);
          transition: all var(--transition-normal);
          transform-origin: center left;
        }
        
        .timeline-item:hover,
        .timeline-item.hovered {
          transform: translateX(5px);
          border-color: var(--timeline-color);
          box-shadow: 0 0 20px rgba(0, 0, 0, 0.3), 0 0 10px var(--timeline-color);
        }
        
        .timeline-item.expanded {
          background-color: rgba(30, 30, 30, 0.8);
        }
        
        .timeline-item-header {
          display: flex;
          align-items: center;
          padding: var(--space-md);
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
          cursor: none;
        }
        
        .timeline-icon {
          display: flex;
          align-items: center;
          justify-content: center;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          margin-right: var(--space-md);
          flex-shrink: 0;
        }
        
        .timeline-header-content {
          flex: 1;
        }
        
        .timeline-title {
          font-size: 1.2rem;
          margin-bottom: var(--space-xs);
          color: var(--text-primary);
        }
        
        .timeline-subtitle {
          display: flex;
          align-items: center;
          color: var(--text-secondary);
          font-size: 0.9rem;
          flex-wrap: wrap;
        }
        
        .timeline-separator {
          margin: 0 var(--space-xs);
          color: var(--text-tertiary);
        }
        
        .timeline-date {
          font-family: var(--font-mono);
          font-size: 0.9rem;
          color: var(--timeline-color);
          white-space: nowrap;
          margin-left: var(--space-md);
        }
        
        .timeline-content {
          padding: var(--space-md);
        }
        
        .timeline-description {
          color: var(--text-secondary);
          line-height: 1.5;
          margin-bottom: var(--space-md);
        }
        
        .timeline-details {
          border-top: 1px solid rgba(255, 255, 255, 0.1);
          padding-top: var(--space-md);
        }
        
        .timeline-section {
          margin-bottom: var(--space-md);
        }
        
        .timeline-section:last-child {
          margin-bottom: 0;
        }
        
        .timeline-section-title {
          font-size: 1rem;
          color: var(--timeline-color);
          margin-bottom: var(--space-sm);
          font-family: var(--font-mono);
          letter-spacing: 1px;
        }
        
        .timeline-achievements {
          list-style-type: none;
          padding-left: var(--space-md);
        }
        
        .timeline-achievement-item {
          position: relative;
          color: var(--text-secondary);
          margin-bottom: var(--space-xs);
          line-height: 1.5;
        }
        
        .timeline-achievement-item::before {
          content: 'â–¹';
          position: absolute;
          left: -15px;
          color: var(--timeline-color);
        }
        
        .timeline-skills {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
        }
        
        .timeline-skill {
          background-color: rgba(255, 255, 255, 0.1);
          color: var(--text-primary);
          padding: 3px 10px;
          border-radius: var(--border-radius-sm);
          font-size: 0.8rem;
          border: 1px solid var(--timeline-color);
        }
        
        .timeline-connector {
          position: absolute;
          top: 0;
          left: 0;
          height: 100%;
          display: flex;
          flex-direction: column;
          align-items: center;
          pointer-events: none;
          z-index: -1;
        }
        
        .timeline-line {
          position: absolute;
          top: 0;
          bottom: 0;
          left: 20px;
          width: 1px;
          background-color: var(--timeline-color);
        }
        
        .timeline-dot {
          position: absolute;
          top: 30px;
          left: 20px;
          width: 10px;
          height: 10px;
          background-color: var(--timeline-color);
          border-radius: 50%;
          transform: translateX(-4.5px);
          box-shadow: 0 0 10px var(--timeline-color);
        }
        
        .no-items-message {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: var(--text-secondary);
          text-align: center;
        }
        
        .no-items-icon {
          font-size: 3rem;
          margin-bottom: var(--space-md);
        }
        
        /* Light theme styles */
        .light-theme .timeline-container {
          background-color: rgba(245, 245, 245, 0.5);
        }
        
        .light-theme .timeline-item {
          background-color: rgba(230, 230, 230, 0.7);
          border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-theme .timeline-item.expanded {
          background-color: rgba(215, 215, 215, 0.8);
        }
        
        .light-theme .category-button {
          background-color: rgba(220, 220, 220, 0.5);
          border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-theme .category-button:hover {
          border-color: var(--accent-blue);
          box-shadow: 0 0 10px rgba(77, 77, 255, 0.2);
        }
        
        .light-theme .category-button.active {
          background-color: rgba(77, 77, 255, 0.1);
          border-color: var(--accent-blue);
          color: var(--accent-blue);
          box-shadow: 0 0 15px rgba(77, 77, 255, 0.3);
        }
        
        .light-theme .timeline-items::-webkit-scrollbar-thumb {
          background: var(--accent-blue);
        }
        
        .light-theme .timeline-item-header,
        .light-theme .timeline-details {
          border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-theme .timeline-skill {
          background-color: rgba(0, 0, 0, 0.05);
        }
        
        /* Media queries */
        @media (max-width: 768px) {
          .category-selector {
            gap: var(--space-sm);
          }
          
          .category-button {
            padding: var(--space-xs) var(--space-sm);
          }
          
          .timeline-item-header {
            flex-direction: column;
            align-items: flex-start;
          }
          
          .timeline-date {
            margin-left: 0;
            margin-top: var(--space-xs);
          }
          
          .timeline-items {
            padding: var(--space-md);
          }
          
          .page-title {
            font-size: 2.2rem;
          }
        }
        
        @media (max-width: 480px) {
          .timeline-icon {
            width: 32px;
            height: 32px;
            font-size: 0.9rem;
          }
          
          .timeline-title {
            font-size: 1rem;
          }
          
          .timeline-subtitle {
            font-size: 0.8rem;
          }
          
          .timeline-date {
            font-size: 0.8rem;
          }
          
          .timeline-description {
            font-size: 0.9rem;
          }
          
          .timeline-section-title {
            font-size: 0.9rem;
          }
          
          .timeline-achievement-item,
          .timeline-skill {
            font-size: 0.8rem;
          }
          
          .category-name {
            display: none;
          }
          
          .category-icon {
            font-size: 1.5rem;
          }
          
          .category-button {
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
          }
        }
      `}</style>
    </section>
  );
};

export default HolographicTimeline;
</file>

<file path="frontend/src/components/sections/ProjectsGrid.jsx">
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { Link } from 'react-router-dom';
import { useTheme } from '../../contexts/ThemeContext';
import { useAudio } from '../../contexts/AudioContext';

const ProjectsGrid = ({ fullPage = false }) => {
  const { theme } = useTheme();
  const { playSound } = useAudio();
  const [activeFilter, setActiveFilter] = useState('all');
  const [filteredProjects, setFilteredProjects] = useState([]);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [hoveredProject, setHoveredProject] = useState(null);
  const projectsContainerRef = useRef(null);
  
  // Project data with your specified projects
  const projects = [
    {
      id: 1,
      title: 'CertGames.com',
      description: 'A gamified platform for certification preparation. Follow structured roadmaps to learn, practice, and master certifications like CompTIA. Earn XP, unlock badges, and track your progress.',
      image: '/assets/projects/certgames.jpg',
      categories: ['cybersecurity', 'education'],
      technologies: ['React', 'Node.js', 'MongoDB', 'Express'],
      link: 'https://certgames.com',
      featured: true
    },
    {
      id: 2,
      title: 'Flask-Honeypot',
      description: 'A lightweight honeypot system built with Flask. Detects and logs potential cyber attacks while presenting convincing decoy services to attackers. Helps identify common attack vectors and malicious IP addresses.',
      image: '/assets/projects/honeypot.jpg',
      categories: ['cybersecurity'],
      technologies: ['Python', 'Flask', 'Docker', 'SQLite'],
      link: 'https://github.com/username/flask-honeypot',
      featured: false
    },
    {
      id: 3,
      title: 'Cyberpunk Portfolio',
      description: 'A futuristic, cyberpunk-themed portfolio website with interactive elements and holographic UI. Features include 3D elements, glitch effects, and a custom terminal interface.',
      image: '/assets/projects/portfolio.jpg',
      categories: ['web dev'],
      technologies: ['React', 'Three.js', 'CSS3', 'Framer Motion'],
      link: 'https://github.com/username/cyberpunk-portfolio',
      featured: false
    },
    {
      id: 4,
      title: 'AngelaCLI',
      description: 'An AI-powered command line tool that assists with coding tasks. Integrates with your development workflow to provide context-aware suggestions, refactoring tips, and code generation.',
      image: '/assets/projects/angela-cli.jpg',
      categories: ['ai'],
      technologies: ['Python', 'OpenAI API', 'TensorFlow', 'Click'],
      link: 'https://github.com/username/angela-cli',
      featured: false
    },
    // Blog placeholders
    {
      id: 5,
      title: 'Understanding Zero Trust Architecture',
      description: 'An in-depth exploration of Zero Trust security principles and implementation strategies for modern organizations. Learn how to implement "never trust, always verify" in your infrastructure.',
      image: '/assets/blogs/zerotrust.jpg',
      categories: ['blogs', 'cybersecurity'],
      date: 'April 15, 2025',
      link: '/blog/zero-trust',
      featured: false,
      isBlog: true
    },
    {
      id: 6,
      title: 'The Future of Web Development in 2025',
      description: 'Exploring emerging web technologies and development paradigms that will shape the industry in the coming year. From WebAssembly to Edge Computing and AI-assisted coding.',
      image: '/assets/blogs/webdev2025.jpg',
      categories: ['blogs', 'web dev'],
      date: 'March 22, 2025',
      link: '/blog/web-development-trends',
      featured: false,
      isBlog: true
    },
    {
      id: 7,
      title: 'Practical Applications of LLMs in Education',
      description: 'How Large Language Models are transforming educational methodologies and creating new opportunities for personalized learning experiences. Case studies and implementation strategies.',
      image: '/assets/blogs/ai-education.jpg',
      categories: ['blogs', 'ai', 'education'],
      date: 'February 8, 2025',
      link: '/blog/llms-education',
      featured: false,
      isBlog: true
    }
  ];
  
  // Category filters - updated as requested
  const categories = [
    { id: 'all', name: 'ALL' },
    { id: 'cybersecurity', name: 'CYBERSECURITY' },
    { id: 'web dev', name: 'WEB DEV' },
    { id: 'ai', name: 'AI' },
    { id: 'education', name: 'EDUCATION' },
    { id: 'blogs', name: 'BLOGS' }
  ];
  
  // Filter projects based on active filter
  useEffect(() => {
    if (activeFilter === 'all') {
      setFilteredProjects(projects);
    } else {
      const filtered = projects.filter(project => 
        project.categories.includes(activeFilter)
      );
      setFilteredProjects(filtered);
    }
  }, [activeFilter]);
  
  // Handle filter click
  const handleFilterClick = (categoryId) => {
    setActiveFilter(categoryId);
    playSound('click');
  };
  
  // Handle mouse movement for mild parallax effect (simplified to reduce glitchiness)
  useEffect(() => {
    const handleMouseMove = (e) => {
      if (!projectsContainerRef.current) return;
      
      const rect = projectsContainerRef.current.getBoundingClientRect();
      
      setMousePosition({
        x: ((e.clientX - rect.left) / rect.width - 0.5) * 0.5, // Reduced factor to minimize effect
        y: ((e.clientY - rect.top) / rect.height - 0.5) * 0.5  // Reduced factor to minimize effect
      });
    };
    
    const projectsContainer = projectsContainerRef.current;
    
    if (projectsContainer) {
      projectsContainer.addEventListener('mousemove', handleMouseMove);
    }
    
    return () => {
      if (projectsContainer) {
        projectsContainer.removeEventListener('mousemove', handleMouseMove);
      }
    };
  }, []);
  
  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };
  
  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { type: 'spring', stiffness: 50, damping: 10 } // More stable animation
    }
  };
  
  return (
    <section className={`projects-section ${fullPage ? 'full-page' : ''}`} id="projects">
      <div className="projects-background"></div>
      
      <div className="container">
        {!fullPage && (
          <motion.h2 
            className="section-title"
            initial={{ opacity: 0, y: -20 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true, margin: "-100px" }}
            transition={{ duration: 0.5 }}
          >
            Featured Projects
          </motion.h2>
        )}
        
        {fullPage && (
          <motion.h1 
            className="page-title"
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            Project Portfolio
          </motion.h1>
        )}
        
        <motion.div 
          className="filter-container"
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true, margin: "-100px" }}
          transition={{ duration: 0.5, delay: 0.1 }}
        >
          <div className="filter-label">FILTER:</div>
          <div className="filter-options">
            {categories.map((category) => (
              <button
                key={category.id}
                className={`filter-option ${activeFilter === category.id ? 'active' : ''}`}
                onClick={() => handleFilterClick(category.id)}
              >
                {category.name}
              </button>
            ))}
          </div>
        </motion.div>
        
        <motion.div 
          className="projects-grid"
          ref={projectsContainerRef}
          variants={containerVariants}
          initial="hidden"
          whileInView="visible"
          viewport={{ once: true, margin: "-100px" }}
        >
          {filteredProjects.map((project) => (
            <motion.div 
              key={project.id}
              className={`project-card ${
                hoveredProject === project.id ? 'hovered' : ''
              } ${project.featured ? 'featured' : ''} ${project.isBlog ? 'blog-card' : ''}`}
              variants={itemVariants}
              onMouseEnter={() => {
                setHoveredProject(project.id);
                playSound('hover');
              }}
              onMouseLeave={() => setHoveredProject(null)}
              style={{
                transform: hoveredProject === project.id
                  ? `translateY(-8px)`
                  : 'translateY(0)'
              }}
            >
              <div className="project-image-container">
                <div className="project-image-overlay"></div>
                <img 
                  src={project.image || `/assets/projects/default.jpg`} 
                  alt={project.title} 
                  className="project-image"
                  loading="lazy"
                />
                
                {project.featured && (
                  <div className="featured-badge">FEATURED</div>
                )}
                
                {project.isBlog && (
                  <div className="blog-badge">BLOG</div>
                )}
              </div>
              
              <div className="project-content">
                <h3 className="project-title">{project.title}</h3>
                
                <div className="project-categories">
                  {project.categories.map((category, idx) => (
                    <span key={idx} className="project-category">
                      {categories.find(c => c.id === category)?.name || category}
                    </span>
                  ))}
                </div>
                
                {project.isBlog && (
                  <div className="blog-date">{project.date}</div>
                )}
                
                <p className="project-description">{project.description}</p>
                
                {!project.isBlog && (
                  <div className="project-technologies">
                    {project.technologies.map((tech, idx) => (
                      <span key={idx} className="project-technology">
                        {tech}
                      </span>
                    ))}
                  </div>
                )}
                
                <div className="project-links">
                  <a 
                    href={project.link} 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="cyber-button cyber-button--small"
                    onClick={() => playSound('click')}
                  >
                    {project.isBlog ? 'READ POST' : 'VIEW PROJECT'}
                  </a>
                </div>
              </div>
            </motion.div>
          ))}
        </motion.div>
        
        {!fullPage && filteredProjects.length > 0 && (
          <motion.div 
            className="view-all-container"
            initial={{ opacity: 0, y: 20 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true, margin: "-100px" }}
            transition={{ duration: 0.5, delay: 0.3 }}
          >
            <Link 
              to="/projects" 
              className="cyber-button"
              onClick={() => playSound('click')}
            >
              VIEW ALL PROJECTS
            </Link>
          </motion.div>
        )}
        
        {filteredProjects.length === 0 && (
          <motion.div 
            className="no-projects"
            initial={{ opacity: 0, y: 20 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true, margin: "-100px" }}
            transition={{ duration: 0.5 }}
          >
            <div className="no-projects-message">
              <div className="no-projects-icon">!</div>
              <h3>NO PROJECTS FOUND</h3>
              <p>Try selecting a different category filter.</p>
            </div>
          </motion.div>
        )}
      </div>
      
      <style jsx>{`
        .projects-section {
          position: relative;
          padding: var(--space-xxl) 0;
          min-height: ${fullPage ? '100vh' : 'auto'};
          display: flex;
          flex-direction: column;
          justify-content: center;
        }
        
        .projects-section.full-page {
          padding-top: calc(var(--header-height) + var(--space-xxl));
        }
        
        .projects-background {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: -1;
          background-color: rgba(5, 5, 5, 0.3);
        }
        
        .section-title,
        .page-title {
          text-align: center;
          margin-bottom: var(--space-xl);
          color: var(--accent-cyan);
          position: relative;
          display: inline-block;
          width: 100%;
        }
        
        .page-title {
          font-size: 3rem;
        }
        
        .section-title::after,
        .page-title::after {
          content: '';
          position: absolute;
          bottom: -10px;
          left: 50%;
          transform: translateX(-50%);
          width: 100px;
          height: 3px;
          background: linear-gradient(
            90deg,
            transparent,
            var(--accent-cyan),
            transparent
          );
        }
        
        .filter-container {
          display: flex;
          flex-wrap: wrap;
          align-items: center;
          justify-content: center;
          margin-bottom: var(--space-xl);
          gap: var(--space-sm);
        }
        
        .filter-label {
          font-family: var(--font-mono);
          color: var(--text-secondary);
          margin-right: var(--space-sm);
        }
        
        .filter-options {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
          justify-content: center;
        }
        
        .filter-option {
          padding: var(--space-xs) var(--space-sm);
          background-color: rgba(10, 10, 10, 0.5);
          border: 1px solid var(--border-primary);
          border-radius: var(--border-radius-sm);
          color: var(--text-secondary);
          font-family: var(--font-mono);
          font-size: 0.8rem;
          transition: all var(--transition-normal);
          cursor: none;
        }
        
        .filter-option:hover {
          color: var(--accent-cyan);
          border-color: var(--accent-cyan);
          background-color: rgba(0, 255, 245, 0.1);
          transform: translateY(-2px);
        }
        
        .filter-option.active {
          color: var(--bg-primary);
          background-color: var(--accent-cyan);
          border-color: var(--accent-cyan);
          box-shadow: 0 0 10px rgba(0, 255, 245, 0.3);
        }
        
        .projects-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
          gap: var(--space-xl);
          margin-bottom: var(--space-xl);
        }
        
        .project-card {
          position: relative;
          background-color: rgba(10, 10, 10, 0.7);
          border-radius: var(--border-radius-md);
          overflow: hidden;
          border: 1px solid var(--border-primary);
          transition: all 0.3s ease;
          height: 100%;
          display: flex;
          flex-direction: column;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .project-card.hovered {
          border-color: var(--accent-cyan);
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3), 0 0 15px rgba(0, 255, 245, 0.2);
        }
        
        .project-card.featured {
          grid-column: span 2;
        }
        
        .project-card.blog-card {
          border-color: var(--accent-magenta);
        }
        
        .project-card.blog-card.hovered {
          border-color: var(--accent-magenta);
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3), 0 0 15px rgba(255, 61, 61, 0.2);
        }
        
        .project-image-container {
          position: relative;
          height: 200px;
          overflow: hidden;
        }
        
        .project-image {
          width: 100%;
          height: 100%;
          object-fit: cover;
          transition: transform 0.5s ease;
        }
        
        .project-card.hovered .project-image {
          transform: scale(1.05);
        }
        
        .project-image-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient(
            to bottom,
            transparent 50%,
            rgba(10, 10, 10, 0.8) 100%
          );
          z-index: 1;
        }
        
        .featured-badge {
          position: absolute;
          top: var(--space-sm);
          right: var(--space-sm);
          background-color: var(--accent-cyan);
          color: var(--bg-primary);
          font-family: var(--font-mono);
          font-size: 0.7rem;
          padding: 4px 8px;
          border-radius: var(--border-radius-sm);
          z-index: 2;
          font-weight: bold;
        }
        
        .blog-badge {
          position: absolute;
          top: var(--space-sm);
          right: var(--space-sm);
          background-color: var(--accent-magenta);
          color: var(--bg-primary);
          font-family: var(--font-mono);
          font-size: 0.7rem;
          padding: 4px 8px;
          border-radius: var(--border-radius-sm);
          z-index: 2;
          font-weight: bold;
        }
        
        .project-content {
          padding: var(--space-lg);
          flex: 1;
          display: flex;
          flex-direction: column;
        }
        
        .project-title {
          font-size: 1.5rem;
          margin-bottom: var(--space-sm);
          color: var(--accent-cyan);
        }
        
        .blog-card .project-title {
          color: var(--accent-magenta);
        }
        
        .project-categories {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
          margin-bottom: var(--space-sm);
        }
        
        .project-category {
          font-size: 0.7rem;
          color: var(--text-tertiary);
          background-color: rgba(255, 255, 255, 0.1);
          padding: 2px 6px;
          border-radius: var(--border-radius-sm);
          font-family: var(--font-mono);
        }
        
        .blog-date {
          font-size: 0.8rem;
          color: var(--accent-magenta);
          font-family: var(--font-mono);
          margin-bottom: var(--space-sm);
        }
        
        .project-description {
          margin-bottom: var(--space-md);
          color: var(--text-secondary);
          font-size: 0.9rem;
          line-height: 1.5;
          flex: 1;
        }
        
        .project-technologies {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
          margin-bottom: var(--space-md);
        }
        
        .project-technology {
          font-size: 0.8rem;
          color: var(--accent-cyan);
          border: 1px solid var(--accent-cyan);
          padding: 2px 8px;
          border-radius: var(--border-radius-sm);
          font-family: var(--font-mono);
        }
        
        .blog-card .project-technology {
          color: var(--accent-magenta);
          border-color: var(--accent-magenta);
        }
        
        .project-links {
          display: flex;
          justify-content: flex-end;
        }
        
        /* Better hover effect - replacing the corner element */
        .project-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 3px;
          background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
          transform: scaleX(0);
          transform-origin: left;
          transition: transform 0.5s ease;
        }
        
        .project-card.hovered::before {
          transform: scaleX(1);
        }
        
        .project-card.blog-card::before {
          background: linear-gradient(90deg, transparent, var(--accent-magenta), transparent);
        }
        
        .view-all-container {
          display: flex;
          justify-content: center;
          margin-top: var(--space-xl);
        }
        
        .no-projects {
          display: flex;
          justify-content: center;
          align-items: center;
          min-height: 300px;
        }
        
        .no-projects-message {
          text-align: center;
          padding: var(--space-xl);
          background-color: rgba(10, 10, 10, 0.7);
          border: 1px solid var(--border-primary);
          border-radius: var(--border-radius-md);
          max-width: 400px;
        }
        
        .no-projects-icon {
          display: flex;
          justify-content: center;
          align-items: center;
          width: 60px;
          height: 60px;
          margin: 0 auto var(--space-md);
          background-color: rgba(255, 61, 61, 0.2);
          border: 2px solid var(--accent-magenta);
          border-radius: 50%;
          font-size: 2rem;
          font-weight: 700;
          color: var(--accent-magenta);
        }
        
        /* Light theme styles */
        .light-theme .project-card {
          background-color: rgba(245, 245, 245, 0.8);
        }
        
        .light-theme .project-image-overlay {
          background: linear-gradient(
            to bottom,
            transparent 50%,
            rgba(245, 245, 245, 0.8) 100%
          );
        }
        
        .light-theme .project-card.hovered {
          border-color: var(--accent-blue);
          box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1), 0 0 15px rgba(77, 77, 255, 0.2);
        }
        
        .light-theme .project-card::before {
          background: linear-gradient(90deg, transparent, var(--accent-blue), transparent);
        }
        
        .light-theme .project-technology {
          color: var(--accent-blue);
          border-color: var(--accent-blue);
        }
        
        .light-theme .filter-option:hover {
          color: var(--accent-blue);
          border-color: var(--accent-blue);
          background-color: rgba(77, 77, 255, 0.1);
        }
        
        .light-theme .filter-option.active {
          color: #fff;
          background-color: var(--accent-blue);
          border-color: var(--accent-blue);
          box-shadow: 0 0 10px rgba(77, 77, 255, 0.3);
        }
        
        /* Media queries */
        @media (max-width: 1200px) {
          .project-card.featured {
            grid-column: span 1;
          }
        }
        
        @media (max-width: 768px) {
          .projects-grid {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-lg);
          }
          
          .filter-container {
            flex-direction: column;
            gap: var(--space-xs);
          }
          
          .filter-options {
            width: 100%;
            justify-content: center;
          }
          
          .project-content {
            padding: var(--space-md);
          }
          
          .project-title {
            font-size: 1.3rem;
          }
        }
        
        @media (max-width: 480px) {
          .projects-grid {
            grid-template-columns: 1fr;
          }
          
          .filter-option {
            font-size: 0.7rem;
            padding: 4px 6px;
          }
          
          .page-title {
            font-size: 2.2rem;
          }
        }
      `}</style>
    </section>
  );
};

export default ProjectsGrid;
</file>

<file path="frontend/src/components/sections/ResumeHologram.jsx">
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';
import { useAudio } from '../../contexts/AudioContext';

// Resume sections data
const RESUME_SECTIONS = [
  {
    id: 'profile',
    title: 'Profile',
    icon: 'ðŸ‘¤',
    content: `Dedicated System Integration Technician with strong cybersecurity expertise. Proven ability to build, configure, and optimize custom security systems. Holds seven CompTIA certifications and pursuing a master's degree in Cybersecurity. Combines technical knowledge with practical skills to deliver reliable, secure solutions.`
  },
  {
    id: 'experience',
    title: 'Experience',
    icon: 'ðŸ’¼',
    content: [
      {
        title: 'System Integration Technician II',
        company: 'Sealing Technologies',
        location: 'Annapolis, MD',
        duration: '2024 - Present',
        responsibilities: [
          'Build and configure custom cybersecurity and defense systems',
          'Ensure systems meet client specifications and reliability standards',
          'Perform quality assurance and optimization testing',
          'Collaborate with cross-functional teams to deliver comprehensive solutions',
          'Document build processes and system configurations'
        ]
      },
      {
        title: 'General Manager',
        company: "Jimmy John's",
        location: 'Severna Park, MD',
        duration: '2022 - 2024',
        responsibilities: [
          'Managed daily operations and supervised staff',
          'Ensured efficient workflows and high customer satisfaction',
          'Maintained network and POS systems functionality',
          'Implemented new inventory procedures to reduce waste',
          'Diagnosed and resolved technical issues'
        ]
      },
      {
        title: 'General Manager',
        company: "Jimmy John's",
        location: 'Annapolis, MD',
        duration: '2022 - 2022',
        responsibilities: [
          'Diagnosed network & POS issues',
          'Oversaw staff scheduling and training',
          'Ensured compliance with company standards',
          'Optimized operational workflows'
        ]
      }
    ]
  },
  {
    id: 'education',
    title: 'Education',
    icon: 'ðŸŽ“',
    content: [
      {
        degree: "Master's Degree in Cybersecurity",
        institution: 'University of Maryland Global Campus',
        duration: '2024 - Present',
        details: [
          'Focus on advanced security protocols and threat intelligence',
          'GPA: 3.9',
          'Expected graduation: 2026'
        ]
      },
      {
        degree: "Associate's Degree in Cybersecurity",
        institution: 'Anne Arundel Community College',
        duration: '2022 - 2024',
        details: [
          'Graduated with honors (3.8 GPA)',
          'Focus on network security and ethical hacking',
          'Participated in capture-the-flag competitions'
        ]
      },
      {
        degree: 'High School Diploma',
        institution: 'South River High School',
        duration: '2018 - 2022',
        details: [
          'Focus on science and mathematics',
          'Participated in STEM-related extracurriculars'
        ]
      }
    ]
  },
  {
    id: 'skills',
    title: 'Technical Skills',
    icon: 'ðŸ’»',
    content: {
      categories: [
        {
          name: 'Cybersecurity',
          skills: [
            'Risk Assessment',
            'Threat Mitigation',
            'Compliance (ISO 27001, 9001:2015)',
            'Role-Based Access Controls',
            'Encryption Best Practices',
            'Incident Response Planning'
          ]
        },
        {
          name: 'Development',
          skills: [
            'Python',
            'JavaScript',
            'HTML/CSS',
            'Shell Scripting',
            'React',
            'Flask',
            'MongoDB',
            'Docker'
          ]
        },
        {
          name: 'Networking',
          skills: [
            'TCP/IP',
            'DNS/DHCP',
            'Firewalls (UFW, iptables)',
            'Secure Network Configurations',
            'SSH Encryption',
            'VPNs'
          ]
        },
        {
          name: 'Cloud & DevOps',
          skills: [
            'AWS Security (EC2, S3, WAF, Shield)',
            'CI/CD Pipelines',
            'Containerization',
            'Infrastructure as Code',
            'Web Servers (Nginx, Apache)'
          ]
        }
      ]
    }
  },
  {
    id: 'certifications',
    title: 'Certifications',
    icon: 'ðŸ†',
    content: [
      {
        name: 'CompTIA A+',
        issuer: 'CompTIA',
        date: 'April 2024'
      },
      {
        name: 'CompTIA Network+',
        issuer: 'CompTIA',
        date: 'May 2024'
      },
      {
        name: 'CompTIA Security+',
        issuer: 'CompTIA',
        date: 'May 2024'
      },
      {
        name: 'CompTIA CySA+',
        issuer: 'CompTIA',
        date: 'October 2024'
      },
      {
        name: 'CompTIA PenTest+',
        issuer: 'CompTIA',
        date: 'November 2024'
      },
      {
        name: 'CompTIA CASP+',
        issuer: 'CompTIA',
        date: 'December 2024'
      },
      {
        name: 'PCEP (Certified Entry-Level Python Programmer)',
        issuer: 'Python Institute',
        date: 'June 2024'
      }
    ]
  },
  {
    id: 'projects',
    title: 'Projects',
    icon: 'ðŸš€',
    content: [
      {
        name: 'ProxyAuthRequired.com',
        description: 'A centralized cybersecurity platform integrating AI-driven simulations and learning modules.',
        technologies: ['React', 'Python', 'Flask', 'MongoDB', 'Docker'],
        link: 'https://github.com/username/proxyauthrequired'
      },
      {
        name: 'CertsGamified',
        description: 'A gamified platform for certification preparation with structured learning roadmaps.',
        technologies: ['React', 'Node.js', 'MongoDB', 'Express'],
        link: 'https://github.com/username/certsgamified'
      },
      {
        name: 'AutoApplication',
        description: 'An automated application bot for job sites, streamlining the application process.',
        technologies: ['Python', 'Selenium', 'BeautifulSoup'],
        link: 'https://github.com/username/autoapplication'
      }
    ]
  },
  {
    id: 'contact',
    title: 'Contact',
    icon: 'ðŸ“ž',
    content: {
      email: 'CarterPerez-dev@ProxyAuthRequired.com',
      phone: '443-510-0866',
      location: 'Annapolis, MD',
      github: 'https://github.com/CarterPerez-dev',
      linkedin: 'https://www.linkedin.com/in/carter-perez-ProxyAuthRequired/'
    }
  }
];

const ResumeHologram = () => {
  const { theme } = useTheme();
  const { playSound } = useAudio();
  const canvasRef = useRef(null);
  const [activeSection, setActiveSection] = useState('profile');
  const [showDownloadOptions, setShowDownloadOptions] = useState(false);
  const [isDownloading, setIsDownloading] = useState(false);
  const [downloadProgress, setDownloadProgress] = useState(0);
  
  // Holographic effect animation
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    const setCanvasDimensions = () => {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };
    
    window.addEventListener('resize', setCanvasDimensions);
    setCanvasDimensions();
    
    // Holographic parameters
    const grid = {
      spacing: 25,
      dotSize: 1,
      color: theme === 'dark' ? 'rgba(0, 255, 245, 0.4)' : 'rgba(77, 77, 255, 0.4)'
    };
    
    const particles = [];
    const linesCount = 5;
    
    // Create particles along paths
    const createParticles = () => {
      // Reset particles
      particles.length = 0;
      
      // Create flowing lines
      for (let i = 0; i < linesCount; i++) {
        const startX = Math.random() * canvas.width;
        const startY = Math.random() * canvas.height;
        const length = 100 + Math.random() * 200;
        const angle = Math.random() * Math.PI * 2;
        
        const endX = startX + Math.cos(angle) * length;
        const endY = startY + Math.sin(angle) * length;
        
        // Create particles along the line
        const particleCount = Math.max(5, Math.floor(length / 20));
        
        for (let j = 0; j < particleCount; j++) {
          const t = j / particleCount;
          
          particles.push({
            x: startX + (endX - startX) * t,
            y: startY + (endY - startY) * t,
            size: 2 + Math.random() * 2,
            speed: 0.5 + Math.random() * 1.5,
            color: Math.random() > 0.7 ? 'rgba(255, 61, 61, 0.7)' : grid.color.replace('0.4', '0.7'),
            direction: angle,
            life: 1 + Math.random() * 2
          });
        }
      }
    };
    
    // Draw holographic grid
    const drawGrid = () => {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid dots
      for (let x = 0; x < canvas.width; x += grid.spacing) {
        for (let y = 0; y < canvas.height; y += grid.spacing) {
          const distanceToActiveSection = getDistanceToActiveSection(x, y);
          const alpha = Math.max(0.1, Math.min(0.7, 1 - distanceToActiveSection / 500));
          
          ctx.beginPath();
          ctx.arc(x, y, grid.dotSize, 0, Math.PI * 2);
          ctx.fillStyle = grid.color.replace('0.4', alpha.toFixed(2));
          ctx.fill();
        }
      }
      
      // Update and draw particles
      const updatedParticles = [];
      
      for (const particle of particles) {
        // Update position
        particle.x += Math.cos(particle.direction) * particle.speed;
        particle.y += Math.sin(particle.direction) * particle.speed;
        
        // Update life
        particle.life -= 0.01;
        
        // Keep if still alive
        if (particle.life > 0 && 
            particle.x > 0 && particle.x < canvas.width && 
            particle.y > 0 && particle.y < canvas.height) {
          updatedParticles.push(particle);
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fillStyle = particle.color.replace('0.7', (particle.life * 0.6).toFixed(2));
          ctx.fill();
        }
      }
      
      // Update particles array
      particles.splice(0, particles.length, ...updatedParticles);
      
      // Add new particles if needed
      if (particles.length < linesCount * 5) {
        createParticles();
      }
      
      // Draw highlight around active section
      const activeElement = document.getElementById(`section-${activeSection}`);
      
      if (activeElement) {
        const rect = activeElement.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        
        // Convert rect to canvas coordinates
        const highlightRect = {
          x: rect.left - canvasRect.left,
          y: rect.top - canvasRect.top,
          width: rect.width,
          height: rect.height
        };
        
        // Draw glow effect
        const glowSize = 20;
        
        // Create gradient
        const glow = ctx.createLinearGradient(
          highlightRect.x, 
          highlightRect.y, 
          highlightRect.x + highlightRect.width, 
          highlightRect.y + highlightRect.height
        );
        
        glow.addColorStop(0, theme === 'dark' ? 'rgba(0, 255, 245, 0.1)' : 'rgba(77, 77, 255, 0.1)');
        glow.addColorStop(0.5, theme === 'dark' ? 'rgba(0, 255, 245, 0.2)' : 'rgba(77, 77, 255, 0.2)');
        glow.addColorStop(1, theme === 'dark' ? 'rgba(0, 255, 245, 0.1)' : 'rgba(77, 77, 255, 0.1)');
        
        // Draw rounded rectangle with glow
        roundRect(
          ctx, 
          highlightRect.x - glowSize, 
          highlightRect.y - glowSize, 
          highlightRect.width + glowSize * 2, 
          highlightRect.height + glowSize * 2, 
          10,
          glow
        );
      }
    };
    
    // Helper function to draw rounded rectangle
    const roundRect = (ctx, x, y, width, height, radius, fill) => {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      
      ctx.fillStyle = fill;
      ctx.fill();
    };
    
    // Get distance from point to active section
    const getDistanceToActiveSection = (x, y) => {
      const activeElement = document.getElementById(`section-${activeSection}`);
      
      if (!activeElement) return 500; // Default large distance
      
      const rect = activeElement.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      
      // Convert rect to canvas coordinates
      const sectionRect = {
        x: rect.left - canvasRect.left,
        y: rect.top - canvasRect.top,
        width: rect.width,
        height: rect.height
      };
      
      // Calculate center of section
      const centerX = sectionRect.x + sectionRect.width / 2;
      const centerY = sectionRect.y + sectionRect.height / 2;
      
      // Calculate distance
      return Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
    };
    
    // Initialize particles
    createParticles();
    
    // Animation loop
    let animationId;
    const animate = () => {
      drawGrid();
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Clean up
    return () => {
      window.removeEventListener('resize', setCanvasDimensions);
      cancelAnimationFrame(animationId);
    };
  }, [theme, activeSection]);
  
  // Simulate download progress
  const handleDownload = (format) => {
    setIsDownloading(true);
    setDownloadProgress(0);
    playSound('click');
    
    // Simulating download progress
    const interval = setInterval(() => {
      setDownloadProgress(prev => {
        if (prev >= 100) {
          clearInterval(interval);
          setTimeout(() => {
            setIsDownloading(false);
            setShowDownloadOptions(false);
            
            // In a real implementation, trigger actual download here
            const link = document.createElement('a');
            link.href = '/assets/CarterPerez.pdf';
            link.download = `Carter_Perez_Resume.${format.toLowerCase()}`;
            link.click();
          }, 500);
          return 100;
        }
        return prev + (Math.random() * 5) + 2;
      });
    }, 100);
  };
  
  // Render experience list
  const renderExperienceList = (experiences) => {
    return experiences.map((exp, index) => (
      <div key={index} className="experience-item">
        <div className="experience-header">
          <h3 className="experience-title">{exp.title}</h3>
          <div className="experience-meta">
            <span className="experience-company">{exp.company}</span>
            <span className="experience-separator">|</span>
            <span className="experience-location">{exp.location}</span>
            <span className="experience-separator">|</span>
            <span className="experience-duration">{exp.duration}</span>
          </div>
        </div>
        
        <ul className="experience-responsibilities">
          {exp.responsibilities.map((item, idx) => (
            <li key={idx} className="experience-responsibility-item">{item}</li>
          ))}
        </ul>
      </div>
    ));
  };
  
  // Render education list
  const renderEducationList = (educations) => {
    return educations.map((edu, index) => (
      <div key={index} className="education-item">
        <div className="education-header">
          <h3 className="education-degree">{edu.degree}</h3>
          <div className="education-meta">
            <span className="education-institution">{edu.institution}</span>
            <span className="education-separator">|</span>
            <span className="education-duration">{edu.duration}</span>
          </div>
        </div>
        
        <ul className="education-details">
          {edu.details.map((item, idx) => (
            <li key={idx} className="education-detail-item">{item}</li>
          ))}
        </ul>
      </div>
    ));
  };
  
  // Render skills list
  const renderSkillsList = (skillsData) => {
    return skillsData.categories.map((category, index) => (
      <div key={index} className="skills-category">
        <h3 className="skills-category-name">{category.name}</h3>
        <div className="skills-grid">
          {category.skills.map((skill, idx) => (
            <div key={idx} className="skill-item">{skill}</div>
          ))}
        </div>
      </div>
    ));
  };
  
  // Render certifications list
  const renderCertificationsList = (certifications) => {
    return certifications.map((cert, index) => (
      <div key={index} className="certification-item">
        <div className="certification-name">{cert.name}</div>
        <div className="certification-meta">
          <span className="certification-issuer">{cert.issuer}</span>
          <span className="certification-separator">|</span>
          <span className="certification-date">{cert.date}</span>
        </div>
      </div>
    ));
  };
  
  // Render projects list
  const renderProjectsList = (projects) => {
    return projects.map((project, index) => (
      <div key={index} className="project-item">
        <div className="project-header">
          <h3 className="project-name">{project.name}</h3>
          <a 
            href={project.link} 
            target="_blank" 
            rel="noopener noreferrer"
            className="project-link"
            onClick={() => playSound('click')}
          >
            View
          </a>
        </div>
        
        <p className="project-description">{project.description}</p>
        
        <div className="project-technologies">
          {project.technologies.map((tech, idx) => (
            <span key={idx} className="project-technology">{tech}</span>
          ))}
        </div>
      </div>
    ));
  };
  
  // Render contact information
  const renderContactInfo = (contact) => {
    return (
      <div className="contact-info">
        <div className="contact-item">
          <div className="contact-label">Email</div>
          <div className="contact-value">
            <a 
              href={`mailto:${contact.email}`} 
              className="contact-link"
              onClick={() => playSound('click')}
            >
              {contact.email}
            </a>
          </div>
        </div>
        
        <div className="contact-item">
          <div className="contact-label">Phone</div>
          <div className="contact-value">
            <a 
              href={`tel:${contact.phone}`} 
              className="contact-link"
              onClick={() => playSound('click')}
            >
              {contact.phone}
            </a>
          </div>
        </div>
        
        <div className="contact-item">
          <div className="contact-label">Location</div>
          <div className="contact-value">{contact.location}</div>
        </div>
        
        <div className="contact-item">
          <div className="contact-label">Profiles</div>
          <div className="contact-social">
            <a 
              href={contact.github} 
              target="_blank" 
              rel="noopener noreferrer" 
              className="contact-social-link"
              onClick={() => playSound('click')}
            >
              GitHub
            </a>
            <a 
              href={contact.linkedin} 
              target="_blank" 
              rel="noopener noreferrer" 
              className="contact-social-link"
              onClick={() => playSound('click')}
            >
              LinkedIn
            </a>
          </div>
        </div>
      </div>
    );
  };
  
  // Render section content based on activeSection
  const renderSectionContent = () => {
    const section = RESUME_SECTIONS.find(s => s.id === activeSection);
    
    if (!section) {
      return <div>Section not found</div>;
    }
    
    switch (section.id) {
      case 'profile':
        return <p className="section-text">{section.content}</p>;
      case 'experience':
        return renderExperienceList(section.content);
      case 'education':
        return renderEducationList(section.content);
      case 'skills':
        return renderSkillsList(section.content);
      case 'certifications':
        return renderCertificationsList(section.content);
      case 'projects':
        return renderProjectsList(section.content);
      case 'contact':
        return renderContactInfo(section.content);
      default:
        return <div>Content not available</div>;
    }
  };
  
  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1
      }
    }
  };
  
  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { type: 'spring', stiffness: 100 }
    }
  };
  
  return (
    <section className="resume-section" id="resume">
      <div className="container">
        <motion.h1 
          className="page-title"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          Neural RÃ©sumÃ© Interface
        </motion.h1>
        
        <motion.div 
          className="resume-container"
          variants={containerVariants}
          initial="hidden"
          animate="visible"
        >
          <canvas 
            ref={canvasRef} 
            className="resume-canvas"
            aria-hidden="true"
          ></canvas>
          
          <div className="resume-content">
            <div className="resume-header">
              <motion.div 
                className="resume-identity"
                variants={itemVariants}
              >
                <h2 className="resume-name">Carter Rush Perez</h2>
                <div className="resume-title">System Integration Technician & Cybersecurity Specialist</div>
              </motion.div>
              
              <motion.div 
                className="resume-actions"
                variants={itemVariants}
              >
                <button 
                  className="download-button"
                  onClick={() => {
                    setShowDownloadOptions(!showDownloadOptions);
                    playSound('click');
                  }}
                  disabled={isDownloading}
                >
                  {isDownloading ? (
                    <span className="download-progress">
                      <span className="progress-text">DOWNLOADING</span>
                      <span 
                        className="progress-bar" 
                        style={{ width: `${downloadProgress}%` }}
                      ></span>
                    </span>
                  ) : (
                    <span className="button-text">DOWNLOAD RÃ‰SUMÃ‰</span>
                  )}
                </button>
                
                {showDownloadOptions && !isDownloading && (
                  <div className="download-options">
                    <button 
                      className="download-option"
                      onClick={() => handleDownload('PDF')}
                    >
                      PDF Format
                    </button>
                    <button 
                      className="download-option"
                      onClick={() => handleDownload('DOCX')}
                    >
                      DOCX Format
                    </button>
                    <button 
                      className="download-option"
                      onClick={() => handleDownload('TXT')}
                    >
                      TXT Format
                    </button>
                  </div>
                )}
              </motion.div>
            </div>
            
            <div className="resume-body">
              <motion.div 
                className="resume-nav"
                variants={itemVariants}
              >
                <div className="nav-title">SECTIONS</div>
                {RESUME_SECTIONS.map((section) => (
                  <button 
                    key={section.id}
                    className={`nav-item ${activeSection === section.id ? 'active' : ''}`}
                    onClick={() => {
                      setActiveSection(section.id);
                      playSound('click');
                    }}
                  >
                    <span className="nav-icon">{section.icon}</span>
                    <span className="nav-label">{section.title}</span>
                  </button>
                ))}
              </motion.div>
              
              <motion.div 
                className="resume-section-content"
                variants={itemVariants}
                id={`section-${activeSection}`}
              >
                <div className="section-header">
                  <h2 className="section-title">
                    <span className="section-icon">
                      {RESUME_SECTIONS.find(s => s.id === activeSection)?.icon}
                    </span>
                    <span>{RESUME_SECTIONS.find(s => s.id === activeSection)?.title}</span>
                  </h2>
                </div>
                
                <div className="section-body">
                  {renderSectionContent()}
                </div>
              </motion.div>
            </div>
          </div>
        </motion.div>
      </div>
      
      <style jsx>{`
        .resume-section {
          padding: var(--space-xxl) 0;
          position: relative;
          min-height: 100vh;
          display: flex;
          align-items: center;
        }
        
        .page-title {
          text-align: center;
          margin-bottom: var(--space-xl);
          color: var(--accent-cyan);
          font-size: 3rem;
          position: relative;
        }
        
        .page-title::after {
          content: '';
          position: absolute;
          bottom: -10px;
          left: 50%;
          transform: translateX(-50%);
          width: 100px;
          height: 3px;
          background: linear-gradient(
            90deg,
            transparent,
            var(--accent-cyan),
            transparent
          );
        }
        
        .resume-container {
          position: relative;
          width: 100%;
          min-height: 600px;
          box-shadow: 0 0 50px rgba(0, 0, 0, 0.3);
          border-radius: var(--border-radius-lg);
          overflow: hidden;
        }
        
        .resume-canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 0;
          pointer-events: none;
        }
        
        .resume-content {
          position: relative;
          z-index: 1;
          display: flex;
          flex-direction: column;
          width: 100%;
          min-height: 600px;
        }
        
        .resume-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: var(--space-lg);
          background-color: rgba(10, 10, 10, 0.75);
          border-bottom: 1px solid var(--accent-cyan);
          backdrop-filter: blur(5px);
        }
        
        .resume-identity {
          flex: 1;
        }
        
        .resume-name {
          font-size: 1.8rem;
          color: var(--accent-cyan);
          margin-bottom: var(--space-xs);
        }
        
        .resume-title {
          color: var(--text-secondary);
          font-size: 1.1rem;
        }
        
        .resume-actions {
          position: relative;
        }
        
        .download-button {
          padding: var(--space-sm) var(--space-lg);
          background-color: rgba(0, 255, 245, 0.1);
          border: 1px solid var(--accent-cyan);
          border-radius: var(--border-radius-sm);
          color: var(--accent-cyan);
          font-family: var(--font-mono);
          font-size: 0.9rem;
          letter-spacing: 1px;
          transition: all var(--transition-normal);
          cursor: none;
          position: relative;
          overflow: hidden;
          min-width: 180px;
        }
        
        .download-button::before {
          content: '';
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(
            90deg,
            transparent,
            rgba(0, 255, 245, 0.2),
            transparent
          );
          transition: left 0.5s ease;
        }
        
        .download-button:hover {
          background-color: rgba(0, 255, 245, 0.2);
          transform: translateY(-2px);
        }
        
        .download-button:hover::before {
          left: 100%;
        }
        
        .download-button:disabled {
          opacity: 0.7;
          cursor: not-allowed;
        }
        
        .download-progress {
          display: flex;
          flex-direction: column;
          width: 100%;
          gap: var(--space-xs);
        }
        
        .progress-text {
          font-size: 0.8rem;
        }
        
        .progress-bar {
          height: 3px;
          background-color: var(--accent-cyan);
          width: 0%;
          transition: width 0.2s ease-out;
        }
        
        .download-options {
          position: absolute;
          top: 100%;
          right: 0;
          margin-top: var(--space-xs);
          background-color: rgba(10, 10, 10, 0.9);
          border: 1px solid var(--accent-cyan);
          border-radius: var(--border-radius-sm);
          padding: var(--space-xs);
          display: flex;
          flex-direction: column;
          gap: var(--space-xs);
          min-width: 150px;
          z-index: var(--z-dropdown);
          backdrop-filter: blur(5px);
        }
        
        .download-option {
          padding: var(--space-xs) var(--space-sm);
          background-color: transparent;
          border: none;
          color: var(--text-primary);
          text-align: left;
          font-family: var(--font-mono);
          font-size: 0.8rem;
          transition: all var(--transition-fast);
          cursor: none;
        }
        
        .download-option:hover {
          background-color: rgba(0, 255, 245, 0.1);
          color: var(--accent-cyan);
        }
        
        .resume-body {
          display: flex;
          flex: 1;
        }
        
        .resume-nav {
          width: 250px;
          padding: var(--space-md);
          background-color: rgba(10, 10, 10, 0.75);
          border-right: 1px solid var(--accent-cyan);
          display: flex;
          flex-direction: column;
          backdrop-filter: blur(5px);
        }
        
        .nav-title {
          font-family: var(--font-mono);
          font-size: 0.8rem;
          color: var(--text-secondary);
          margin-bottom: var(--space-md);
          padding-bottom: var(--space-sm);
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .nav-item {
          display: flex;
          align-items: center;
          gap: var(--space-sm);
          padding: var(--space-sm);
          border-radius: var(--border-radius-sm);
          color: var(--text-secondary);
          background-color: transparent;
          border: none;
          font-family: var(--font-body);
          font-size: 1rem;
          text-align: left;
          transition: all var(--transition-normal);
          margin-bottom: var(--space-xs);
          cursor: none;
        }
        
        .nav-item:hover {
          background-color: rgba(255, 255, 255, 0.05);
          color: var(--text-primary);
        }
        
        .nav-item.active {
          background-color: rgba(0, 255, 245, 0.1);
          color: var(--accent-cyan);
        }
        
        .nav-icon {
          font-size: 1.2rem;
          min-width: 20px;
          text-align: center;
        }
        
        .resume-section-content {
          flex: 1;
          padding: var(--space-lg);
          background-color: rgba(10, 10, 10, 0.75);
          overflow-y: auto;
          backdrop-filter: blur(5px);
        }
        
        .resume-section-content::-webkit-scrollbar {
          width: 6px;
        }
        
        .resume-section-content::-webkit-scrollbar-track {
          background: rgba(0, 0, 0, 0.2);
          border-radius: 3px;
        }
        
        .resume-section-content::-webkit-scrollbar-thumb {
          background: var(--accent-cyan);
          border-radius: 3px;
        }
        
        .section-header {
          margin-bottom: var(--space-lg);
          padding-bottom: var(--space-sm);
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .section-title {
          display: flex;
          align-items: center;
          font-size: 1.5rem;
          color: var(--accent-cyan);
          gap: var(--space-sm);
        }
        
        .section-icon {
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          background-color: rgba(0, 255, 245, 0.1);
          border-radius: 50%;
          font-size: 1.2rem;
        }
        
        .section-text {
          color: var(--text-secondary);
          line-height: 1.6;
          font-size: 1.1rem;
        }
        
        /* Experience styling */
        .experience-item {
          margin-bottom: var(--space-lg);
          padding-bottom: var(--space-md);
          border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .experience-item:last-child {
          border-bottom: none;
          margin-bottom: 0;
          padding-bottom: 0;
        }
        
        .experience-header {
          margin-bottom: var(--space-sm);
        }
        
        .experience-title {
          font-size: 1.2rem;
          color: var(--text-primary);
          margin-bottom: var(--space-xs);
        }
        
        .experience-meta {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
          color: var(--text-secondary);
          font-size: 0.9rem;
        }
        
        .experience-company {
          color: var(--accent-magenta);
        }
        
        .experience-separator {
          color: var(--text-tertiary);
        }
        
        .experience-responsibilities {
          list-style-type: none;
          padding-left: var(--space-md);
        }
        
        .experience-responsibility-item {
          position: relative;
          color: var(--text-secondary);
          margin-bottom: var(--space-xs);
        }
        
        .experience-responsibility-item::before {
          content: 'â–¹';
          position: absolute;
          left: calc(-1 * var(--space-md));
          color: var(--accent-cyan);
        }
        
        /* Education styling */
        .education-item {
          margin-bottom: var(--space-lg);
          padding-bottom: var(--space-md);
          border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .education-item:last-child {
          border-bottom: none;
          margin-bottom: 0;
          padding-bottom: 0;
        }
        
        .education-header {
          margin-bottom: var(--space-sm);
        }
        
        .education-degree {
          font-size: 1.2rem;
          color: var(--text-primary);
          margin-bottom: var(--space-xs);
        }
        
        .education-meta {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
          color: var(--text-secondary);
          font-size: 0.9rem;
        }
        
        .education-institution {
          color: var(--accent-magenta);
        }
        
        .education-separator {
          color: var(--text-tertiary);
        }
        
        .education-details {
          list-style-type: none;
          padding-left: var(--space-md);
        }
        
        .education-detail-item {
          position: relative;
          color: var(--text-secondary);
          margin-bottom: var(--space-xs);
        }
        
        .education-detail-item::before {
          content: 'â–¹';
          position: absolute;
          left: calc(-1 * var(--space-md));
          color: var(--accent-cyan);
        }
        
        /* Skills styling */
        .skills-category {
          margin-bottom: var(--space-lg);
        }
        
        .skills-category:last-child {
          margin-bottom: 0;
        }
        
        .skills-category-name {
          font-size: 1.2rem;
          color: var(--accent-magenta);
          margin-bottom: var(--space-sm);
          position: relative;
          display: inline-block;
        }
        
        .skills-category-name::after {
          content: '';
          position: absolute;
          bottom: -3px;
          left: 0;
          width: 100%;
          height: 1px;
          background-color: var(--accent-magenta);
          opacity: 0.5;
        }
        
        .skills-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
          gap: var(--space-sm);
        }
        
        .skill-item {
          padding: var(--space-xs) var(--space-sm);
          background-color: rgba(255, 255, 255, 0.05);
          border-radius: var(--border-radius-sm);
          color: var(--text-secondary);
          font-size: 0.9rem;
        }
        
        /* Certifications styling */
        .certification-item {
          margin-bottom: var(--space-md);
          padding: var(--space-sm);
          border-left: 2px solid var(--accent-cyan);
          background-color: rgba(255, 255, 255, 0.03);
        }
        
        .certification-name {
          font-size: 1.1rem;
          color: var(--text-primary);
          margin-bottom: var(--space-xs);
        }
        
        .certification-meta {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
          color: var(--text-secondary);
          font-size: 0.9rem;
        }
        
        .certification-issuer {
          color: var(--accent-magenta);
        }
        
        .certification-separator {
          color: var(--text-tertiary);
        }
        
        /* Projects styling */
        .project-item {
          margin-bottom: var(--space-lg);
          padding: var(--space-md);
          border-radius: var(--border-radius-sm);
          background-color: rgba(255, 255, 255, 0.03);
          border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .project-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: var(--space-sm);
        }
        
        .project-name {
          font-size: 1.2rem;
          color: var(--text-primary);
        }
        
        .project-link {
          padding: 2px 10px;
          background-color: rgba(0, 255, 245, 0.1);
          border-radius: var(--border-radius-sm);
          color: var(--accent-cyan);
          font-family: var(--font-mono);
          font-size: 0.8rem;
          transition: all var(--transition-normal);
        }
        
        .project-link:hover {
          background-color: var(--accent-cyan);
          color: var(--bg-primary);
        }
        
        .project-description {
          color: var(--text-secondary);
          margin-bottom: var(--space-sm);
          line-height: 1.5;
        }
        
        .project-technologies {
          display: flex;
          flex-wrap: wrap;
          gap: var(--space-xs);
        }
        
        .project-technology {
          padding: 2px 8px;
          background-color: rgba(255, 255, 255, 0.05);
          border-radius: var(--border-radius-sm);
          color: var(--accent-cyan);
          font-family: var(--font-mono);
          font-size: 0.8rem;
        }
        
        /* Contact styling */
        .contact-info {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
          gap: var(--space-lg);
        }
        
        .contact-item {
          display: flex;
          flex-direction: column;
          gap: var(--space-xs);
        }
        
        .contact-label {
          font-family: var(--font-mono);
          font-size: 0.9rem;
          color: var(--accent-magenta);
        }
        
        .contact-value {
          font-size: 1.1rem;
          color: var(--text-primary);
        }
        
        .contact-link {
          color: var(--accent-cyan);
          transition: all var(--transition-normal);
        }
        
        .contact-link:hover {
          text-decoration: underline;
        }
        
        .contact-social {
          display: flex;
          gap: var(--space-md);
        }
        
        .contact-social-link {
          padding: var(--space-xs) var(--space-sm);
          background-color: rgba(0, 255, 245, 0.1);
          border-radius: var(--border-radius-sm);
          color: var(--accent-cyan);
          font-family: var(--font-mono);
          font-size: 0.9rem;
          transition: all var(--transition-normal);
        }
        
        .contact-social-link:hover {
          background-color: var(--accent-cyan);
          color: var(--bg-primary);
          text-decoration: none;
        }
        
        /* Light theme styles */
        .light-theme .resume-header,
        .light-theme .resume-nav,
        .light-theme .resume-section-content {
          background-color: rgba(245, 245, 245, 0.75);
        }
        
        .light-theme .resume-header {
          border-color: var(--accent-blue);
        }
        
        .light-theme .resume-nav {
          border-color: var(--accent-blue);
        }
        
        .light-theme .resume-name,
        .light-theme .section-title {
          color: var(--accent-blue);
        }
        
        .light-theme .nav-item.active {
          background-color: rgba(77, 77, 255, 0.1);
          color: var(--accent-blue);
        }
        
        .light-theme .section-icon {
          background-color: rgba(77, 77, 255, 0.1);
        }
        
        .light-theme .download-button {
          background-color: rgba(77, 77, 255, 0.1);
          border-color: var(--accent-blue);
          color: var(--accent-blue);
        }
        
        .light-theme .download-button::before {
          background: linear-gradient(
            90deg,
            transparent,
            rgba(77, 77, 255, 0.2),
            transparent
          );
        }
        
        .light-theme .download-button:hover {
          background-color: rgba(77, 77, 255, 0.2);
        }
        
        .light-theme .progress-bar {
          background-color: var(--accent-blue);
        }
        
        .light-theme .download-options {
          background-color: rgba(245, 245, 245, 0.9);
          border-color: var(--accent-blue);
        }
        
        .light-theme .download-option:hover {
          background-color: rgba(77, 77, 255, 0.1);
          color: var(--accent-blue);
        }
        
        .light-theme .resume-section-content::-webkit-scrollbar-thumb {
          background: var(--accent-blue);
        }
        
        .light-theme .experience-responsibility-item::before,
        .light-theme .education-detail-item::before {
          color: var(--accent-blue);
        }
        
        .light-theme .skills-category-name,
        .light-theme .experience-company,
        .light-theme .education-institution,
        .light-theme .certification-issuer,
        .light-theme .contact-label {
          color: var(--accent-blue);
        }
        
        .light-theme .skills-category-name::after {
          background-color: var(--accent-blue);
        }
        
        .light-theme .certification-item {
          border-left-color: var(--accent-blue);
        }
        
        .light-theme .project-link,
        .light-theme .contact-link,
        .light-theme .contact-social-link,
        .light-theme .project-technology {
          color: var(--accent-blue);
          background-color: rgba(77, 77, 255, 0.1);
        }
        
        .light-theme .project-link:hover,
        .light-theme .contact-social-link:hover {
          background-color: var(--accent-blue);
          color: white;
        }
        
        /* Media queries */
        @media (max-width: 1024px) {
          .resume-body {
            flex-direction: column;
          }
          
          .resume-nav {
            width: 100%;
            border-right: none;
            border-bottom: 1px solid var(--accent-cyan);
            padding: var(--space-sm);
            flex-direction: row;
            flex-wrap: wrap;
            gap: var(--space-xs);
          }
          
          .nav-title {
            width: 100%;
            margin-bottom: var(--space-xs);
          }
          
          .nav-item {
            margin-bottom: 0;
            padding: var(--space-xs) var(--space-sm);
          }
          
          .nav-label {
            font-size: 0.9rem;
          }
        }
        
        @media (max-width: 768px) {
          .page-title {
            font-size: 2.5rem;
          }
          
          .resume-header {
            flex-direction: column;
            align-items: flex-start;
            gap: var(--space-md);
          }
          
          .resume-actions {
            width: 100%;
          }
          
          .download-button {
            width: 100%;
          }
          
          .resume-name {
            font-size: 1.5rem;
          }
          
          .resume-title {
            font-size: 1rem;
          }
          
          .section-title {
            font-size: 1.3rem;
          }
          
          .contact-info {
            grid-template-columns: 1fr;
          }
        }
        
        @media (max-width: 480px) {
          .page-title {
            font-size: 2rem;
          }
          
          .nav-icon {
            font-size: 1rem;
          }
          
          .nav-label {
            display: none;
          }
          
          .nav-item {
            padding: var(--space-xs);
            min-width: 40px;
            justify-content: center;
          }
          
          .resume-section-content {
            padding: var(--space-md);
          }
          
          .skills-grid {
            grid-template-columns: 1fr;
          }
        }
      `}</style>
    </section>
  );
};

export default ResumeHologram;
</file>

<file path="frontend/src/components/sections/TechStackGalaxy.jsx">
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { useTheme } from '../../contexts/ThemeContext';

// Skill categories with icons represented as text for simplicity
const SKILL_CATEGORIES = [
  {
    id: 'cybersecurity',
    name: 'Cybersecurity',
    icon: 'ðŸ”’',
    color: '#ff3d3d'
  },
  {
    id: 'frontend',
    name: 'Frontend',
    icon: 'ðŸ–¥ï¸',
    color: '#00fff5'
  },
  {
    id: 'backend',
    name: 'Backend',
    icon: 'âš™ï¸',
    color: '#4d4dff'
  },
  {
    id: 'devops',
    name: 'DevOps',
    icon: 'ðŸ”„',
    color: '#00ff9f'
  },
  {
    id: 'databases',
    name: 'Databases',
    icon: 'ðŸ’¾',
    color: '#d22aff'
  },
  {
    id: 'networking',
    name: 'Networking',
    icon: 'ðŸŒ',
    color: '#ffcc00'
  }
];

// Skills data
const SKILLS = [
  // Cybersecurity
  { name: 'Penetration Testing', category: 'cybersecurity', level: 90 },
  { name: 'Vulnerability Assessment', category: 'cybersecurity', level: 85 },
  { name: 'Security Monitoring', category: 'cybersecurity', level: 80 },
  { name: 'Incident Response', category: 'cybersecurity', level: 75 },
  { name: 'Compliance (ISO, NIST)', category: 'cybersecurity', level: 70 },
  { name: 'Risk Management', category: 'cybersecurity', level: 85 },
  
  // Frontend
  { name: 'React', category: 'frontend', level: 90 },
  { name: 'JavaScript/ES6+', category: 'frontend', level: 85 },
  { name: 'HTML5/CSS3', category: 'frontend', level: 95 },
  { name: 'TypeScript', category: 'frontend', level: 75 },
  { name: 'Responsive Design', category: 'frontend', level: 90 },
  { name: 'Three.js', category: 'frontend', level: 65 },
  
  // Backend
  { name: 'Python', category: 'backend', level: 95 },
  { name: 'Flask', category: 'backend', level: 85 },
  { name: 'Node.js', category: 'backend', level: 80 },
  { name: 'Express', category: 'backend', level: 75 },
  { name: 'RESTful APIs', category: 'backend', level: 90 },
  { name: 'GraphQL', category: 'backend', level: 60 },
  
  // DevOps
  { name: 'Docker', category: 'devops', level: 90 },
  { name: 'Kubernetes', category: 'devops', level: 65 },
  { name: 'CI/CD Pipelines', category: 'devops', level: 75 },
  { name: 'AWS Services', category: 'devops', level: 80 },
  { name: 'Terraform', category: 'devops', level: 60 },
  { name: 'Linux Administration', category: 'devops', level: 85 },
  
  // Databases
  { name: 'MongoDB', category: 'databases', level: 85 },
  { name: 'PostgreSQL', category: 'databases', level: 80 },
  { name: 'MySQL', category: 'databases', level: 75 },
  { name: 'Redis', category: 'databases', level: 70 },
  { name: 'Database Design', category: 'databases', level: 80 },
  { name: 'Data Modeling', category: 'databases', level: 75 },
  
  // Networking
  { name: 'TCP/IP', category: 'networking', level: 90 },
  { name: 'Firewalls', category: 'networking', level: 85 },
  { name: 'VPNs', category: 'networking', level: 80 },
  { name: 'Network Security', category: 'networking', level: 90 },
  { name: 'DNS', category: 'networking', level: 75 },
  { name: 'Load Balancing', category: 'networking', level: 70 }
];

const TechStackGalaxy = ({ fullPage = false }) => {
  const { theme } = useTheme();
  const canvasRef = useRef(null);
  const galaxyContainerRef = useRef(null);
  const [activeCategory, setActiveCategory] = useState('cybersecurity');
  const [filteredSkills, setFilteredSkills] = useState([]);
  const [isMobile, setIsMobile] = useState(false);
  const [isRotating, setIsRotating] = useState(true);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [skillDetails, setSkillDetails] = useState(null);
  
  // Check if mobile
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth <= 768);
    };
    
    checkMobile();
    window.addEventListener('resize', checkMobile);
    
    return () => window.removeEventListener('resize', checkMobile);
  }, []);
  
  // Filter skills based on active category
  useEffect(() => {
    setFilteredSkills(SKILLS.filter(skill => skill.category === activeCategory));
  }, [activeCategory]);
  
  // Handle mouse movement for parallax effect
  useEffect(() => {
    const handleMouseMove = (e) => {
      if (!galaxyContainerRef.current) return;
      
      const rect = galaxyContainerRef.current.getBoundingClientRect();
      
      setMousePosition({
        x: ((e.clientX - rect.left) / rect.width - 0.5) * 2,
        y: ((e.clientY - rect.top) / rect.height - 0.5) * 2
      });
    };
    
    const galaxyContainer = galaxyContainerRef.current;
    
    if (galaxyContainer) {
      galaxyContainer.addEventListener('mousemove', handleMouseMove);
    }
    
    return () => {
      if (galaxyContainer) {
        galaxyContainer.removeEventListener('mousemove', handleMouseMove);
      }
    };
  }, []);
  
  // 3D Galaxy Animation
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    const setCanvasDimensions = () => {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };
    
    window.addEventListener('resize', setCanvasDimensions);
    setCanvasDimensions();
    
    // Galaxy parameters
    const stars = [];
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // Create stars
    const createStars = () => {
      const starCount = Math.min(Math.floor(canvas.width * canvas.height / 3000), 200);
      
      for (let i = 0; i < starCount; i++) {
        const radius = Math.random() * 1.5 + 0.5;
        const distance = Math.random() * (Math.min(canvas.width, canvas.height) / 3) + 50;
        const angle = Math.random() * Math.PI * 2;
        const speed = (0.2 + Math.random() * 0.8) * 0.001;
        
        // Color based on category
        const categoryIndex = Math.floor(Math.random() * SKILL_CATEGORIES.length);
        const category = SKILL_CATEGORIES[categoryIndex];
        
        stars.push({
          x: centerX + Math.cos(angle) * distance,
          y: centerY + Math.sin(angle) * distance,
          radius,
          distance,
          angle,
          speed,
          color: category.color,
          opacity: 0.3 + Math.random() * 0.7,
          category: category.id
        });
      }
    };
    
    // Render galaxy
    const renderGalaxy = () => {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Apply galaxy background
      const galaxyGradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, Math.min(canvas.width, canvas.height) / 2
      );
      
      if (theme === 'dark') {
        galaxyGradient.addColorStop(0, 'rgba(0, 20, 40, 0.3)');
        galaxyGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      } else {
        galaxyGradient.addColorStop(0, 'rgba(200, 220, 255, 0.3)');
        galaxyGradient.addColorStop(1, 'rgba(245, 245, 245, 0)');
      }
      
      ctx.fillStyle = galaxyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw galaxy center glow
      const centerGradient = ctx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, 80
      );
      
      const categoryColor = SKILL_CATEGORIES.find(c => c.id === activeCategory)?.color || '#00fff5';
      
      centerGradient.addColorStop(0, `${categoryColor}40`);
      centerGradient.addColorStop(1, 'transparent');
      
      ctx.fillStyle = centerGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, 80, 0, Math.PI * 2);
      ctx.fill();
      
      // Update and draw stars
      for (const star of stars) {
        if (isRotating) {
          star.angle += star.speed;
        }
        
        // Calculate position with parallax effect
        const parallaxX = mousePosition.x * (star.distance * 0.05);
        const parallaxY = mousePosition.y * (star.distance * 0.05);
        
        star.x = centerX + Math.cos(star.angle) * star.distance + parallaxX;
        star.y = centerY + Math.sin(star.angle) * star.distance + parallaxY;
        
        // Draw star with higher opacity for active category
        ctx.globalAlpha = star.category === activeCategory ? star.opacity * 1.5 : star.opacity * 0.5;
        
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fillStyle = star.color;
        ctx.fill();
        
        // Draw glow
        const glowSize = star.radius * 5;
        const glow = ctx.createRadialGradient(
          star.x, star.y, 0,
          star.x, star.y, glowSize
        );
        
        glow.addColorStop(0, `${star.color}80`);
        glow.addColorStop(1, 'transparent');
        
        ctx.globalAlpha = star.category === activeCategory ? 0.4 : 0.2;
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(star.x, star.y, glowSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1;
      }
      
      // Draw connection lines for active category
      ctx.strokeStyle = categoryColor;
      ctx.lineWidth = 1;
      
      const activeStars = stars.filter(s => s.category === activeCategory);
      
      for (let i = 0; i < activeStars.length; i++) {
        for (let j = i + 1; j < activeStars.length; j++) {
          const star1 = activeStars[i];
          const star2 = activeStars[j];
          
          const dx = star1.x - star2.x;
          const dy = star1.y - star2.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 100) {
            ctx.globalAlpha = (1 - distance / 100) * 0.3;
            ctx.beginPath();
            ctx.moveTo(star1.x, star1.y);
            ctx.lineTo(star2.x, star2.y);
            ctx.stroke();
          }
        }
      }
      
      ctx.globalAlpha = 1;
    };
    
    // Initialize and start animation
    createStars();
    
    let animationId;
    const animate = () => {
      renderGalaxy();
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Clean up
    return () => {
      window.removeEventListener('resize', setCanvasDimensions);
      cancelAnimationFrame(animationId);
    };
  }, [theme, activeCategory, isRotating, mousePosition]);
  
  // Show skill details
  const handleSkillHover = (skill) => {
    setSkillDetails(skill);
  };
  
  const handleSkillLeave = () => {
    setSkillDetails(null);
  };
  
  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.05
      }
    }
  };
  
  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { type: 'spring', stiffness: 100 }
    }
  };
  
  return (
    <section className={`tech-stack-section ${fullPage ? 'full-page' : ''}`} id="tech-stack">
      <div className="container">
        {!fullPage && (
          <motion.h2 
            className="section-title"
            initial={{ opacity: 0, y: -20 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true, margin: "-100px" }}
            transition={{ duration: 0.5 }}
          >
            Tech Stack
          </motion.h2>
        )}
        
        {fullPage && (
          <motion.h1 
            className="page-title"
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            Technology Matrix
          </motion.h1>
        )}
        
        <div className="tech-galaxy-container" ref={galaxyContainerRef}>
          <canvas 
            ref={canvasRef} 
            className="tech-galaxy-canvas"
            aria-hidden="true"
          ></canvas>
          
          <motion.div 
            className="category-selector"
            variants={containerVariants}
            initial="hidden"
            whileInView="visible"
            viewport={{ once: true, margin: "-100px" }}
          >
            {SKILL_CATEGORIES.map((category) => (
              <motion.button 
                key={category.id}
                className={`category-button ${activeCategory === category.id ? 'active' : ''}`}
                onClick={() => setActiveCategory(category.id)}
                variants={itemVariants}
                style={{
                  '--category-color': category.color
                }}
              >
                <span className="category-icon">{category.icon}</span>
                <span className="category-name">{category.name}</span>
              </motion.button>
            ))}
            
            <motion.button 
              className="rotation-toggle"
              onClick={() => setIsRotating(!isRotating)}
              variants={itemVariants}
              aria-label={isRotating ? 'Pause rotation' : 'Resume rotation'}
              title={isRotating ? 'Pause rotation' : 'Resume rotation'}
            >
              {isRotating ? 'â¸' : 'â–¶ï¸'}
            </motion.button>
          </motion.div>
          
          <motion.div 
            className="skills-display"
            variants={containerVariants}
            initial="hidden"
            whileInView="visible"
            viewport={{ once: true, margin: "-100px" }}
          >
            {filteredSkills.map((skill, index) => (
              <motion.div 
                key={index}
                className="skill-item"
                variants={itemVariants}
                onMouseEnter={() => handleSkillHover(skill)}
                onMouseLeave={handleSkillLeave}
              >
                <div className="skill-name">{skill.name}</div>
                <div className="skill-level-container">
                  <div 
                    className="skill-level-bar" 
                    style={{ 
                      width: `${skill.level}%`,
                      backgroundColor: SKILL_CATEGORIES.find(c => c.id === skill.category)?.color
                    }}
                  ></div>
                </div>
                <div className="skill-level-text">{skill.level}%</div>
              </motion.div>
            ))}
          </motion.div>
          
          {skillDetails && (
            <div 
              className="skill-details"
              style={{
                '--detail-color': SKILL_CATEGORIES.find(c => c.id === skillDetails.category)?.color
              }}
            >
              <div className="skill-details-header">
                <div className="skill-details-name">{skillDetails.name}</div>
                <div className="skill-details-category">
                  {SKILL_CATEGORIES.find(c => c.id === skillDetails.category)?.name}
                </div>
              </div>
              
              <div className="skill-details-level">
                <div className="skill-details-level-label">Proficiency</div>
                <div className="skill-details-level-bar-container">
                  <div 
                    className="skill-details-level-bar" 
                    style={{ width: `${skillDetails.level}%` }}
                  ></div>
                </div>
                <div className="skill-details-level-text">{skillDetails.level}%</div>
              </div>
              
              <div className="skill-details-description">
                {getSkillDescription(skillDetails.name)}
              </div>
            </div>
          )}
        </div>
      </div>
      
      <style jsx>{`
        .tech-stack-section {
          position: relative;
          padding: var(--space-xxl) 0;
          min-height: ${fullPage ? '100vh' : 'auto'};
        }
        
        .tech-stack-section.full-page {
          padding-top: calc(var(--header-height) + var(--space-xl));
        }
        
        .section-title,
        .page-title {
          text-align: center;
          margin-bottom: var(--space-xl);
          color: var(--accent-cyan);
          position: relative;
          display: inline-block;
          width: 100%;
        }
        
        .page-title {
          font-size: 3rem;
        }
        
        .section-title::after,
        .page-title::after {
          content: '';
          position: absolute;
          bottom: -10px;
          left: 50%;
          transform: translateX(-50%);
          width: 100px;
          height: 3px;
          background: linear-gradient(
            90deg,
            transparent,
            var(--accent-cyan),
            transparent
          );
        }
        
        .tech-galaxy-container {
          position: relative;
          width: 100%;
          height: 600px;
          margin-bottom: var(--space-xl);
          border-radius: var(--border-radius-lg);
          overflow: hidden;
          background-color: rgba(10, 10, 10, 0.5);
          border: 1px solid var(--border-primary);
        }
        
        .tech-galaxy-canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 0;
        }
        
        .category-selector {
          position: absolute;
          top: var(--space-md);
          left: 50%;
          transform: translateX(-50%);
          display: flex;
          gap: var(--space-sm);
          z-index: 1;
          flex-wrap: wrap;
          justify-content: center;
          max-width: 90%;
          padding: var(--space-sm);
          background-color: rgba(10, 10, 10, 0.7);
          border-radius: var(--border-radius-md);
          backdrop-filter: blur(5px);
        }
        
        .category-button {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: var(--space-sm);
          background-color: rgba(20, 20, 20, 0.6);
          border: 1px solid var(--border-primary);
          border-radius: var(--border-radius-sm);
          color: var(--text-secondary);
          transition: all var(--transition-normal);
          min-width: 80px;
          cursor: none;
        }
        
        .category-button:hover {
          transform: translateY(-3px);
          border-color: var(--category-color);
          box-shadow: 0 0 10px rgba(var(--category-color), 0.3);
        }
        
        .category-button.active {
          border-color: var(--category-color);
          background-color: rgba(var(--category-color), 0.2);
          color: #fff;
          box-shadow: 0 0 15px rgba(var(--category-color), 0.3);
        }
        
        .category-icon {
          font-size: 1.5rem;
          margin-bottom: var(--space-xs);
        }
        
        .category-name {
          font-size: 0.8rem;
          font-family: var(--font-mono);
          text-transform: uppercase;
          letter-spacing: 1px;
        }
        
        .rotation-toggle {
          position: absolute;
          top: var(--space-sm);
          right: var(--space-sm);
          width: 36px;
          height: 36px;
          background-color: rgba(20, 20, 20, 0.6);
          border: 1px solid var(--border-primary);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 1.2rem;
          transition: all var(--transition-normal);
          cursor: none;
        }
        
        .rotation-toggle:hover {
          border-color: var(--accent-cyan);
          box-shadow: 0 0 10px rgba(0, 255, 245, 0.3);
        }
        
        .skills-display {
          position: absolute;
          bottom: var(--space-md);
          left: var(--space-md);
          right: var(--space-md);
          max-height: 300px;
          overflow-y: auto;
          background-color: rgba(10, 10, 10, 0.8);
          border-radius: var(--border-radius-md);
          padding: var(--space-md);
          z-index: 1;
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
          gap: var(--space-md);
          backdrop-filter: blur(5px);
        }
        
        .skills-display::-webkit-scrollbar {
          width: 6px;
        }
        
        .skills-display::-webkit-scrollbar-track {
          background: rgba(0, 0, 0, 0.2);
          border-radius: 3px;
        }
        
        .skills-display::-webkit-scrollbar-thumb {
          background: var(--accent-cyan);
          border-radius: 3px;
        }
        
        .skill-item {
          background-color: rgba(20, 20, 20, 0.6);
          border-radius: var(--border-radius-sm);
          padding: var(--space-sm);
          transition: all var(--transition-normal);
        }
        
        .skill-item:hover {
          transform: translateY(-2px);
          box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .skill-name {
          color: var(--text-primary);
          font-size: 0.9rem;
          margin-bottom: var(--space-xs);
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        
        .skill-level-container {
          width: 100%;
          height: 6px;
          background-color: rgba(255, 255, 255, 0.1);
          border-radius: 3px;
          overflow: hidden;
          margin-bottom: var(--space-xs);
        }
        
        .skill-level-bar {
          height: 100%;
          border-radius: 3px;
          transition: width 1s ease-out;
        }
        
        .skill-level-text {
          color: var(--text-secondary);
          font-size: 0.8rem;
          text-align: right;
          font-family: var(--font-mono);
        }
        
        .skill-details {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 300px;
          background-color: rgba(10, 10, 10, 0.9);
          border-radius: var(--border-radius-md);
          border: 1px solid var(--detail-color);
          padding: var(--space-md);
          z-index: 2;
          box-shadow: 0 0 30px rgba(0, 0, 0, 0.3), 0 0 15px rgba(var(--detail-color), 0.3);
          backdrop-filter: blur(10px);
        }
        
        .skill-details::before {
          content: '';
          position: absolute;
          top: -20px;
          left: -20px;
          width: 40px;
          height: 40px;
          border-top: 2px solid var(--detail-color);
          border-left: 2px solid var(--detail-color);
        }
        
        .skill-details::after {
          content: '';
          position: absolute;
          bottom: -20px;
          right: -20px;
          width: 40px;
          height: 40px;
          border-bottom: 2px solid var(--detail-color);
          border-right: 2px solid var(--detail-color);
        }
        
        .skill-details-header {
          margin-bottom: var(--space-md);
          padding-bottom: var(--space-sm);
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .skill-details-name {
          color: var(--detail-color);
          font-size: 1.2rem;
          margin-bottom: var(--space-xs);
        }
        
        .skill-details-category {
          color: var(--text-secondary);
          font-size: 0.8rem;
          font-family: var(--font-mono);
        }
        
        .skill-details-level {
          margin-bottom: var(--space-md);
        }
        
        .skill-details-level-label {
          color: var(--text-secondary);
          font-size: 0.9rem;
          margin-bottom: var(--space-xs);
        }
        
        .skill-details-level-bar-container {
          width: 100%;
          height: 10px;
          background-color: rgba(255, 255, 255, 0.1);
          border-radius: 5px;
          overflow: hidden;
          margin-bottom: var(--space-xs);
        }
        
        .skill-details-level-bar {
          height: 100%;
          background-color: var(--detail-color);
          border-radius: 5px;
        }
        
        .skill-details-level-text {
          color: var(--text-primary);
          font-size: 0.9rem;
          text-align: right;
          font-family: var(--font-mono);
        }
        
        .skill-details-description {
          color: var(--text-secondary);
          font-size: 0.9rem;
          line-height: 1.5;
        }
        
        /* Light theme styles */
        .light-theme .tech-galaxy-container {
          background-color: rgba(245, 245, 245, 0.5);
        }
        
        .light-theme .category-selector,
        .light-theme .skills-display {
          background-color: rgba(245, 245, 245, 0.8);
        }
        
        .light-theme .category-button,
        .light-theme .skill-item,
        .light-theme .rotation-toggle {
          background-color: rgba(220, 220, 220, 0.6);
          border-color: rgba(0, 0, 0, 0.1);
        }
        
        .light-theme .skill-details {
          background-color: rgba(245, 245, 245, 0.9);
        }
        
        .light-theme .skill-level-container,
        .light-theme .skill-details-level-bar-container {
          background-color: rgba(0, 0, 0, 0.1);
        }
        
        /* Media queries */
        @media (max-width: 768px) {
          .tech-galaxy-container {
            height: 700px;
          }
          
          .category-selector {
            max-width: 100%;
            padding: var(--space-xs);
            top: var(--space-sm);
          }
          
          .category-button {
            min-width: 60px;
            padding: var(--space-xs);
          }
          
          .category-icon {
            font-size: 1.2rem;
          }
          
          .category-name {
            font-size: 0.7rem;
          }
          
          .skills-display {
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: var(--space-sm);
            bottom: var(--space-sm);
            left: var(--space-sm);
            right: var(--space-sm);
            padding: var(--space-sm);
          }
          
          .skill-details {
            width: 280px;
          }
          
          .page-title {
            font-size: 2.2rem;
          }
        }
        
        @media (max-width: 480px) {
          .tech-galaxy-container {
            height: 600px;
          }
          
          .category-selector {
            gap: var(--space-xs);
          }
          
          .category-button {
            min-width: 50px;
          }
          
          .skills-display {
            grid-template-columns: 1fr;
            max-height: 250px;
          }
          
          .skill-details {
            width: 90%;
            max-width: 280px;
          }
        }
      `}</style>
    </section>
  );
};

// Helper function to get skill descriptions
function getSkillDescription(skillName) {
  const descriptions = {
    // Cybersecurity
    'Penetration Testing': 'Simulating cyber attacks to identify security vulnerabilities in systems, networks, and applications. Includes both manual and automated testing techniques.',
    'Vulnerability Assessment': 'Systematic review of security weaknesses in information systems. Evaluates if the system is susceptible to known vulnerabilities and assigns severity levels.',
    'Security Monitoring': 'Continuous observation of systems and networks to detect security incidents and suspicious activities in real-time. Includes log analysis and SIEM implementation.',
    'Incident Response': 'Methodology for handling security breaches, including preparation, identification, containment, eradication, recovery, and lessons learned.',
    'Compliance (ISO, NIST)': 'Knowledge of regulatory frameworks, standards, and requirements. Implementation of controls to ensure adherence to ISO 27001, NIST, and other frameworks.',
    'Risk Management': 'Identification, assessment, and prioritization of risks followed by coordinated application of resources to minimize, monitor, and control the impact of unfortunate events.',
    
    // Frontend
    'React': 'Building dynamic and responsive user interfaces with React.js, including state management, hooks, and component lifecycle. Experience with Redux and context API.',
    'JavaScript/ES6+': 'Modern JavaScript development utilizing ES6+ features like arrow functions, destructuring, promises, async/await, and modules.',
    'HTML5/CSS3': 'Creating semantic markup and responsive designs using the latest HTML5 elements and CSS3 features including flexbox, grid, and animations.',
    'TypeScript': 'Implementing strongly typed JavaScript development for improved code quality, better documentation, and enhanced IDE support.',
    'Responsive Design': 'Building websites that provide optimal viewing experience across a wide range of devices from desktop to mobile phones.',
    'Three.js': 'Creating 3D graphics and animations for web browsers using WebGL through the Three.js library.',
    
    // Backend
    'Python': 'Developing robust backend services, data processing pipelines, and automation scripts using Python and its extensive ecosystem.',
    'Flask': 'Building lightweight web applications and APIs using Flask, including RESTful endpoints, authentication, and database integration.',
    'Node.js': 'Creating scalable server-side applications with JavaScript runtime, including event-driven architecture and asynchronous programming.',
    'Express': 'Implementing web applications and APIs with Express.js framework, including middleware, routing, and template engines.',
    'RESTful APIs': 'Designing and developing stateless APIs following REST principles for communication between client and server applications.',
    'GraphQL': 'Implementing flexible query language for APIs, allowing clients to request exactly what they need and making it easier to evolve APIs over time.',
    
    // DevOps
    'Docker': 'Containerizing applications to ensure consistency across different development and production environments, including multi-container applications.',
    'Kubernetes': 'Orchestrating containerized applications for automated deployment, scaling, and management in cluster environments.',
    'CI/CD Pipelines': 'Implementing continuous integration and continuous deployment pipelines to automate testing and deployment processes.',
    'AWS Services': 'Leveraging cloud services like EC2, S3, Lambda, and more for scalable and reliable application infrastructure.',
    'Terraform': 'Using infrastructure as code to provision and manage cloud resources across multiple providers.',
    'Linux Administration': 'Managing and troubleshooting Linux systems, including user management, permissions, services, and performance optimization.',
    
    // Databases
    'MongoDB': 'Working with document-oriented NoSQL databases for flexible and scalable data storage and retrieval.',
    'PostgreSQL': 'Implementing relational database solutions with advanced features like JSON storage, full-text search, and complex queries.',
    'MySQL': 'Managing relational databases for structured data storage, including optimization, backup, and recovery procedures.',
    'Redis': 'Using in-memory data structure store for caching, message brokering, and other high-performance data operations.',
    'Database Design': 'Creating efficient database schemas, normalizing data, and optimizing performance through proper indexing and query design.',
    'Data Modeling': 'Conceptualizing and creating database structures that reflect business requirements while maintaining data integrity.',
    
    // Networking
    'TCP/IP': 'Understanding and implementing the foundational protocols that govern internet communications.',
    'Firewalls': 'Configuring and managing network security systems that monitor and control incoming and outgoing traffic.',
    'VPNs': 'Setting up secure network connections that extend private networks across public networks to enable secure data transmission.',
    'Network Security': 'Implementing measures to protect network infrastructure and data from unauthorized access, misuse, and modification.',
    'DNS': 'Managing Domain Name System services that translate domain names to IP addresses and vice versa.',
    'Load Balancing': 'Distributing network traffic across multiple servers to ensure no single server is overwhelmed, improving reliability and performance.'
  };
  
  return descriptions[skillName] || 'A specialized technology skill in the selected category.';
}

export default TechStackGalaxy;
</file>

<file path="frontend/src/contexts/AudioContext.jsx">
import { createContext, useContext, useState, useEffect, useCallback } from 'react';

// Create context with default values
const AudioContext = createContext({
  audioEnabled: false,
  toggleAudio: () => {},
  playSound: () => {},
  initializeAudio: () => {},
});

// Custom hook to use the audio context
export const useAudio = () => useContext(AudioContext);

// Audio provider component
export const AudioProvider = ({ children }) => {
  // Audio state
  const [audioEnabled, setAudioEnabled] = useState(false);
  const [audioInitialized, setAudioInitialized] = useState(false);
  const [ambientAudio, setAmbientAudio] = useState(null);
  const [hoverSound, setHoverSound] = useState(null);
  const [clickSound, setClickSound] = useState(null);

  // Initialize audio elements
  const initializeAudio = useCallback(() => {
    if (audioInitialized) return;
    
    const ambient = document.getElementById('ambient-background');
    const hover = document.getElementById('ui-sound-hover');
    const click = document.getElementById('ui-sound-click');
    
    if (ambient && hover && click) {
      setAmbientAudio(ambient);
      setHoverSound(hover);
      setClickSound(click);
      
      // Set volume levels
      ambient.volume = 0.1;
      hover.volume = 0.2;
      click.volume = 0.3;
      
      setAudioInitialized(true);
      
      // Get saved audio preference from localStorage
      const savedAudioEnabled = localStorage.getItem('audioEnabled') === 'true';
      setAudioEnabled(savedAudioEnabled);
      
      // If audio was enabled previously, start ambient sound
      if (savedAudioEnabled) {
        ambient.play().catch((e) => console.log('Audio play prevented by browser', e));
      }
    }
  }, [audioInitialized]);

  // Toggle audio on/off
  const toggleAudio = useCallback(() => {
    if (!audioInitialized) return;
    
    setAudioEnabled((prev) => {
      const newState = !prev;
      
      // Save preference to localStorage
      localStorage.setItem('audioEnabled', newState.toString());
      
      // Play or pause ambient audio
      if (newState) {
        ambientAudio.play().catch((e) => console.log('Audio play prevented by browser', e));
      } else {
        ambientAudio.pause();
      }
      
      return newState;
    });
  }, [audioInitialized, ambientAudio]);

  // Play UI sound effect
  const playSound = useCallback((type = 'click') => {
    if (!audioInitialized || !audioEnabled) return;
    
    try {
      const sound = type === 'hover' ? hoverSound : clickSound;
      
      if (sound) {
        // Reset sound to beginning
        sound.currentTime = 0;
        sound.play().catch((e) => {
          // Handle any autoplay restrictions
          console.log('Sound play prevented by browser', e);
        });
      }
    } catch (error) {
      console.error('Error playing sound:', error);
    }
  }, [audioInitialized, audioEnabled, hoverSound, clickSound]);

  // Set up global hover sound events
  useEffect(() => {
    if (!audioInitialized || !audioEnabled) return;
    
    const handleMouseEnter = () => playSound('hover');
    
    // Add hover sound to interactive elements
    const interactiveElements = document.querySelectorAll('button, a, [role="button"]');
    interactiveElements.forEach((el) => {
      el.addEventListener('mouseenter', handleMouseEnter);
    });
    
    // Clean up
    return () => {
      interactiveElements.forEach((el) => {
        el.removeEventListener('mouseenter', handleMouseEnter);
      });
    };
  }, [audioInitialized, audioEnabled, playSound]);

  // Provide audio context to children
  return (
    <AudioContext.Provider value={{ audioEnabled, toggleAudio, playSound, initializeAudio }}>
      {children}
    </AudioContext.Provider>
  );
};

export default AudioContext;
</file>

<file path="frontend/src/contexts/ThemeContext.jsx">
import { createContext, useContext, useState, useEffect } from 'react';

// Create context with default values
const ThemeContext = createContext({
  theme: 'dark',
  toggleTheme: () => {},
});

// Custom hook to use the theme context
export const useTheme = () => useContext(ThemeContext);

// Theme provider component
export const ThemeProvider = ({ children }) => {
  // Get saved theme from localStorage or default to 'dark'
  const [theme, setTheme] = useState(() => {
    const savedTheme = localStorage.getItem('theme');
    return savedTheme || 'dark';
  });

  // Toggle between 'dark' and 'light' themes
  const toggleTheme = () => {
    setTheme((prevTheme) => (prevTheme === 'dark' ? 'light' : 'dark'));
  };

  // Save theme to localStorage whenever it changes
  useEffect(() => {
    localStorage.setItem('theme', theme);
    
    // Apply theme class to body element
    if (theme === 'dark') {
      document.body.classList.remove('light-theme');
    } else {
      document.body.classList.add('light-theme');
    }
  }, [theme]);

  // Provide theme context to children
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export default ThemeContext;
</file>

<file path="frontend/src/hooks/useAudio.js">
import { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';

// Create context for audio functionality
const AudioContext = createContext({
  audioEnabled: false,
  audioInitialized: false,
  toggleAudio: () => {},
  playSound: () => {},
  initializeAudio: () => {},
  setVolume: () => {},
  ambientVolume: 0.3,
  effectsVolume: 0.5
});

// Custom hook to use the audio context
export const useAudio = () => useContext(AudioContext);

// Provider component for audio context
export const AudioProvider = ({ children }) => {
  // State for audio settings
  const [audioEnabled, setAudioEnabled] = useState(false);
  const [audioInitialized, setAudioInitialized] = useState(false);
  const [ambientVolume, setAmbientVolume] = useState(0.3);
  const [effectsVolume, setEffectsVolume] = useState(0.5);
  
  // References to audio elements
  const ambientAudioRef = useRef(null);
  const hoverSoundRef = useRef(null);
  const clickSoundRef = useRef(null);
  const glitchSoundRef = useRef(null);
  const successSoundRef = useRef(null);
  const errorSoundRef = useRef(null);
  
  // Debounce timer for hover sound to prevent sound spam
  const hoverDebounceRef = useRef(null);
  
  // Initialize audio system - must be called after user interaction
  const initializeAudio = useCallback(() => {
    if (audioInitialized) return;
    
    // Try to get audio elements from DOM
    const ambientAudio = document.getElementById('ambient-background');
    const hoverSound = document.getElementById('ui-sound-hover');
    const clickSound = document.getElementById('ui-sound-click');
    const glitchSound = document.getElementById('ui-sound-glitch');
    const successSound = document.getElementById('ui-sound-success');
    const errorSound = document.getElementById('ui-sound-error');
    
    // If all required audio elements exist
    if (ambientAudio && hoverSound && clickSound) {
      // Store references
      ambientAudioRef.current = ambientAudio;
      hoverSoundRef.current = hoverSound;
      clickSoundRef.current = clickSound;
      
      // Store optional audio references if they exist
      if (glitchSound) glitchSoundRef.current = glitchSound;
      if (successSound) successSoundRef.current = successSound;
      if (errorSound) errorSoundRef.current = errorSound;
      
      // Set initial volumes
      ambientAudio.volume = ambientVolume;
      hoverSound.volume = effectsVolume;
      clickSound.volume = effectsVolume;
      if (glitchSound) glitchSound.volume = effectsVolume;
      if (successSound) successSound.volume = effectsVolume;
      if (errorSound) errorSound.volume = effectsVolume;
      
      // Mark as initialized
      setAudioInitialized(true);
      
      // Load preference from localStorage
      const savedAudioEnabled = localStorage.getItem('audioEnabled') === 'true';
      setAudioEnabled(savedAudioEnabled);
      
      // Start ambient audio if enabled
      if (savedAudioEnabled) {
        ambientAudio.play().catch(error => {
          console.warn('Could not autoplay ambient audio:', error);
        });
      }
    }
  }, [audioInitialized, ambientVolume, effectsVolume]);
  
  // Toggle audio on/off
  const toggleAudio = useCallback(() => {
    if (!audioInitialized) return;
    
    const newAudioEnabled = !audioEnabled;
    setAudioEnabled(newAudioEnabled);
    
    // Save preference to localStorage
    localStorage.setItem('audioEnabled', newAudioEnabled);
    
    // Play or pause ambient audio
    if (newAudioEnabled) {
      ambientAudioRef.current.play().catch(error => {
        console.warn('Could not play ambient audio:', error);
      });
    } else {
      ambientAudioRef.current.pause();
    }
    
    // Play click sound to confirm toggle
    playSound('click');
  }, [audioInitialized, audioEnabled]);
  
  // Function to play sound effects
  const playSound = useCallback((type = 'click') => {
    if (!audioInitialized || !audioEnabled) return;
    
    let sound;
    switch (type) {
      case 'hover':
        // Prevent hover sound spam with debouncing
        if (hoverDebounceRef.current) return;
        sound = hoverSoundRef.current;
        hoverDebounceRef.current = setTimeout(() => {
          hoverDebounceRef.current = null;
        }, 100);
        break;
      case 'click':
        sound = clickSoundRef.current;
        break;
      case 'glitch':
        sound = glitchSoundRef.current;
        break;
      case 'success':
        sound = successSoundRef.current;
        break;
      case 'error':
        sound = errorSoundRef.current;
        break;
      default:
        sound = clickSoundRef.current;
    }
    
    if (sound) {
      // Reset sound to start
      sound.currentTime = 0;
      
      // Play the sound
      sound.play().catch(error => {
        console.warn(`Could not play ${type} sound:`, error);
      });
    }
  }, [audioInitialized, audioEnabled]);
  
  // Set volume levels
  const setVolume = useCallback((type, level) => {
    if (!audioInitialized) return;
    
    // Ensure volume is between 0 and 1
    const volume = Math.max(0, Math.min(1, level));
    
    switch (type) {
      case 'ambient':
        setAmbientVolume(volume);
        if (ambientAudioRef.current) {
          ambientAudioRef.current.volume = volume;
        }
        break;
      case 'effects':
        setEffectsVolume(volume);
        // Update all effect sounds
        if (hoverSoundRef.current) hoverSoundRef.current.volume = volume;
        if (clickSoundRef.current) clickSoundRef.current.volume = volume;
        if (glitchSoundRef.current) glitchSoundRef.current.volume = volume;
        if (successSoundRef.current) successSoundRef.current.volume = volume;
        if (errorSoundRef.current) errorSoundRef.current.volume = volume;
        break;
    }
    
    // Save settings to localStorage
    localStorage.setItem(`${type}Volume`, volume.toString());
  }, [audioInitialized]);
  
  // Add hover sound to interactive elements
  useEffect(() => {
    if (!audioInitialized || !audioEnabled) return;
    
    const handleMouseEnter = () => playSound('hover');
    
    // Find all interactive elements
    const buttons = document.querySelectorAll('button:not([disabled])');
    const links = document.querySelectorAll('a:not([disabled])');
    const interactives = document.querySelectorAll('[role="button"]:not([disabled])');
    
    // Add event listeners
    buttons.forEach(el => el.addEventListener('mouseenter', handleMouseEnter));
    links.forEach(el => el.addEventListener('mouseenter', handleMouseEnter));
    interactives.forEach(el => el.addEventListener('mouseenter', handleMouseEnter));
    
    // Cleanup function
    return () => {
      buttons.forEach(el => el.removeEventListener('mouseenter', handleMouseEnter));
      links.forEach(el => el.removeEventListener('mouseenter', handleMouseEnter));
      interactives.forEach(el => el.removeEventListener('mouseenter', handleMouseEnter));
    };
  }, [audioInitialized, audioEnabled, playSound]);
  
  // Load volume settings from localStorage on init
  useEffect(() => {
    if (!audioInitialized) return;
    
    const savedAmbientVolume = parseFloat(localStorage.getItem('ambientVolume') || '0.3');
    const savedEffectsVolume = parseFloat(localStorage.getItem('effectsVolume') || '0.5');
    
    setAmbientVolume(savedAmbientVolume);
    setEffectsVolume(savedEffectsVolume);
    
    if (ambientAudioRef.current) {
      ambientAudioRef.current.volume = savedAmbientVolume;
    }
    
    if (hoverSoundRef.current) hoverSoundRef.current.volume = savedEffectsVolume;
    if (clickSoundRef.current) clickSoundRef.current.volume = savedEffectsVolume;
    if (glitchSoundRef.current) glitchSoundRef.current.volume = savedEffectsVolume;
    if (successSoundRef.current) successSoundRef.current.volume = savedEffectsVolume;
    if (errorSoundRef.current) errorSoundRef.current.volume = savedEffectsVolume;
  }, [audioInitialized]);
  
  return (
    <AudioContext.Provider value={{
      audioEnabled,
      audioInitialized,
      toggleAudio,
      playSound,
      initializeAudio,
      setVolume,
      ambientVolume,
      effectsVolume
    }}>
      {children}
    </AudioContext.Provider>
  );
};

export default useAudio;
</file>

<file path="frontend/src/hooks/useDataStream.js">
import { useCallback, useEffect, useRef } from 'react';
import { useTheme } from '../contexts/ThemeContext';

/**
 * Custom hook for creating and controlling data stream animations
 * 
 * @param {React.RefObject} canvasRef - Reference to the canvas element
 * @param {Object} config - Configuration options for the data stream
 * @returns {Object} - Methods to control the data stream
 */
export const useDataStream = (
  canvasRef,
  {
    density = 70,
    speed = 5,
    direction = 'right',
    mode = 'continuous',
    primaryColor = null,
    secondaryColor = null
  } = {}
) => {
  const { theme } = useTheme();
  const configRef = useRef({
    density,
    speed,
    direction,
    mode,
    primaryColor: primaryColor || (theme === 'dark' ? 'rgba(0, 255, 245, 0.8)' : 'rgba(77, 77, 255, 0.8)'),
    secondaryColor: secondaryColor || 'rgba(255, 61, 61, 0.8)'
  });
  
  const streamRef = useRef({
    active: false,
    animationId: null,
    particles: [],
    lastFrameTime: 0
  });
  
  // Parse CSS variable to RGB values
  const parseColor = useCallback((color) => {
    // Handle CSS variables
    if (color.startsWith('var(')) {
      // Since we can't access computed styles directly here,
      // use predefined fallbacks for common variables
      if (color.includes('accent-cyan')) {
        return { r: 0, g: 255, b: 245 };
      } else if (color.includes('accent-blue')) {
        return { r: 77, g: 77, b: 255 };
      } else if (color.includes('accent-magenta')) {
        return { r: 255, g: 61, b: 61 };
      }
      
      // Default fallback
      return { r: 0, g: 255, b: 245 };
    }
    
    // Handle hex colors
    if (color.startsWith('#')) {
      const hex = color.substring(1);
      return {
        r: parseInt(hex.substring(0, 2), 16),
        g: parseInt(hex.substring(2, 4), 16),
        b: parseInt(hex.substring(4, 6), 16)
      };
    }
    
    // Handle rgba colors
    if (color.startsWith('rgba(')) {
      const values = color.substring(5, color.length - 1).split(',');
      return {
        r: parseInt(values[0], 10),
        g: parseInt(values[1], 10),
        b: parseInt(values[2], 10)
      };
    }
    
    // Handle rgb colors
    if (color.startsWith('rgb(')) {
      const values = color.substring(4, color.length - 1).split(',');
      return {
        r: parseInt(values[0], 10),
        g: parseInt(values[1], 10),
        b: parseInt(values[2], 10)
      };
    }
    
    // Default fallback
    return { r: 0, g: 255, b: 245 };
  }, []);
  
  // Create a data particle
  const createParticle = useCallback((canvas, config) => {
    const { width, height } = canvas;
    const { direction, primaryColor, secondaryColor } = config;
    
    // Set particle position based on direction
    let x, y;
    
    switch (direction) {
      case 'right':
        x = 0;
        y = Math.random() * height;
        break;
      case 'left':
        x = width;
        y = Math.random() * height;
        break;
      case 'up':
        x = Math.random() * width;
        y = height;
        break;
      case 'down':
        x = Math.random() * width;
        y = 0;
        break;
      default:
        x = 0;
        y = Math.random() * height;
    }
    
    // Randomly choose color
    const color = Math.random() > 0.7 ? secondaryColor : primaryColor;
    const parsedColor = parseColor(color);
    
    // Create particle
    return {
      x,
      y,
      size: 1 + Math.random() * 3,
      speed: (0.5 + Math.random() * 1.5) * config.speed / 5,
      color: `rgba(${parsedColor.r}, ${parsedColor.g}, ${parsedColor.b}, ${0.3 + Math.random() * 0.7})`,
      trail: [], // Store previous positions for trail effect
      trailLength: Math.floor(5 + Math.random() * 15),
      pulsePhase: Math.random() * Math.PI * 2, // For pulsing mode
      waveOffset: Math.random() * Math.PI * 2 // For wave mode
    };
  }, [parseColor]);
  
  // Update particle position
  const updateParticle = useCallback((particle, canvas, config, deltaTime) => {
    const { direction, mode } = config;
    const { width, height } = canvas;
    
    // Store current position in trail
    particle.trail.unshift({ x: particle.x, y: particle.y });
    
    // Limit trail length
    if (particle.trail.length > particle.trailLength) {
      particle.trail.pop();
    }
    
    // Calculate base movement
    let dx = 0;
    let dy = 0;
    
    switch (direction) {
      case 'right':
        dx = particle.speed * deltaTime / 16;
        break;
      case 'left':
        dx = -particle.speed * deltaTime / 16;
        break;
      case 'up':
        dy = -particle.speed * deltaTime / 16;
        break;
      case 'down':
        dy = particle.speed * deltaTime / 16;
        break;
    }
    
    // Apply movement patterns based on mode
    if (mode === 'wave') {
      // Add sine wave pattern perpendicular to movement
      particle.waveOffset += 0.1 * deltaTime / 16;
      
      const amplitude = 2 + Math.random() * 3;
      const waveFactor = Math.sin(particle.waveOffset) * amplitude;
      
      if (direction === 'right' || direction === 'left') {
        dy += waveFactor;
      } else {
        dx += waveFactor;
      }
    } else if (mode === 'pulse') {
      // Pulse size and opacity
      particle.pulsePhase += 0.1 * deltaTime / 16;
      
      if (particle.pulsePhase > Math.PI * 2) {
        particle.pulsePhase -= Math.PI * 2;
      }
    }
    
    // Update position
    particle.x += dx;
    particle.y += dy;
    
    // Check if particle is out of bounds
    const isOutOfBounds = 
      particle.x < -particle.size * 2 || 
      particle.x > width + particle.size * 2 || 
      particle.y < -particle.size * 2 || 
      particle.y > height + particle.size * 2;
    
    return isOutOfBounds;
  }, []);
  
  // Draw a single particle
  const drawParticle = useCallback((ctx, particle, config) => {
    const { mode } = config;
    
    // For pulse mode, adjust size and opacity
    let size = particle.size;
    let opacity = 1;
    
    if (mode === 'pulse') {
      const pulseFactor = 0.7 + 0.3 * Math.sin(particle.pulsePhase);
      size *= pulseFactor;
      opacity *= pulseFactor;
    }
    
    // Draw trail first (behind particle)
    if (particle.trail.length > 0) {
      ctx.beginPath();
      ctx.moveTo(particle.x, particle.y);
      
      for (let i = 0; i < particle.trail.length; i++) {
        const point = particle.trail[i];
        const trailOpacity = opacity * (1 - i / particle.trail.length);
        
        if (i === 0) {
          ctx.lineTo(point.x, point.y);
        } else {
          // Use quadratic curves for smoother trails
          const prevPoint = particle.trail[i - 1];
          const midX = (prevPoint.x + point.x) / 2;
          const midY = (prevPoint.y + point.y) / 2;
          
          ctx.quadraticCurveTo(prevPoint.x, prevPoint.y, midX, midY);
        }
      }
      
      // Get base color without alpha
      const baseColor = particle.color.substring(0, particle.color.lastIndexOf(',') + 1);
      
      // Create gradient along trail
      const gradient = ctx.createLinearGradient(
        particle.x, particle.y,
        particle.trail[particle.trail.length - 1].x,
        particle.trail[particle.trail.length - 1].y
      );
      
      gradient.addColorStop(0, `${baseColor} ${opacity})`);
      gradient.addColorStop(1, `${baseColor} 0)`);
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = size / 2;
      ctx.stroke();
    }
    
    // Draw particle
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
    ctx.fillStyle = particle.color.replace(/[\d.]+\)$/, `${opacity})`);
    ctx.fill();
    
    // Add glow effect
    const glowSize = size * 3;
    const glow = ctx.createRadialGradient(
      particle.x, particle.y, size * 0.5,
      particle.x, particle.y, glowSize
    );
    
    const baseColor = particle.color.substring(0, particle.color.lastIndexOf(',') + 1);
    glow.addColorStop(0, `${baseColor} ${opacity * 0.5})`);
    glow.addColorStop(1, `${baseColor} 0)`);
    
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, glowSize, 0, Math.PI * 2);
    ctx.fill();
  }, []);
  
  // Animation loop for the data stream
  const animateStream = useCallback((timestamp) => {
    if (!canvasRef.current || !streamRef.current.active) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const config = configRef.current;
    
    // Calculate time delta
    const deltaTime = timestamp - streamRef.current.lastFrameTime;
    streamRef.current.lastFrameTime = timestamp;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Add new particles based on density
    const particlesNeeded = Math.max(5, Math.floor(config.density / 10));
    const newParticlesCount = Math.max(0, particlesNeeded - streamRef.current.particles.length);
    
    // Add new particles with probability based on density and delta time
    if (Math.random() < config.density / 1000 * deltaTime / 16) {
      for (let i = 0; i < Math.min(newParticlesCount, 3); i++) {
        streamRef.current.particles.push(createParticle(canvas, config));
      }
    }
    
    // Update and draw particles
    for (let i = streamRef.current.particles.length - 1; i >= 0; i--) {
      const particle = streamRef.current.particles[i];
      
      // Update position and check if out of bounds
      const isOutOfBounds = updateParticle(particle, canvas, config, deltaTime);
      
      if (isOutOfBounds) {
        // Replace with new particle
        streamRef.current.particles.splice(i, 1);
        continue;
      }
      
      // Draw particle
      drawParticle(ctx, particle, config);
    }
    
    // Schedule next frame
    streamRef.current.animationId = requestAnimationFrame(animateStream);
  }, [canvasRef, createParticle, drawParticle, updateParticle]);
  
  // Start the data stream animation
  const startStream = useCallback(() => {
    if (!canvasRef.current || streamRef.current.active) return;
    
    // Initialize canvas
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    
    // Reset particles
    streamRef.current.particles = [];
    
    // Initialize with some particles
    const initialParticles = Math.max(5, Math.floor(configRef.current.density / 20));
    
    for (let i = 0; i < initialParticles; i++) {
      streamRef.current.particles.push(
        createParticle(canvas, configRef.current)
      );
    }
    
    // Start animation
    streamRef.current.active = true;
    streamRef.current.lastFrameTime = performance.now();
    streamRef.current.animationId = requestAnimationFrame(animateStream);
  }, [canvasRef, createParticle, animateStream]);
  
  // Stop the data stream animation
  const stopStream = useCallback(() => {
    if (!streamRef.current.active) return;
    
    streamRef.current.active = false;
    
    if (streamRef.current.animationId) {
      cancelAnimationFrame(streamRef.current.animationId);
      streamRef.current.animationId = null;
    }
  }, []);
  
  // Update stream configuration
  const updateStreamConfig = useCallback((newConfig) => {
    configRef.current = {
      ...configRef.current,
      ...newConfig
    };
  }, []);
  
  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (streamRef.current.animationId) {
        cancelAnimationFrame(streamRef.current.animationId);
      }
    };
  }, []);
  
  return {
    startStream,
    stopStream,
    updateStreamConfig
  };
};

export default useDataStream;
</file>

<file path="frontend/src/hooks/useGlitch.js">
import { useCallback, useEffect, useRef } from 'react';

/**
 * A custom hook to create cyberpunk-style glitch effects on elements
 * 
 * @param {React.RefObject} elementRef - React ref object pointing to the element to apply glitch effect
 * @param {Object} options - Configuration options for the glitch effect
 * @param {number} options.intensity - Intensity of the glitch (1-10)
 * @param {number} options.duration - Duration of the glitch effect in ms
 * @param {boolean} options.continuousGlitch - Whether the glitch should continue indefinitely
 * @param {string} options.targetType - What to glitch: 'text', 'element', or 'image'
 * @returns {Object} - Methods to control the glitch effect
 */
export const useGlitch = (
  elementRef,
  {
    intensity = 5,
    duration = 1000,
    continuousGlitch = false,
    targetType = 'auto'
  } = {}
) => {
  const intervalRef = useRef(null);
  const timeoutRef = useRef(null);
  const isActiveRef = useRef(false);
  
  // Normalize intensity to a value between 1 and 10
  const normalizedIntensity = Math.min(10, Math.max(1, intensity));
  
  // Clean up any existing intervals and timeouts
  const cleanUp = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
    
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    
    // Reset element styles if glitch is not active anymore
    if (!isActiveRef.current && elementRef.current) {
      const element = elementRef.current;
      
      // Reset text element
      if (targetType === 'text' || 
         (targetType === 'auto' && (!element.childElementCount || element.childElementCount === 1))) {
        element.style.transform = '';
        element.style.textShadow = '';
        element.style.color = '';
      }
      
      // Reset image element
      if (targetType === 'image' || 
         (targetType === 'auto' && (element.tagName === 'IMG' || element.querySelector('img')))) {
        const img = element.tagName === 'IMG' ? element : element.querySelector('img');
        if (img) {
          img.style.transform = '';
          img.style.filter = '';
          img.style.opacity = '';
        }
      }
      
      // Reset element styles
      element.style.clipPath = '';
    }
  }, [elementRef, targetType]);
  
  // Apply a single glitch frame
  const applyGlitchFrame = useCallback(() => {
    if (!elementRef.current) return;
    
    const element = elementRef.current;
    
    // Determine target type if auto
    let effectiveType = targetType;
    if (targetType === 'auto') {
      if (element.tagName === 'IMG' || element.querySelector('img')) {
        effectiveType = 'image';
      } else if (!element.childElementCount || element.childElementCount === 1) {
        effectiveType = 'text';
      } else {
        effectiveType = 'element';
      }
    }
    
    // Apply appropriate glitch effect based on target type
    switch (effectiveType) {
      case 'text': {
        // Text glitch effects
        const glitchChance = normalizedIntensity / 10;
        
        if (Math.random() < glitchChance) {
          // Apply RGB shift
          const shiftX = Math.random() * normalizedIntensity - normalizedIntensity / 2;
          const shiftY = Math.random() * normalizedIntensity - normalizedIntensity / 2;
          
          element.style.textShadow = `
            ${shiftX}px 0 1px rgba(255, 0, 0, 0.7),
            ${-shiftX}px 0 1px rgba(0, 255, 255, 0.7),
            0 ${shiftY}px 1px rgba(0, 255, 0, 0.7)
          `;
        }
        
        if (Math.random() < glitchChance * 0.7) {
          // Apply skew transform
          const skewX = (Math.random() * normalizedIntensity - normalizedIntensity / 2) * 0.5;
          const skewY = (Math.random() * normalizedIntensity - normalizedIntensity / 2) * 0.5;
          
          element.style.transform = `skew(${skewX}deg, ${skewY}deg)`;
        } else {
          element.style.transform = '';
        }
        
        break;
      }
      
      case 'image': {
        // Image glitch effects
        const img = element.tagName === 'IMG' ? element : element.querySelector('img');
        if (!img) return;
        
        const glitchChance = normalizedIntensity / 10;
        
        if (Math.random() < glitchChance) {
          // Apply RGB shift and other filters
          const hueRotate = Math.floor(Math.random() * 360);
          const brightness = 0.8 + Math.random() * 0.4;
          const contrast = 0.8 + Math.random() * 0.4;
          
          img.style.filter = `
            hue-rotate(${hueRotate}deg)
            brightness(${brightness})
            contrast(${contrast})
          `;
          
          // Random displacement
          const translateX = (Math.random() * normalizedIntensity - normalizedIntensity / 2) * 0.5;
          const translateY = (Math.random() * normalizedIntensity - normalizedIntensity / 2) * 0.5;
          
          img.style.transform = `translate(${translateX}px, ${translateY}px)`;
        } else {
          img.style.filter = '';
          img.style.transform = '';
        }
        
        break;
      }
      
      case 'element':
      default: {
        // Element glitch effects
        const glitchChance = normalizedIntensity / 10;
        
        if (Math.random() < glitchChance) {
          // Apply clip-path glitch
          const top = Math.random() * 100;
          const bottom = 100 - Math.random() * 20;
          
          element.style.clipPath = `inset(${top}% 0 ${bottom}% 0)`;
        } else {
          element.style.clipPath = '';
        }
        
        if (Math.random() < glitchChance * 0.5) {
          // Apply transform glitch
          const translateX = (Math.random() * normalizedIntensity - normalizedIntensity / 2) * 0.5;
          
          element.style.transform = `translateX(${translateX}px)`;
        } else {
          element.style.transform = '';
        }
        
        break;
      }
    }
  }, [elementRef, normalizedIntensity, targetType]);
  
  // Reset the glitch effect
  const resetGlitch = useCallback(() => {
    cleanUp();
    isActiveRef.current = false;
    
    if (elementRef.current) {
      const element = elementRef.current;
      
      element.style.transform = '';
      element.style.textShadow = '';
      element.style.clipPath = '';
      element.style.filter = '';
      
      if (element.tagName === 'IMG' || element.querySelector('img')) {
        const img = element.tagName === 'IMG' ? element : element.querySelector('img');
        if (img) {
          img.style.transform = '';
          img.style.filter = '';
        }
      }
    }
  }, [cleanUp, elementRef]);
  
  // Start the glitch effect
  const startGlitch = useCallback((options = {}) => {
    // Merge default options with provided options
    const glitchOptions = {
      intensity: normalizedIntensity,
      duration: duration,
      continuousGlitch: continuousGlitch,
      ...options
    };
    
    // Clean up any existing glitch effects
    cleanUp();
    
    // Set active state
    isActiveRef.current = true;
    
    // Apply initial glitch
    applyGlitchFrame();
    
    // Set up interval for glitching
    const intervalTime = Math.max(30, 200 - glitchOptions.intensity * 15);
    intervalRef.current = setInterval(applyGlitchFrame, intervalTime);
    
    // If not continuous, set timeout to stop glitching
    if (!glitchOptions.continuousGlitch) {
      timeoutRef.current = setTimeout(() => {
        cleanUp();
        isActiveRef.current = false;
        
        // Reset styles smoothly
        if (elementRef.current) {
          elementRef.current.style.transition = 'all 0.3s ease';
          
          setTimeout(() => {
            if (elementRef.current) {
              elementRef.current.style.transform = '';
              elementRef.current.style.textShadow = '';
              elementRef.current.style.clipPath = '';
              
              // Reset transition after styles are reset
              setTimeout(() => {
                if (elementRef.current) {
                  elementRef.current.style.transition = '';
                }
              }, 300);
            }
          }, 50);
        }
      }, glitchOptions.duration);
    }
  }, [
    applyGlitchFrame,
    cleanUp,
    normalizedIntensity,
    duration,
    continuousGlitch,
    elementRef
  ]);
  
  // Stop the glitch effect
  const stopGlitch = useCallback(() => {
    cleanUp();
    isActiveRef.current = false;
    
    // Reset styles smoothly
    if (elementRef.current) {
      elementRef.current.style.transition = 'all 0.3s ease';
      
      setTimeout(() => {
        if (elementRef.current) {
          elementRef.current.style.transform = '';
          elementRef.current.style.textShadow = '';
          elementRef.current.style.clipPath = '';
          
          // Reset transition after styles are reset
          setTimeout(() => {
            if (elementRef.current) {
              elementRef.current.style.transition = '';
            }
          }, 300);
        }
      }, 50);
    }
  }, [cleanUp, elementRef]);
  
  // Clean up on unmount
  useEffect(() => {
    return () => cleanUp();
  }, [cleanUp]);
  
  // Start glitch if continuousGlitch is true on mount
  useEffect(() => {
    if (continuousGlitch) {
      startGlitch({ continuousGlitch: true });
    }
    
    return () => cleanUp();
  }, [continuousGlitch, startGlitch, cleanUp]);
  
  return {
    startGlitch,
    stopGlitch,
    resetGlitch,
    isGlitching: isActiveRef.current
  };
};

export default useGlitch;
</file>

<file path="frontend/src/hooks/useHolographicEffect.js">
import { useCallback, useEffect, useRef } from 'react';
import { useTheme } from '../contexts/ThemeContext';

/**
 * Custom hook for creating holographic effects on elements
 * 
 * @param {React.RefObject} elementRef - React ref to the element to apply effect to
 * @param {Object} config - Configuration options for the holographic effect
 * @returns {Object} - Methods to control the holographic effect
 */
export const useHolographicEffect = (
  elementRef,
  {
    color = null,
    intensity = 5,
    interactive = true,
    glowOnHover = true,
    perspective = 1000,
    hoverScale = 1.02,
    rotationFactor = 10
  } = {}
) => {
  const { theme } = useTheme();
  const configRef = useRef({
    color: color || (theme === 'dark' ? 'rgba(0, 255, 245, 0.8)' : 'rgba(77, 77, 255, 0.8)'),
    intensity: Math.min(10, Math.max(0, intensity)), // Clamp between 0-10
    interactive,
    glowOnHover,
    perspective,
    hoverScale,
    rotationFactor
  });
  
  const stateRef = useRef({
    active: false,
    mousePosition: { x: 0, y: 0 },
    isHovered: false,
    rotation: { x: 0, y: 0 },
    animationId: null
  });
  
  // Parse color to RGB values
  const parseColor = useCallback((color) => {
    // Handle CSS variables
    if (color.startsWith('var(')) {
      // Since we can't access computed styles here, use predefined values
      if (color.includes('accent-cyan')) {
        return { r: 0, g: 255, b: 245 };
      } else if (color.includes('accent-blue')) {
        return { r: 77, g: 77, b: 255 };
      } else if (color.includes('accent-magenta')) {
        return { r: 255, g: 61, b: 61 };
      }
      
      // Default fallback
      return { r: 0, g: 255, b: 245 };
    }
    
    // Handle hex colors
    if (color.startsWith('#')) {
      const hex = color.substring(1);
      return {
        r: parseInt(hex.substring(0, 2), 16),
        g: parseInt(hex.substring(2, 4), 16),
        b: parseInt(hex.substring(4, 6), 16)
      };
    }
    
    // Handle rgba colors
    if (color.startsWith('rgba(')) {
      const values = color.substring(5, color.length - 1).split(',');
      return {
        r: parseInt(values[0], 10),
        g: parseInt(values[1], 10),
        b: parseInt(values[2], 10)
      };
    }
    
    // Handle rgb colors
    if (color.startsWith('rgb(')) {
      const values = color.substring(4, color.length - 1).split(',');
      return {
        r: parseInt(values[0], 10),
        g: parseInt(values[1], 10),
        b: parseInt(values[2], 10)
      };
    }
    
    // Default fallback
    return { r: 0, g: 255, b: 245 };
  }, []);
  
  // Update element with holographic effect
  const updateHolographicEffect = useCallback(() => {
    if (!elementRef.current || !stateRef.current.active) return;
    
    const element = elementRef.current;
    const { interactive, rotationFactor, hoverScale, glowOnHover, intensity, color } = configRef.current;
    const { isHovered, mousePosition, rotation } = stateRef.current;
    
    if (!interactive) {
      // Reset all transformations if not interactive
      element.style.transform = '';
      return;
    }
    
    // Apply rotation based on mouse position
    if (isHovered) {
      // Target rotation based on mouse position
      const targetRotationX = -(mousePosition.y * rotationFactor);
      const targetRotationY = mousePosition.x * rotationFactor;
      
      // Smoothly interpolate current rotation towards target
      rotation.x += (targetRotationX - rotation.x) * 0.1;
      rotation.y += (targetRotationY - rotation.y) * 0.1;
    } else {
      // When not hovered, smoothly return to neutral position
      rotation.x *= 0.9;
      rotation.y *= 0.9;
    }
    
    // Apply transform with rotation and optional scale
    const scale = isHovered ? hoverScale : 1;
    element.style.transform = `
      perspective(${configRef.current.perspective}px)
      rotateX(${rotation.x}deg)
      rotateY(${rotation.y}deg)
      scale(${scale})
    `;
    
    // Apply glow effect on hover if enabled
    if (glowOnHover) {
      // Parse color to create glow
      const parsedColor = parseColor(color);
      const glowIntensity = isHovered ? intensity * 2 : intensity;
      const glowSize = isHovered ? 10 + glowIntensity * 2 : 5 + glowIntensity;
      
      element.style.boxShadow = isHovered
        ? `0 0 ${glowSize}px rgba(${parsedColor.r}, ${parsedColor.g}, ${parsedColor.b}, 0.8)`
        : `0 0 ${glowSize / 2}px rgba(${parsedColor.r}, ${parsedColor.g}, ${parsedColor.b}, 0.3)`;
      
      element.style.borderColor = color;
    }
    
    // Request next frame if still active
    if (stateRef.current.active) {
      stateRef.current.animationId = requestAnimationFrame(updateHolographicEffect);
    }
  }, [elementRef, parseColor]);
  
  // Handle mouse events for interactive holographic effect
  const setupMouseEvents = useCallback(() => {
    if (!elementRef.current || !configRef.current.interactive) return;
    
    const element = elementRef.current;
    
    const handleMouseMove = (e) => {
      if (!stateRef.current.active) return;
      
      const rect = element.getBoundingClientRect();
      
      // Calculate mouse position relative to element center (-1 to 1)
      stateRef.current.mousePosition = {
        x: ((e.clientX - rect.left) / rect.width - 0.5) * 2,
        y: ((e.clientY - rect.top) / rect.height - 0.5) * 2
      };
    };
    
    const handleMouseEnter = () => {
      if (!stateRef.current.active) return;
      
      stateRef.current.isHovered = true;
      
      // Add a CSS transition for smoother effect
      element.style.transition = 'transform 0.2s, box-shadow 0.5s';
      
      setTimeout(() => {
        if (element && stateRef.current.isHovered) {
          element.style.transition = 'box-shadow 0.5s';
        }
      }, 200);
    };
    
    const handleMouseLeave = () => {
      if (!stateRef.current.active) return;
      
      stateRef.current.isHovered = false;
      
      // Add a CSS transition for smoother effect
      element.style.transition = 'transform 0.5s, box-shadow 0.5s';
      
      setTimeout(() => {
        if (element && !stateRef.current.isHovered) {
          element.style.transition = '';
        }
      }, 500);
    };
    
    // Add event listeners
    element.addEventListener('mousemove', handleMouseMove);
    element.addEventListener('mouseenter', handleMouseEnter);
    element.addEventListener('mouseleave', handleMouseLeave);
    
    // Return cleanup function
    return () => {
      element.removeEventListener('mousemove', handleMouseMove);
      element.removeEventListener('mouseenter', handleMouseEnter);
      element.removeEventListener('mouseleave', handleMouseLeave);
    };
  }, [elementRef]);
  
  // Start holographic effect
  const startHolographicEffect = useCallback(() => {
    if (!elementRef.current || stateRef.current.active) return;
    
    stateRef.current.active = true;
    
    // Setup mouse events for interactive effect
    const cleanupMouseEvents = setupMouseEvents();
    
    // Start animation loop
    stateRef.current.animationId = requestAnimationFrame(updateHolographicEffect);
    
    // Return function to stop effect
    return () => {
      if (cleanupMouseEvents) cleanupMouseEvents();
      stopHolographicEffect();
    };
  }, [elementRef, setupMouseEvents, updateHolographicEffect]);
  
  // Stop holographic effect
  const stopHolographicEffect = useCallback(() => {
    if (!stateRef.current.active) return;
    
    stateRef.current.active = false;
    
    if (stateRef.current.animationId) {
      cancelAnimationFrame(stateRef.current.animationId);
      stateRef.current.animationId = null;
    }
    
    // Reset element styles if it still exists
    if (elementRef.current) {
      const element = elementRef.current;
      
      element.style.transform = '';
      element.style.transition = '';
    }
  }, [elementRef]);
  
  // Update holographic effect configuration
  const updateHolographicConfig = useCallback((newConfig) => {
    configRef.current = {
      ...configRef.current,
      ...newConfig,
      // Ensure intensity is clamped
      intensity: newConfig.intensity !== undefined 
        ? Math.min(10, Math.max(0, newConfig.intensity))
        : configRef.current.intensity
    };
  }, []);
  
  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (stateRef.current.animationId) {
        cancelAnimationFrame(stateRef.current.animationId);
      }
    };
  }, []);
  
  return {
    startHolographicEffect,
    stopHolographicEffect,
    updateHolographicConfig
  };
};

export default useHolographicEffect;
</file>

<file path="frontend/src/styles/animations.css">
/* animations.css - Collection of animation keyframes and animation utilities */

/* ------ BASIC TRANSITIONS ------ */

.fade-in {
  opacity: 0;
  animation: fadeIn 0.5s forwards;
}

.fade-out {
  opacity: 1;
  animation: fadeOut 0.5s forwards;
}

.slide-in-right {
  transform: translateX(100%);
  animation: slideInRight 0.5s forwards;
}

.slide-in-left {
  transform: translateX(-100%);
  animation: slideInLeft 0.5s forwards;
}

.slide-in-up {
  transform: translateY(100%);
  animation: slideInUp 0.5s forwards;
}

.slide-in-down {
  transform: translateY(-100%);
  animation: slideInDown 0.5s forwards;
}

/* ------ CYBER EFFECTS ------ */

.glitch-text {
  position: relative;
  display: inline-block;
}

.glitch-text[data-text]::before,
.glitch-text[data-text]::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.glitch-text[data-text]::before {
  left: 2px;
  text-shadow: -2px 0 var(--accent-magenta);
  animation: glitch-text-1 2s infinite linear alternate-reverse;
}

.glitch-text[data-text]::after {
  left: -2px;
  text-shadow: 2px 0 var(--accent-cyan);
  animation: glitch-text-2 3s infinite linear alternate-reverse;
}

.digital-noise {
  position: relative;
}

.digital-noise::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.1'/%3E%3C/svg%3E");
  opacity: 0.05;
  pointer-events: none;
  animation: digital-noise 0.5s steps(1) infinite;
}

.scan-line {
  position: relative;
  overflow: hidden;
}

.scan-line::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 2px;
  background-color: rgba(0, 255, 245, 0.5);
  box-shadow: 0 0 10px 2px var(--accent-cyan);
  animation: scan-line 2s linear infinite;
  opacity: 0.7;
  pointer-events: none;
  z-index: 9999;
}

.data-flow {
  position: relative;
  overflow: hidden;
}

.data-flow::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    90deg,
    transparent,
    transparent 20px,
    rgba(0, 255, 245, 0.05) 20px,
    rgba(0, 255, 245, 0.05) 40px
  );
  animation: data-flow 1s linear infinite;
  pointer-events: none;
}

.neon-pulse {
  animation: neon-pulse 2s ease-in-out infinite;
}

.pixelate-in {
  animation: pixelate-in 0.5s cubic-bezier(0.23, 1, 0.32, 1) forwards;
}

.pixelate-out {
  animation: pixelate-out 0.5s cubic-bezier(0.23, 1, 0.32, 1) forwards;
}

.crt-flicker {
  animation: crt-flicker 2s linear infinite;
}

.matrix-rain {
  overflow: hidden;
  position: relative;
}

.matrix-rain::before {
  content: '';
  position: absolute;
  top: -100%;
  left: 0;
  width: 100%;
  height: 200%;
  background: linear-gradient(0deg, transparent 0%, var(--accent-cyan) 75%, transparent 100%);
  opacity: 0.05;
  transform: rotate(45deg);
  animation: matrix-rain 3s linear infinite;
  pointer-events: none;
}

.cyber-blink {
  animation: cyber-blink 1s steps(2) infinite;
}

.glitch-image {
  position: relative;
  overflow: hidden;
}

.glitch-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.glitch-image::before,
.glitch-image::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: inherit;
  background-size: cover;
  background-position: center;
  opacity: 0.5;
  mix-blend-mode: hard-light;
}

.glitch-image::before {
  left: 5px;
  background-color: rgba(255, 0, 80, 0.1);
  animation: glitch-image-1 2.5s infinite linear alternate-reverse;
}

.glitch-image::after {
  left: -5px;
  background-color: rgba(0, 255, 255, 0.1);
  animation: glitch-image-2 3s infinite linear alternate-reverse;
}

.data-bits {
  position: relative;
}

.data-bits::after {
  content: attr(data-bits);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  font-family: var(--font-mono);
  font-size: 8px;
  color: var(--accent-cyan);
  opacity: 0.1;
  background-image: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 10px,
    var(--accent-cyan) 10px,
    var(--accent-cyan) 20px
  );
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: data-bits 30s linear infinite;
  pointer-events: none;
}

.terminal-cursor {
  display: inline-block;
  width: 8px;
  height: 1em;
  background-color: var(--accent-cyan);
  animation: terminal-cursor 1s step-end infinite;
}

.laser-beam {
  position: relative;
}

.laser-beam::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 1px;
  background-color: var(--accent-magenta);
  transform: translateY(-50%);
  animation: laser-beam 2s ease-in-out infinite;
  pointer-events: none;
}

.digital-circuitry {
  position: relative;
  overflow: hidden;
}

.digital-circuitry::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    linear-gradient(90deg, transparent 98%, var(--accent-cyan) 98%),
    linear-gradient(0deg, transparent 98%, var(--accent-cyan) 98%);
  background-size: 20px 20px;
  opacity: 0.1;
  animation: digital-circuitry 10s linear infinite;
  pointer-events: none;
}

/* ------ 3D EFFECTS ------ */

.hologram-effect {
  position: relative;
  transform-style: preserve-3d;
  perspective: 1000px;
}

.hologram-effect::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    135deg,
    transparent 0%,
    rgba(0, 255, 245, 0.05) 25%,
    rgba(0, 255, 245, 0.1) 50%,
    rgba(0, 255, 245, 0.05) 75%,
    transparent 100%
  );
  animation: hologram-rotate 3s linear infinite;
  pointer-events: none;
}

.cyber-rotate-3d {
  transform-style: preserve-3d;
  perspective: 1000px;
  animation: cyber-rotate-3d 15s linear infinite;
}

.floating-3d {
  transform-style: preserve-3d;
  perspective: 1000px;
  animation: floating-3d 4s ease-in-out infinite;
}

/* ------ PARTICLE EFFECTS ------ */

.particle-burst {
  position: relative;
}

.particle-burst::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 10px;
  height: 10px;
  background-color: var(--accent-cyan);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  opacity: 0;
  animation: particle-burst 2s ease-out infinite;
  pointer-events: none;
}

.data-stream {
  position: relative;
  overflow: hidden;
}

.data-stream::before {
  content: '';
  position: absolute;
  width: 2px;
  height: 100%;
  top: 0;
  left: 10%;
  background-color: var(--accent-cyan);
  opacity: 0.3;
  animation: data-stream 2s linear infinite;
  pointer-events: none;
}

.data-stream::after {
  content: '';
  position: absolute;
  width: 2px;
  height: 100%;
  top: 0;
  left: 20%;
  background-color: var(--accent-magenta);
  opacity: 0.3;
  animation: data-stream 3s linear infinite;
  pointer-events: none;
}

/* ------ ANIMATION DELAY UTILITIES ------ */

.delay-100 { animation-delay: 0.1s !important; }
.delay-200 { animation-delay: 0.2s !important; }
.delay-300 { animation-delay: 0.3s !important; }
.delay-400 { animation-delay: 0.4s !important; }
.delay-500 { animation-delay: 0.5s !important; }
.delay-750 { animation-delay: 0.75s !important; }
.delay-1000 { animation-delay: 1s !important; }
.delay-1500 { animation-delay: 1.5s !important; }
.delay-2000 { animation-delay: 2s !important; }

/* ------ ANIMATION DURATION UTILITIES ------ */

.duration-300 { animation-duration: 0.3s !important; }
.duration-500 { animation-duration: 0.5s !important; }
.duration-750 { animation-duration: 0.75s !important; }
.duration-1000 { animation-duration: 1s !important; }
.duration-1500 { animation-duration: 1.5s !important; }
.duration-2000 { animation-duration: 2s !important; }
.duration-3000 { animation-duration: 3s !important; }
.duration-5000 { animation-duration: 5s !important; }

/* ------ KEYFRAMES DEFINITIONS ------ */

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes slideInRight {
  from { transform: translateX(100%); }
  to { transform: translateX(0); }
}

@keyframes slideInLeft {
  from { transform: translateX(-100%); }
  to { transform: translateX(0); }
}

@keyframes slideInUp {
  from { transform: translateY(100%); }
  to { transform: translateY(0); }
}

@keyframes slideInDown {
  from { transform: translateY(-100%); }
  to { transform: translateY(0); }
}

@keyframes glitch-text-1 {
  0%, 100% { clip-path: inset(50% 0 30% 0); }
  20% { clip-path: inset(10% 0 60% 0); }
  40% { clip-path: inset(40% 0 40% 0); }
  60% { clip-path: inset(80% 0 5% 0); }
  80% { clip-path: inset(15% 0 80% 0); }
}

@keyframes glitch-text-2 {
  0%, 100% { clip-path: inset(30% 0 60% 0); }
  20% { clip-path: inset(60% 0 30% 0); }
  40% { clip-path: inset(10% 0 70% 0); }
  60% { clip-path: inset(70% 0 10% 0); }
  80% { clip-path: inset(20% 0 50% 0); }
}

@keyframes digital-noise {
  0%, 100% { transform: translate(0, 0); }
  10% { transform: translate(-5%, 3%); }
  20% { transform: translate(3%, -5%); }
  30% { transform: translate(5%, 2%); }
  40% { transform: translate(-3%, 5%); }
  50% { transform: translate(2%, -2%); }
  60% { transform: translate(-2%, 3%); }
  70% { transform: translate(5%, -1%); }
  80% { transform: translate(-4%, -4%); }
  90% { transform: translate(1%, 5%); }
}

@keyframes scan-line {
  0% { top: -10%; }
  100% { top: 110%; }
}

@keyframes data-flow {
  0% { transform: translateX(0); }
  100% { transform: translateX(-40px); }
}

@keyframes neon-pulse {
  0%, 100% { text-shadow: 0 0 5px var(--accent-cyan), 0 0 10px var(--accent-cyan); }
  50% { text-shadow: 0 0 10px var(--accent-cyan), 0 0 20px var(--accent-cyan), 0 0 30px var(--accent-cyan); }
}

@keyframes pixelate-in {
  0% { filter: blur(15px) brightness(1.5); }
  50% { filter: blur(5px) brightness(1.25); }
  100% { filter: blur(0) brightness(1); }
}

@keyframes pixelate-out {
  0% { filter: blur(0) brightness(1); }
  50% { filter: blur(5px) brightness(1.25); }
  100% { filter: blur(15px) brightness(1.5); }
}

@keyframes crt-flicker {
  0%, 100% { opacity: 1; }
  97%, 98% { opacity: 0.8; }
  99% { opacity: 0.6; }
}

@keyframes matrix-rain {
  0% { transform: translateY(-100%) rotate(45deg); }
  100% { transform: translateY(100%) rotate(45deg); }
}

@keyframes cyber-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

@keyframes glitch-image-1 {
  0%, 100% { clip-path: inset(40% 0 60% 0); transform: translate(-2px, 2px); }
  20% { clip-path: inset(30% 0 40% 0); transform: translate(1px, -1px); }
  40% { clip-path: inset(50% 0 20% 0); transform: translate(2px, 2px); }
  60% { clip-path: inset(10% 0 50% 0); transform: translate(-1px, -2px); }
  80% { clip-path: inset(60% 0 10% 0); transform: translate(2px, -1px); }
}

@keyframes glitch-image-2 {
  0%, 100% { clip-path: inset(60% 0 20% 0); transform: translate(2px, -2px); }
  20% { clip-path: inset(20% 0 60% 0); transform: translate(-2px, 1px); }
  40% { clip-path: inset(30% 0 70% 0); transform: translate(1px, 1px); }
  60% { clip-path: inset(70% 0 10% 0); transform: translate(-2px, -1px); }
  80% { clip-path: inset(10% 0 40% 0); transform: translate(2px, 2px); }
}

@keyframes data-bits {
  0% { background-position: 0 0; }
  100% { background-position: 0 1000px; }
}

@keyframes terminal-cursor {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

@keyframes laser-beam {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}

@keyframes digital-circuitry {
  0% { background-position: 0 0; }
  100% { background-position: 100% 100%; }
}

@keyframes hologram-rotate {
  0% { transform: rotateY(0deg); opacity: 0.2; }
  50% { opacity: 0.1; }
  100% { transform: rotateY(360deg); opacity: 0.2; }
}

@keyframes cyber-rotate-3d {
  0% { transform: rotateY(0deg) rotateX(10deg); }
  100% { transform: rotateY(360deg) rotateX(10deg); }
}

@keyframes floating-3d {
  0%, 100% { transform: translateY(0) rotateY(0deg); }
  25% { transform: translateY(-10px) rotateY(2deg); }
  50% { transform: translateY(0) rotateY(0deg); }
  75% { transform: translateY(10px) rotateY(-2deg); }
}

@keyframes particle-burst {
  0% { width: 0; height: 0; opacity: 0.7; }
  100% { width: 100px; height: 100px; opacity: 0; }
}

@keyframes data-stream {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100%); }
}
</file>

<file path="frontend/src/styles/base.css">
/* Base.css - Core styling for the cyberpunk portfolio */

:root {
  /* Color palette - dark theme (default) */
  --bg-primary: #050505;
  --bg-secondary: #0a0a0a;
  --bg-tertiary: #101010;
  --bg-overlay: rgba(10, 10, 10, 0.85);
  
  /* Accent colors */
  --accent-cyan: #00fff5;
  --accent-blue: #4d4dff;
  --accent-magenta: #ff3d3d;
  --accent-green: #00ff9f;
  --accent-purple: #d22aff;
  
  /* Functional colors */
  --text-primary: rgba(255, 255, 255, 0.95);
  --text-secondary: rgba(255, 255, 255, 0.7);
  --text-tertiary: rgba(255, 255, 255, 0.5);
  --border-primary: rgba(255, 255, 255, 0.1);
  --border-glow: rgba(0, 255, 245, 0.5);
  
  /* Button colors */
  --button-bg: rgba(0, 255, 245, 0.1);
  --button-hover: rgba(0, 255, 245, 0.2);
  --button-active: rgba(0, 255, 245, 0.3);
  
  /* Terminal colors */
  --terminal-bg: rgba(5, 5, 5, 0.95);
  --terminal-text: #33ff33;
  --terminal-cursor: #33ff33;
  
  /* Typography */
  --font-display: 'Orbitron', sans-serif;
  --font-body: 'Rajdhani', sans-serif;
  --font-mono: 'Fira Code', monospace;
  
  /* Spacing */
  --space-xs: 0.25rem;  /* 4px */
  --space-sm: 0.5rem;   /* 8px */
  --space-md: 1rem;     /* 16px */
  --space-lg: 1.5rem;   /* 24px */
  --space-xl: 2rem;     /* 32px */
  --space-xxl: 3rem;    /* 48px */
  
  /* Shadows */
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.5);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.5);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.5);
  --shadow-neon: 0 0 10px var(--accent-cyan), 0 0 20px rgba(0, 255, 245, 0.5);
  
  /* Z-index layers */
  --z-background: -10;
  --z-default: 1;
  --z-overlay: 10;
  --z-dropdown: 20;
  --z-modal: 30;
  --z-tooltip: 40;
  --z-top: 50;
  
  /* Transitions */
  --transition-fast: 0.2s;
  --transition-normal: 0.3s;
  --transition-slow: 0.5s;
  
  /* Borders */
  --border-radius-sm: 2px;
  --border-radius-md: 4px;
  --border-radius-lg: 8px;
  --border-radius-xl: 16px;
  
  /* Sizes */
  --header-height: 80px;
  --footer-height: 60px;
  --sidebar-width: 260px;
  
  /* Container max widths */
  --container-sm: 640px;
  --container-md: 960px;
  --container-lg: 1280px;
}

/* Light theme overrides */
.light-theme {
  --bg-primary: #f5f5f5;
  --bg-secondary: #e0e0e0;
  --bg-tertiary: #d0d0d0;
  --bg-overlay: rgba(230, 230, 230, 0.85);
  
  --text-primary: rgba(10, 10, 10, 0.95);
  --text-secondary: rgba(10, 10, 10, 0.7);
  --text-tertiary: rgba(10, 10, 10, 0.5);
  
  --border-primary: rgba(10, 10, 10, 0.1);
  --border-glow: rgba(0, 167, 215, 0.5);
  
  --button-bg: rgba(0, 167, 215, 0.1);
  --button-hover: rgba(0, 167, 215, 0.2);
  --button-active: rgba(0, 167, 215, 0.3);
  
  --terminal-bg: rgba(240, 240, 240, 0.95);
  --terminal-text: #006600;
  --terminal-cursor: #006600;
  
  --shadow-neon: 0 0 10px var(--accent-blue), 0 0 20px rgba(77, 77, 255, 0.5);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  font-family: var(--font-body);
  font-size: 16px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  overflow-x: hidden;
  line-height: 1.5;
  scroll-behavior: smooth;
}

/* Override default cursor with custom cyberpunk cursor */
body {
  cursor: none;
}

body::-webkit-scrollbar {
  width: 8px;
}

body::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

body::-webkit-scrollbar-thumb {
  background: var(--accent-cyan);
  border-radius: var(--border-radius-md);
}

body::-webkit-scrollbar-thumb:hover {
  background: var(--accent-blue);
}

#root {
  min-height: 100%;
  display: flex;
  flex-direction: column;
}

.app-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  position: relative;
}

.main-content {
  flex: 1;
  padding-top: var(--header-height);
  padding-bottom: var(--footer-height);
  width: 100%;
}

/* Custom cyberpunk cursor */
.cyber-cursor {
  position: fixed;
  width: 24px;
  height: 24px;
  border: 2px solid var(--accent-cyan);
  border-radius: 50%;
  pointer-events: none;
  z-index: var(--z-top);
  mix-blend-mode: difference;
  transform: translate(-50%, -50%);
  transition: width 0.2s, height 0.2s, border 0.2s;
}

.cyber-cursor.expand {
  width: 40px;
  height: 40px;
  border: 2px solid var(--accent-magenta);
  mix-blend-mode: exclusion;
}

.cyber-cursor-dot {
  position: fixed;
  width: 4px;
  height: 4px;
  background-color: var(--accent-cyan);
  border-radius: 50%;
  pointer-events: none;
  z-index: calc(var(--z-top) + 1);
  transform: translate(-50%, -50%);
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-display);
  font-weight: 700;
  line-height: 1.2;
  margin-bottom: var(--space-md);
  text-transform: uppercase;
  letter-spacing: 1px;
}

h1 {
  font-size: 2.5rem;
}

h2 {
  font-size: 2rem;
}

h3 {
  font-size: 1.75rem;
}

h4 {
  font-size: 1.5rem;
}

h5 {
  font-size: 1.25rem;
}

h6 {
  font-size: 1rem;
}

p {
  margin-bottom: var(--space-md);
  font-size: 1rem;
}

a {
  color: var(--accent-cyan);
  text-decoration: none;
  transition: color var(--transition-fast);
  position: relative;
  cursor: none;
}

a:hover {
  color: var(--accent-blue);
}

a::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 1px;
  bottom: -2px;
  left: 0;
  background-color: var(--accent-cyan);
  transform: scaleX(0);
  transform-origin: bottom right;
  transition: transform var(--transition-normal);
}

a:hover::after {
  transform: scaleX(1);
  transform-origin: bottom left;
}

/* Utility classes */
.container {
  width: 100%;
  max-width: var(--container-lg);
  margin: 0 auto;
  padding: 0 var(--space-md);
}

.container-sm {
  max-width: var(--container-sm);
}

.container-md {
  max-width: var(--container-md);
}

.section {
  padding: var(--space-xxl) 0;
}

.text-gradient {
  background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}

.neon-text {
  color: var(--accent-cyan);
  text-shadow: 0 0 5px var(--accent-cyan), 0 0 10px var(--accent-cyan);
}

.center-content {
  display: flex;
  justify-content: center;
  align-items: center;
}

.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}

/* Boot sequence styling */
#boot-sequence {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: black;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  transition: opacity 0.5s;
}

.boot-content {
  width: 80%;
  max-width: 500px;
  text-align: center;
}

.boot-logo {
  width: 100px;
  height: 100px;
  margin: 0 auto var(--space-xl);
  border: 2px solid var(--accent-cyan);
  position: relative;
  transform: rotate(45deg);
}

.boot-logo::before,
.boot-logo::after {
  content: '';
  position: absolute;
  background-color: var(--accent-magenta);
}

.boot-logo::before {
  width: 60%;
  height: 2px;
  top: 50%;
  left: 20%;
  transform: translateY(-50%);
}

.boot-logo::after {
  width: 2px;
  height: 60%;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
}

.boot-progress {
  width: 100%;
  height: 4px;
  background-color: #222;
  margin-bottom: var(--space-md);
  position: relative;
  overflow: hidden;
}

.boot-progress-bar {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
  width: 0%;
  transition: width 0.2s;
}

.boot-text {
  font-family: var(--font-mono);
  color: var(--accent-cyan);
  margin-bottom: var(--space-sm);
  letter-spacing: 1px;
  font-size: 1rem;
}

.boot-version {
  font-family: var(--font-mono);
  color: var(--text-tertiary);
  font-size: 0.8rem;
}

.glitch-text {
  animation: glitch 0.5s linear;
}

@keyframes glitch {
  0% {
    transform: translate(0);
  }
  20% {
    transform: translate(-2px, 2px);
  }
  40% {
    transform: translate(-2px, -2px);
  }
  60% {
    transform: translate(2px, 2px);
  }
  80% {
    transform: translate(2px, -2px);
  }
  100% {
    transform: translate(0);
  }
}
</file>

<file path="frontend/src/styles/cyberpunk.css">
/* Cyberpunk.css - Contains specialized cyberpunk-themed styling */

/* ------ NEON ELEMENTS ------ */

.neon-border {
  border: 1px solid var(--accent-cyan);
  box-shadow: 0 0 5px var(--accent-cyan), inset 0 0 5px var(--accent-cyan);
  border-radius: var(--border-radius-md);
  transition: all var(--transition-normal);
}

.neon-border:hover {
  box-shadow: 0 0 10px var(--accent-cyan), inset 0 0 10px var(--accent-cyan);
}

.neon-border-magenta {
  border: 1px solid var(--accent-magenta);
  box-shadow: 0 0 5px var(--accent-magenta), inset 0 0 5px var(--accent-magenta);
}

.neon-border-magenta:hover {
  box-shadow: 0 0 10px var(--accent-magenta), inset 0 0 10px var(--accent-magenta);
}

.neon-border-blue {
  border: 1px solid var(--accent-blue);
  box-shadow: 0 0 5px var(--accent-blue), inset 0 0 5px var(--accent-blue);
}

.neon-border-blue:hover {
  box-shadow: 0 0 10px var(--accent-blue), inset 0 0 10px var(--accent-blue);
}

.neon-text {
  color: var(--accent-cyan);
  text-shadow: 0 0 5px var(--accent-cyan);
  transition: all var(--transition-normal);
}

.neon-text:hover {
  text-shadow: 0 0 10px var(--accent-cyan), 0 0 20px var(--accent-cyan);
}

.neon-text-magenta {
  color: var(--accent-magenta);
  text-shadow: 0 0 5px var(--accent-magenta);
}

.neon-text-magenta:hover {
  text-shadow: 0 0 10px var(--accent-magenta), 0 0 20px var(--accent-magenta);
}

.neon-text-blue {
  color: var(--accent-blue);
  text-shadow: 0 0 5px var(--accent-blue);
}

.neon-text-blue:hover {
  text-shadow: 0 0 10px var(--accent-blue), 0 0 20px var(--accent-blue);
}

/* ------ CYBER BUTTONS ------ */

.cyber-button {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-sm) var(--space-md);
  min-width: 150px;
  background-color: transparent;
  color: var(--accent-cyan);
  font-family: var(--font-display);
  font-size: 1rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  border: 1px solid var(--accent-cyan);
  border-radius: var(--border-radius-sm);
  text-decoration: none;
  overflow: hidden;
  cursor: none;
  transition: all var(--transition-normal);
  z-index: 1;
}

.cyber-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(120deg, transparent, transparent 40%, var(--accent-cyan));
  opacity: 0.2;
  z-index: -1;
  transform: translateX(-100%) skewX(-15deg);
  transition: transform var(--transition-normal);
}

.cyber-button:hover {
  color: var(--bg-primary);
  text-shadow: none;
  box-shadow: 0 0 10px var(--accent-cyan);
}

.cyber-button:hover::before {
  transform: translateX(0) skewX(-15deg);
}

.cyber-button::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0;
  width: 30px;
  height: 1px;
  background-color: var(--accent-cyan);
  transition: width var(--transition-normal);
}

.cyber-button:hover::after {
  width: 100%;
}

.cyber-button--magenta {
  color: var(--accent-magenta);
  border-color: var(--accent-magenta);
}

.cyber-button--magenta::before {
  background: linear-gradient(120deg, transparent, transparent 40%, var(--accent-magenta));
}

.cyber-button--magenta:hover {
  box-shadow: 0 0 10px var(--accent-magenta);
}

.cyber-button--magenta::after {
  background-color: var(--accent-magenta);
}

.cyber-button--blue {
  color: var(--accent-blue);
  border-color: var(--accent-blue);
}

.cyber-button--blue::before {
  background: linear-gradient(120deg, transparent, transparent 40%, var(--accent-blue));
}

.cyber-button--blue:hover {
  box-shadow: 0 0 10px var(--accent-blue);
}

.cyber-button--blue::after {
  background-color: var(--accent-blue);
}

.cyber-button--small {
  padding: var(--space-xs) var(--space-sm);
  min-width: 100px;
  font-size: 0.8rem;
}

.cyber-button--large {
  padding: var(--space-md) var(--space-lg);
  min-width: 200px;
  font-size: 1.2rem;
}

/* ------ CYBER CARDS ------ */

.cyber-card {
  position: relative;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-md);
  padding: var(--space-lg);
  overflow: hidden;
  transition: all var(--transition-normal);
}

.cyber-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 4px;
  background: linear-gradient(90deg, var(--accent-cyan), var(--accent-magenta));
}

.cyber-card::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0;
  width: 30%;
  height: 30px;
  background-color: var(--bg-secondary);
  border-top: 1px solid var(--accent-cyan);
  border-left: 1px solid var(--accent-cyan);
  transition: all var(--transition-normal);
}

.cyber-card:hover {
  transform: translateY(-5px);
  box-shadow: var(--shadow-lg);
}

.cyber-card:hover::after {
  width: 40%;
  border-color: var(--accent-magenta);
}

.cyber-card__header {
  margin-bottom: var(--space-md);
  padding-bottom: var(--space-sm);
  border-bottom: 1px solid var(--border-primary);
  position: relative;
}

.cyber-card__title {
  font-family: var(--font-display);
  color: var(--accent-cyan);
  margin-bottom: var(--space-xs);
  position: relative;
  z-index: 1;
}

.cyber-card__subtitle {
  font-size: 0.9rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.cyber-card__content {
  position: relative;
  z-index: 1;
}

.cyber-card__footer {
  margin-top: var(--space-md);
  padding-top: var(--space-sm);
  border-top: 1px solid var(--border-primary);
  display: flex;
  justify-content: flex-end;
}

/* ------ HOLOGRAPHIC ELEMENTS ------ */

.holographic {
  position: relative;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: var(--border-radius-md);
  background-color: rgba(10, 10, 10, 0.5);
  backdrop-filter: blur(10px);
  overflow: hidden;
}

.holographic::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    135deg,
    transparent 0%,
    rgba(255, 255, 255, 0.1) 45%,
    rgba(255, 255, 255, 0.05) 50%,
    transparent 100%
  );
  transform: rotate(45deg);
  animation: holographic-sweep 3s linear infinite;
  pointer-events: none;
}

@keyframes holographic-sweep {
  0% {
    transform: rotate(45deg) translateY(-100%);
  }
  100% {
    transform: rotate(45deg) translateY(100%);
  }
}

.holographic-text {
  color: var(--text-primary);
  text-shadow: 0 0 5px var(--accent-cyan), 0 0 10px rgba(0, 255, 245, 0.5);
  position: relative;
  display: inline-block;
  overflow: hidden;
}

.holographic-text::before {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  color: var(--accent-cyan);
  filter: blur(3px);
  mix-blend-mode: screen;
  opacity: 0.7;
  z-index: -1;
}

.holographic-text::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    45deg,
    transparent 0%,
    rgba(0, 255, 245, 0.3) 30%,
    rgba(77, 77, 255, 0.3) 70%,
    transparent 100%
  );
  transform: rotate(30deg);
  animation: holographic-text-sweep 2s linear infinite;
  pointer-events: none;
  z-index: -1;
}

@keyframes holographic-text-sweep {
  0% {
    transform: rotate(30deg) translateX(-100%);
  }
  100% {
    transform: rotate(30deg) translateX(100%);
  }
}

/* ------ CIRCUIT PATTERNS ------ */

.circuit-bg {
  position: relative;
  overflow: hidden;
}

.circuit-bg::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    linear-gradient(to right, var(--border-primary) 1px, transparent 1px),
    linear-gradient(to bottom, var(--border-primary) 1px, transparent 1px);
  background-size: 20px 20px;
  opacity: 0.2;
  z-index: -1;
}

.circuit-bg::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    radial-gradient(circle, var(--accent-cyan) 1px, transparent 1px),
    radial-gradient(circle, var(--accent-magenta) 1px, transparent 1px);
  background-size: 60px 60px;
  background-position: 0 0, 30px 30px;
  opacity: 0.1;
  z-index: -1;
}

/* ------ TERMINAL STYLES ------ */

.cyber-terminal {
  background-color: var(--terminal-bg);
  border: 1px solid var(--accent-cyan);
  border-radius: var(--border-radius-md);
  padding: var(--space-md);
  font-family: var(--font-mono);
  color: var(--terminal-text);
  position: relative;
  overflow: hidden;
}

.cyber-terminal::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: repeating-linear-gradient(
    0deg,
    rgba(0, 0, 0, 0.15),
    rgba(0, 0, 0, 0.15) 1px,
    transparent 1px,
    transparent 2px
  );
  pointer-events: none;
  opacity: 0.5;
  z-index: 1;
}

.cyber-terminal__header {
  display: flex;
  align-items: center;
  margin-bottom: var(--space-md);
  padding-bottom: var(--space-sm);
  border-bottom: 1px solid rgba(0, 255, 51, 0.3);
}

.cyber-terminal__title {
  font-size: 1rem;
  color: var(--terminal-text);
  margin-right: auto;
}

.cyber-terminal__controls {
  display: flex;
  gap: var(--space-xs);
}

.cyber-terminal__control {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  cursor: pointer;
}

.cyber-terminal__control--close {
  background-color: var(--accent-magenta);
}

.cyber-terminal__control--minimize {
  background-color: var(--accent-cyan);
}

.cyber-terminal__control--maximize {
  background-color: var(--accent-green);
}

.cyber-terminal__content {
  position: relative;
  z-index: 2;
  max-height: 400px;
  overflow-y: auto;
}

.cyber-terminal__content::-webkit-scrollbar {
  width: 4px;
}

.cyber-terminal__content::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.3);
}

.cyber-terminal__content::-webkit-scrollbar-thumb {
  background: var(--terminal-text);
}

.cyber-terminal__line {
  display: flex;
  margin-bottom: var(--space-xs);
}

.cyber-terminal__prompt {
  color: var(--accent-cyan);
  margin-right: var(--space-xs);
}

.cyber-terminal__input {
  flex: 1;
  background-color: transparent;
  border: none;
  outline: none;
  color: var(--terminal-text);
  font-family: var(--font-mono);
  font-size: 1rem;
  caret-color: var(--terminal-cursor);
}

/* ------ DATA PANELS ------ */

.data-panel {
  position: relative;
  background-color: rgba(10, 10, 10, 0.6);
  border: 1px solid var(--accent-cyan);
  border-radius: var(--border-radius-md);
  padding: var(--space-md);
  overflow: hidden;
}

.data-panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 25px;
  background-color: rgba(0, 255, 245, 0.1);
  border-bottom: 1px solid var(--accent-cyan);
}

.data-panel::after {
  content: '';
  position: absolute;
  top: 5px;
  right: 5px;
  width: 15px;
  height: 15px;
  background-color: var(--accent-cyan);
  border-radius: 50%;
  box-shadow: 0 0 5px var(--accent-cyan);
  animation: data-panel-blink 2s infinite;
}

@keyframes data-panel-blink {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.data-panel__header {
  position: relative;
  z-index: 1;
  padding-top: var(--space-lg);
  margin-bottom: var(--space-md);
}

.data-panel__title {
  font-family: var(--font-display);
  color: var(--accent-cyan);
  font-size: 1.2rem;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.data-panel__content {
  position: relative;
  z-index: 1;
}

/* ------ GRID LAYOUTS ------ */

.cyber-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: var(--space-lg);
  width: 100%;
}

.cyber-grid--2col {
  grid-template-columns: repeat(2, 1fr);
}

.cyber-grid--3col {
  grid-template-columns: repeat(3, 1fr);
}

.cyber-grid--4col {
  grid-template-columns: repeat(4, 1fr);
}

@media (max-width: 1024px) {
  .cyber-grid--3col,
  .cyber-grid--4col {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  .cyber-grid,
  .cyber-grid--2col,
  .cyber-grid--3col,
  .cyber-grid--4col {
    grid-template-columns: 1fr;
  }
}

/* ------ FORM ELEMENTS ------ */

.cyber-input-group {
  position: relative;
  margin-bottom: var(--space-md);
}

.cyber-label {
  display: block;
  margin-bottom: var(--space-xs);
  font-family: var(--font-display);
  font-size: 0.9rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1px;
  transition: color var(--transition-fast);
}

.cyber-input {
  width: 100%;
  background-color: rgba(10, 10, 10, 0.3);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-sm);
  padding: var(--space-sm);
  color: var(--text-primary);
  font-family: var(--font-body);
  font-size: 1rem;
  transition: all var(--transition-normal);
}

.cyber-input:focus {
  border-color: var(--accent-cyan);
  outline: none;
  box-shadow: 0 0 5px rgba(0, 255, 245, 0.3);
}

.cyber-input-group:focus-within .cyber-label {
  color: var(--accent-cyan);
}

.cyber-textarea {
  min-height: 120px;
  resize: vertical;
}

.cyber-select {
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%2300fff5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right var(--space-sm) center;
  background-size: 16px;
  padding-right: var(--space-xl);
}

.cyber-checkbox-group {
  display: flex;
  align-items: center;
  margin-bottom: var(--space-md);
}

.cyber-checkbox {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

.cyber-checkbox-label {
  display: flex;
  align-items: center;
  position: relative;
  cursor: pointer;
  padding-left: 30px;
  user-select: none;
}

.cyber-checkbox-label::before {
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 20px;
  height: 20px;
  background-color: rgba(10, 10, 10, 0.3);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-sm);
  transition: all var(--transition-normal);
}

.cyber-checkbox:checked + .cyber-checkbox-label::before {
  background-color: var(--accent-cyan);
  border-color: var(--accent-cyan);
}

.cyber-checkbox-label::after {
  content: '';
  position: absolute;
  left: 6px;
  top: 50%;
  transform: translateY(-60%) rotate(45deg) scale(0);
  width: 5px;
  height: 10px;
  border: solid var(--bg-primary);
  border-width: 0 2px 2px 0;
  transition: all var(--transition-normal);
}

.cyber-checkbox:checked + .cyber-checkbox-label::after {
  transform: translateY(-60%) rotate(45deg) scale(1);
}

/* ------ ANIMATIONS AND EFFECTS ------ */

.pulse {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(0, 255, 245, 0.4);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(0, 255, 245, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(0, 255, 245, 0);
  }
}

.float {
  animation: float 3s ease-in-out infinite;
}

@keyframes float {
  0% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-10px);
  }
  100% {
    transform: translateY(0);
  }
}

.rotate {
  animation: rotate 10s linear infinite;
}

@keyframes rotate {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.glitch {
  position: relative;
  color: var(--text-primary);
}

.glitch::before,
.glitch::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.glitch::before {
  left: 2px;
  text-shadow: -1px 0 var(--accent-magenta);
  animation: glitch-animation-1 2s infinite linear alternate-reverse;
}

.glitch::after {
  left: -2px;
  text-shadow: 1px 0 var(--accent-cyan);
  animation: glitch-animation-2 3s infinite linear alternate-reverse;
}

@keyframes glitch-animation-1 {
  0%, 100% {
    clip-path: inset(80% 0 0 0);
  }
  20% {
    clip-path: inset(20% 0 80% 0);
  }
  40% {
    clip-path: inset(40% 0 40% 0);
  }
  60% {
    clip-path: inset(80% 0 20% 0);
  }
  80% {
    clip-path: inset(50% 0 30% 0);
  }
}

@keyframes glitch-animation-2 {
  0%, 100% {
    clip-path: inset(40% 0 60% 0);
  }
  20% {
    clip-path: inset(60% 0 20% 0);
  }
  40% {
    clip-path: inset(20% 0 60% 0);
  }
  60% {
    clip-path: inset(30% 0 50% 0);
  }
  80% {
    clip-path: inset(10% 0 90% 0);
  }
}

/* ------ LOADING ANIMATION ------ */

.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  width: 100%;
}

.cyber-loading {
  position: relative;
  width: 80px;
  height: 80px;
}

.cyber-loading div {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: 2px solid transparent;
  border-top-color: var(--accent-cyan);
  border-radius: 50%;
  animation: cyber-loading 1.5s linear infinite;
}

.cyber-loading div:nth-child(2) {
  border-top-color: var(--accent-magenta);
  animation-duration: 2.5s;
  animation-direction: reverse;
}

.cyber-loading div:nth-child(3) {
  border-top-color: var(--accent-blue);
  animation-duration: 3.5s;
}

@keyframes cyber-loading {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
</file>

<file path="frontend/src/styles/glitch.css">
/* glitch.css - Specialized CSS for various glitch effects */

/* ------ TEXT GLITCH EFFECTS ------ */

/* Basic text glitch */
.glitch-text {
  position: relative;
  display: inline-block;
  color: var(--text-primary);
}

.glitch-text::before,
.glitch-text::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.glitch-text::before {
  left: -2px;
  text-shadow: 2px 0 var(--accent-magenta);
  animation: glitch-text-1 3s infinite linear alternate-reverse;
}

.glitch-text::after {
  left: 2px;
  text-shadow: -2px 0 var(--accent-cyan);
  animation: glitch-text-2 2s infinite linear alternate-reverse;
}

/* Cyberpunk title glitch */
.cyber-glitch-title {
  position: relative;
  font-family: var(--font-display);
  font-size: 3rem;
  font-weight: 700;
  color: var(--text-primary);
  text-transform: uppercase;
  letter-spacing: 2px;
}

.cyber-glitch-title::before,
.cyber-glitch-title::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.cyber-glitch-title::before {
  left: -3px;
  text-shadow: 3px 0 var(--accent-magenta);
  animation: cyber-glitch-title-1 4s infinite linear alternate-reverse;
  background: linear-gradient(90deg, transparent 0%, rgba(255, 61, 61, 0.2) 50%, transparent 100%);
  background-size: 200% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  animation: cyber-glitch-title-bg 3s infinite linear;
}

.cyber-glitch-title::after {
  left: 3px;
  text-shadow: -3px 0 var(--accent-cyan);
  animation: cyber-glitch-title-2 5s infinite linear alternate-reverse;
  background: linear-gradient(90deg, transparent 0%, rgba(0, 255, 245, 0.2) 50%, transparent 100%);
  background-size: 200% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  animation: cyber-glitch-title-bg 4s infinite linear reverse;
}

/* RGB split glitch */
.rgb-split {
  position: relative;
  display: inline-block;
  color: var(--text-primary);
}

.rgb-split::before,
.rgb-split::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.5;
  mix-blend-mode: screen;
}

.rgb-split::before {
  left: -2px;
  color: #ff0000; /* Red */
  animation: rgb-split-1 2s infinite linear alternate-reverse;
}

.rgb-split::after {
  left: 2px;
  color: #00ffff; /* Cyan */
  animation: rgb-split-2 4s infinite linear alternate-reverse;
}

/* CRT flicker text */
.crt-text {
  position: relative;
  display: inline-block;
  animation: crt-text 0.8s ease-out infinite alternate;
}

.crt-text::before {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, 
    transparent 0%, 
    rgba(255, 255, 255, 0.1) 40%,
    rgba(255, 255, 255, 0.2) 50%,
    rgba(255, 255, 255, 0.1) 60%,
    transparent 100%);
  background-size: 100% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  animation: crt-scan 10s linear infinite;
}

/* Digital distortion */
.digital-distortion {
  position: relative;
  display: inline-block;
}

.digital-distortion::before {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    90deg,
    var(--text-primary) 0%,
    var(--text-primary) 5%,
    transparent 5.5%,
    transparent 10%
  );
  background-size: 200% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: digital-distortion 3s linear infinite;
}

/* Binary glitch */
.binary-glitch {
  position: relative;
  display: inline-block;
}

.binary-glitch::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.2);
  opacity: 0;
  animation: binary-glitch 3s steps(2) infinite;
}

/* Noise text */
.noise-text {
  position: relative;
  display: inline-block;
}

.noise-text::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  color: var(--text-primary);
  text-shadow: 1px 0 var(--accent-cyan), -1px 0 var(--accent-magenta);
  opacity: 0;
  animation: noise-text 0.2s linear infinite;
}

/* ------ IMAGE GLITCH EFFECTS ------ */

/* Basic image glitch */
.glitch-image {
  position: relative;
  overflow: hidden;
}

.glitch-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  position: relative;
  z-index: 1;
}

.glitch-image::before,
.glitch-image::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: inherit;
  background-position: center;
  background-size: cover;
  background-repeat: no-repeat;
  z-index: 2;
}

.glitch-image::before {
  left: 2px;
  background-color: rgba(255, 0, 80, 0.2);
  animation: glitch-image-1 4s infinite linear alternate;
  mix-blend-mode: hard-light;
}

.glitch-image::after {
  left: -2px;
  background-color: rgba(0, 255, 255, 0.2);
  animation: glitch-image-2 3s infinite linear alternate-reverse;
  mix-blend-mode: hard-light;
}

/* RGB split image */
.rgb-split-image {
  position: relative;
  overflow: hidden;
}

.rgb-split-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  position: relative;
  z-index: 1;
}

.rgb-split-image::before,
.rgb-split-image::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: inherit;
  background-position: center;
  background-size: cover;
  background-repeat: no-repeat;
  opacity: 0.5;
  z-index: 2;
}

.rgb-split-image::before {
  left: -5px;
  background-color: rgba(255, 0, 0, 0.5);
  mix-blend-mode: screen;
  animation: rgb-split-image-1 4s infinite linear alternate;
}

.rgb-split-image::after {
  left: 5px;
  background-color: rgba(0, 255, 255, 0.5);
  mix-blend-mode: screen;
  animation: rgb-split-image-2 3s infinite linear alternate-reverse;
}

/* Scan lines */
.scan-lines {
  position: relative;
  overflow: hidden;
}

.scan-lines::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.05) 2px,
    rgba(0, 0, 0, 0.05) 4px
  );
  pointer-events: none;
  z-index: 10;
}

/* CRT image effect */
.crt-image {
  position: relative;
  overflow: hidden;
}

.crt-image::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to bottom,
    transparent,
    rgba(20, 20, 20, 0.2) 50%,
    transparent
  );
  background-size: 100% 8px;
  z-index: 2;
  pointer-events: none;
}

.crt-image::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(
    circle at center,
    transparent 30%,
    rgba(0, 0, 0, 0.3) 100%
  );
  z-index: 3;
  mix-blend-mode: overlay;
  pointer-events: none;
}

/* Digital noise */
.digital-noise-overlay {
  position: relative;
}

.digital-noise-overlay::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 800 800' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.1'/%3E%3C/svg%3E");
  opacity: 0.08;
  z-index: 5;
  pointer-events: none;
  animation: digital-noise-overlay 0.2s steps(2) infinite;
}

/* VHS glitch */
.vhs-glitch {
  position: relative;
  overflow: hidden;
}

.vhs-glitch::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    to bottom,
    transparent,
    transparent 2px,
    rgba(255, 255, 255, 0.04) 3px,
    rgba(255, 255, 255, 0.04) 3px
  );
  z-index: 2;
  pointer-events: none;
}

.vhs-glitch::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to bottom,
    rgba(255, 0, 0, 0.05),
    rgba(0, 255, 0, 0.05),
    rgba(0, 0, 255, 0.05)
  );
  z-index: 3;
  mix-blend-mode: screen;
  pointer-events: none;
  animation: vhs-glitch 6s linear infinite alternate;
}

/* ------ KEYFRAMES DEFINITIONS ------ */

/* Text glitch keyframes */
@keyframes glitch-text-1 {
  0%, 100% { clip-path: inset(50% 0 30% 0); }
  20% { clip-path: inset(10% 0 60% 0); }
  40% { clip-path: inset(40% 0 40% 0); }
  60% { clip-path: inset(80% 0 5% 0); }
  80% { clip-path: inset(15% 0 80% 0); }
}

@keyframes glitch-text-2 {
  0%, 100% { clip-path: inset(30% 0 60% 0); }
  20% { clip-path: inset(60% 0 30% 0); }
  40% { clip-path: inset(10% 0 70% 0); }
  60% { clip-path: inset(70% 0 10% 0); }
  80% { clip-path: inset(20% 0 50% 0); }
}

@keyframes cyber-glitch-title-1 {
  0%, 100% { clip-path: inset(10% 0 60% 0); transform: translate(-2px, 2px); }
  20% { clip-path: inset(60% 0 0% 0); transform: translate(2px, -2px); }
  40% { clip-path: inset(10% 0 50% 0); transform: translate(2px, 2px); }
  60% { clip-path: inset(70% 0 5% 0); transform: translate(0, -2px); }
  80% { clip-path: inset(30% 0 30% 0); transform: translate(-2px, 0); }
}

@keyframes cyber-glitch-title-2 {
  0%, 100% { clip-path: inset(60% 0 30% 0); transform: translate(2px, -1px); }
  20% { clip-path: inset(30% 0 60% 0); transform: translate(-2px, 1px); }
  40% { clip-path: inset(20% 0 20% 0); transform: translate(0, 2px); }
  60% { clip-path: inset(5% 0 70% 0); transform: translate(-1px, -1px); }
  80% { clip-path: inset(40% 0 30% 0); transform: translate(2px, 0); }
}

@keyframes cyber-glitch-title-bg {
  0% { background-position: 0% 0; }
  100% { background-position: 200% 0; }
}

@keyframes rgb-split-1 {
  0%, 100% { transform: translate(-1px, 0); }
  25% { transform: translate(-2px, 1px); }
  50% { transform: translate(-3px, 0); }
  75% { transform: translate(-2px, -1px); }
}

@keyframes rgb-split-2 {
  0%, 100% { transform: translate(1px, 0); }
  25% { transform: translate(2px, -1px); }
  50% { transform: translate(3px, 0); }
  75% { transform: translate(2px, 1px); }
}

@keyframes crt-text {
  0%, 100% { opacity: 1; }
  10%, 90% { opacity: 0.9; }
  20%, 80% { opacity: 1; }
  30%, 70% { opacity: 0.9; }
  40%, 60% { opacity: 1; }
  50% { opacity: 0.9; }
}

@keyframes crt-scan {
  0% { background-position: 0 -100vh; }
  100% { background-position: 0 100vh; }
}

@keyframes digital-distortion {
  0% { background-position: 0% 0; }
  100% { background-position: 200% 0; }
}

@keyframes binary-glitch {
  0%, 100% { opacity: 0; }
  15%, 85% { opacity: 0; }
  16%, 84% { opacity: 0.3; }
  52%, 82% { opacity: 0; }
  53%, 81% { opacity: 0.3; }
}

@keyframes noise-text {
  0%, 100% { opacity: 0; }
  10%, 30%, 50%, 70%, 90% { opacity: 0.3; }
}

/* Image glitch keyframes */
@keyframes glitch-image-1 {
  0%, 100% { clip-path: inset(40% 0 30% 0); }
  20% { clip-path: inset(20% 0 60% 0); }
  40% { clip-path: inset(60% 0 30% 0); }
  60% { clip-path: inset(10% 0 50% 0); }
  80% { clip-path: inset(50% 0 10% 0); }
}

@keyframes glitch-image-2 {
  0%, 100% { clip-path: inset(20% 0 50% 0); }
  20% { clip-path: inset(30% 0 10% 0); }
  40% { clip-path: inset(10% 0 40% 0); }
  60% { clip-path: inset(50% 0 30% 0); }
  80% { clip-path: inset(40% 0 20% 0); }
}

@keyframes rgb-split-image-1 {
  0%, 100% { transform: translate(-5px, 0); }
  25% { transform: translate(-7px, 2px); }
  50% { transform: translate(-9px, 0); }
  75% { transform: translate(-7px, -2px); }
}

@keyframes rgb-split-image-2 {
  0%, 100% { transform: translate(5px, 0); }
  25% { transform: translate(7px, -2px); }
  50% { transform: translate(9px, 0); }
  75% { transform: translate(7px, 2px); }
}

@keyframes digital-noise-overlay {
  0%, 100% { transform: translate(0, 0); }
  25% { transform: translate(2px, -2px); }
  50% { transform: translate(-2px, 2px); }
  75% { transform: translate(2px, 2px); }
}

@keyframes vhs-glitch {
  0%, 100% { transform: translateY(0); }
  20% { transform: translateY(-2px); }
  40% { transform: translateY(2px); }
  60% { transform: translateY(-1px); }
  80% { transform: translateY(1px); }
}
</file>

<file path="frontend/src/styles/holographic.css">
/* holographic.css - Styles for holographic and 3D visual effects */

/* ------ HOLOGRAPHIC VARIABLES ------ */
:root {
  --holo-cyan: rgba(0, 255, 245, 0.7);
  --holo-cyan-transparent: rgba(0, 255, 245, 0.1);
  --holo-magenta: rgba(255, 61, 61, 0.7);
  --holo-magenta-transparent: rgba(255, 61, 61, 0.1);
  --holo-blue: rgba(77, 77, 255, 0.7);
  --holo-blue-transparent: rgba(77, 77, 255, 0.1);
  
  --holo-depth: 20px;
  --holo-angle: 15deg;
  --holo-perspective: 1000px;
  
  --holo-scan-speed: 4s;
  --holo-flicker-speed: 0.1s;
  --holo-rotate-speed: 15s;
  
  --holo-grid-size: 20px;
  --holo-grid-line: rgba(0, 255, 245, 0.2);
}

/* ------ HOLOGRAPHIC CONTAINER ------ */

/* Base holographic container */
.holographic-container {
  position: relative;
  transform-style: preserve-3d;
  perspective: var(--holo-perspective);
  overflow: hidden;
  background-color: rgba(10, 10, 10, 0.5);
  border: 1px solid var(--holo-cyan);
  box-shadow: 0 0 20px rgba(0, 255, 245, 0.2);
  transition: all 0.3s ease;
}

/* Container with 3D transform on hover */
.holographic-container.interactive {
  transition: transform 0.5s ease;
}

.holographic-container.interactive:hover {
  transform: 
    perspective(var(--holo-perspective)) 
    rotateX(calc(var(--holo-angle) * -1 * var(--y, 0))) 
    rotateY(calc(var(--holo-angle) * var(--x, 0)));
  box-shadow: 
    0 0 30px rgba(0, 255, 245, 0.3),
    0 0 60px rgba(0, 255, 245, 0.1);
}

/* Holographic grid background */
.holographic-grid {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    linear-gradient(to right, var(--holo-grid-line) 1px, transparent 1px),
    linear-gradient(to bottom, var(--holo-grid-line) 1px, transparent 1px);
  background-size: var(--holo-grid-size) var(--holo-grid-size);
  opacity: 0.3;
  pointer-events: none;
}

/* Holographic scan line effect */
.holographic-scan {
  position: relative;
  overflow: hidden;
}

.holographic-scan::after {
  content: '';
  position: absolute;
  top: -50%;
  left: 0;
  width: 100%;
  height: 200%;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    var(--holo-cyan) 50%,
    transparent 100%
  );
  opacity: 0.15;
  pointer-events: none;
  animation: holographic-scan var(--holo-scan-speed) linear infinite;
}

@keyframes holographic-scan {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100%); }
}

/* Holographic flicker effect */
.holographic-flicker {
  animation: holographic-flicker 4s linear infinite;
}

@keyframes holographic-flicker {
  0%, 100% { opacity: 1; }
  98.5% { opacity: 1; }
  99% { opacity: 0.5; }
  99.5% { opacity: 1; }
}

/* ------ HOLOGRAPHIC ELEMENTS ------ */

/* Holographic text */
.holographic-text {
  color: var(--text-primary);
  text-shadow: 
    0 0 5px var(--holo-cyan),
    0 0 10px var(--holo-cyan-transparent);
  position: relative;
  letter-spacing: 1px;
}

/* Text outline effect */
.holographic-text-outline {
  color: transparent;
  -webkit-text-stroke: 1px var(--holo-cyan);
  text-shadow: 0 0 10px var(--holo-cyan-transparent);
}

/* Holographic image */
.holographic-image {
  position: relative;
  overflow: hidden;
}

.holographic-image img {
  filter: brightness(1.2) contrast(1.1) saturate(0.8);
  mix-blend-mode: screen;
}

.holographic-image::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: 
    linear-gradient(45deg, 
      var(--holo-cyan-transparent), 
      transparent 40%, 
      var(--holo-magenta-transparent) 60%, 
      transparent);
  mix-blend-mode: screen;
  pointer-events: none;
}

.holographic-image::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    var(--holo-cyan-transparent) 50%,
    transparent 100%
  );
  animation: holographic-scan var(--holo-scan-speed) linear infinite;
  pointer-events: none;
}

/* Holographic card */
.holographic-card {
  background-color: rgba(10, 10, 10, 0.7);
  backdrop-filter: blur(5px);
  border: 1px solid var(--holo-cyan);
  box-shadow: 0 0 15px var(--holo-cyan-transparent);
  transform-style: preserve-3d;
  perspective: var(--holo-perspective);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
}

.holographic-card:hover {
  border-color: var(--holo-cyan);
  box-shadow: 
    0 0 20px var(--holo-cyan-transparent),
    0 0 40px var(--holo-cyan-transparent);
}

.holographic-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    135deg,
    transparent 0%,
    var(--holo-cyan-transparent) 50%,
    transparent 100%
  );
  pointer-events: none;
  transform: translateZ(10px);
}

/* ------ HOLOGRAPHIC 3D EFFECTS ------ */

/* Holographic floating effect */
.holographic-float {
  animation: holographic-float 4s ease-in-out infinite;
  transform-style: preserve-3d;
}

@keyframes holographic-float {
  0%, 100% { transform: translateY(0) rotateY(0deg); }
  25% { transform: translateY(-10px) rotateY(2deg); }
  50% { transform: translateY(0) rotateY(0deg); }
  75% { transform: translateY(10px) rotateY(-2deg); }
}

/* Holographic rotation effect */
.holographic-rotate {
  animation: holographic-rotate var(--holo-rotate-speed) linear infinite;
  transform-style: preserve-3d;
}

@keyframes holographic-rotate {
  0% { transform: rotateY(0deg) rotateX(10deg); }
  100% { transform: rotateY(360deg) rotateX(10deg); }
}

/* Holographic depth layers */
.holographic-layers {
  position: relative;
  transform-style: preserve-3d;
  perspective: var(--holo-perspective);
}

.holographic-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  backface-visibility: hidden;
}

.holographic-layer-1 { transform: translateZ(10px); }
.holographic-layer-2 { transform: translateZ(20px); }
.holographic-layer-3 { transform: translateZ(30px); }
.holographic-layer-4 { transform: translateZ(40px); }
.holographic-layer-5 { transform: translateZ(50px); }

/* Holographic parallax effect */
.holographic-parallax {
  position: relative;
  transform-style: preserve-3d;
  perspective: var(--holo-perspective);
  overflow: hidden;
}

.holographic-parallax-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  will-change: transform;
  transform-style: preserve-3d;
}

.holographic-parallax-layer-1 { transform: translateZ(-50px) scale(1.5); }
.holographic-parallax-layer-2 { transform: translateZ(-25px) scale(1.25); }
.holographic-parallax-layer-3 { transform: translateZ(0) scale(1); }
.holographic-parallax-layer-4 { transform: translateZ(25px) scale(0.75); }
.holographic-parallax-layer-5 { transform: translateZ(50px) scale(0.5); }

/* ------ HOLOGRAPHIC UI ELEMENTS ------ */

/* Holographic button */
.holographic-button {
  position: relative;
  background-color: rgba(0, 255, 245, 0.1);
  border: 1px solid var(--holo-cyan);
  color: var(--text-primary);
  padding: 0.6rem 1.5rem;
  font-family: var(--font-mono);
  letter-spacing: 1px;
  text-transform: uppercase;
  overflow: hidden;
  cursor: pointer;
  transform-style: preserve-3d;
  transition: all 0.3s ease;
}

.holographic-button:hover {
  background-color: rgba(0, 255, 245, 0.2);
  box-shadow: 
    0 0 15px var(--holo-cyan-transparent),
    0 0 30px var(--holo-cyan-transparent);
  transform: translateY(-2px);
}

.holographic-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(0, 255, 245, 0.3),
    transparent
  );
  transition: left 0.5s ease;
}

.holographic-button:hover::before {
  left: 100%;
}

.holographic-button::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    var(--holo-cyan-transparent) 50%,
    transparent 100%
  );
  opacity: 0;
  animation: holographic-scan var(--holo-scan-speed) linear infinite;
  transform: translateZ(5px);
  pointer-events: none;
}

/* Holographic input */
.holographic-input {
  background-color: rgba(10, 10, 10, 0.3);
  border: 1px solid var(--holo-cyan);
  color: var(--text-primary);
  padding: 0.6rem 1rem;
  font-family: var(--font-mono);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.holographic-input:focus {
  outline: none;
  border-color: var(--holo-cyan);
  box-shadow: 0 0 15px var(--holo-cyan-transparent);
  background-color: rgba(0, 255, 245, 0.05);
}

.holographic-input::after {
  content: '';
  position: absolute;
  top: -100%;
  left: 0;
  width: 100%;
  height: 200%;
  background: linear-gradient(
    to bottom,
    transparent 0%,
    var(--holo-cyan) 50%,
    transparent 100%
  );
  opacity: 0.1;
  animation: holographic-scan var(--holo-scan-speed) linear infinite;
  pointer-events: none;
}

/* Holographic progress bar */
.holographic-progress {
  height: 6px;
  background-color: rgba(10, 10, 10, 0.5);
  border: 1px solid var(--holo-cyan);
  position: relative;
  overflow: hidden;
}

.holographic-progress-bar {
  height: 100%;
  background-color: var(--holo-cyan);
  box-shadow: 0 0 10px var(--holo-cyan);
  position: relative;
  transition: width 0.3s ease;
}

.holographic-progress::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to right,
    transparent 0%,
    var(--holo-cyan) 50%,
    transparent 100%
  );
  opacity: 0.3;
  animation: holographic-scan-horizontal var(--holo-scan-speed) linear infinite;
  pointer-events: none;
}

@keyframes holographic-scan-horizontal {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* ------ HOLOGRAPHIC DATA VISUALIZATION ------ */

/* Data node point */
.holographic-node {
  width: 8px;
  height: 8px;
  background-color: var(--holo-cyan);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--holo-cyan);
  position: relative;
  transform-style: preserve-3d;
}

.holographic-node::before {
  content: '';
  position: absolute;
  width: 16px;
  height: 16px;
  top: -4px;
  left: -4px;
  border-radius: 50%;
  background-color: transparent;
  border: 1px solid var(--holo-cyan);
  opacity: 0.5;
  animation: holographic-node-pulse 2s ease-in-out infinite;
}

@keyframes holographic-node-pulse {
  0%, 100% { transform: scale(1); opacity: 0.5; }
  50% { transform: scale(1.5); opacity: 0; }
}

/* Data connection line */
.holographic-connection {
  position: absolute;
  background-color: var(--holo-cyan-transparent);
  box-shadow: 0 0 8px var(--holo-cyan);
  height: 2px;
  transform-origin: left center;
  transform-style: preserve-3d;
  animation: holographic-connection-pulse 2s ease-in-out infinite;
}

@keyframes holographic-connection-pulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 0.3; }
}

/* Connection with data flow */
.holographic-connection-flow {
  position: relative;
  overflow: hidden;
}

.holographic-connection-flow::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    to right,
    transparent,
    var(--holo-cyan),
    transparent
  );
  opacity: 0.8;
  animation: holographic-data-flow 2s linear infinite;
}

@keyframes holographic-data-flow {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* ------ HOLOGRAPHIC HUD ELEMENTS ------ */

/* Holographic panel */
.holographic-panel {
  background-color: rgba(10, 10, 10, 0.6);
  border: 1px solid var(--holo-cyan);
  box-shadow: 0 0 15px var(--holo-cyan-transparent);
  padding: 1.5rem;
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(5px);
  transform-style: preserve-3d;
}

/* Panel header */
.holographic-panel-header {
  border-bottom: 1px solid var(--holo-cyan);
  padding-bottom: 0.8rem;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

/* Panel corner decorations */
.holographic-panel::before,
.holographic-panel::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border-color: var(--holo-cyan);
  border-style: solid;
}

.holographic-panel::before {
  top: 5px;
  left: 5px;
  border-width: 2px 0 0 2px;
}

.holographic-panel::after {
  bottom: 5px;
  right: 5px;
  border-width: 0 2px 2px 0;
}

/* Holographic Badge */
.holographic-badge {
  display: inline-block;
  padding: 0.3rem 0.8rem;
  background-color: rgba(0, 255, 245, 0.1);
  border: 1px solid var(--holo-cyan);
  color: var(--holo-cyan);
  font-family: var(--font-mono);
  font-size: 0.8rem;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
}

.holographic-badge::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    45deg,
    transparent,
    var(--holo-cyan-transparent),
    transparent
  );
  opacity: 0.5;
  animation: holographic-badge-shine 2s ease-in-out infinite;
}

@keyframes holographic-badge-shine {
  0%, 100% { transform: translateX(-100%) rotate(45deg); }
  50% { transform: translateX(100%) rotate(45deg); }
}

/* Holographic Label */
.holographic-label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-family: var(--font-mono);
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.holographic-label::before {
  content: '';
  display: block;
  width: 8px;
  height: 8px;
  background-color: var(--holo-cyan);
  border-radius: 50%;
  box-shadow: 0 0 5px var(--holo-cyan);
}

/* Holographic Divider */
.holographic-divider {
  height: 1px;
  background: linear-gradient(
    to right,
    transparent,
    var(--holo-cyan),
    transparent
  );
  margin: 1.5rem 0;
  position: relative;
}

.holographic-divider::before {
  content: '';
  position: absolute;
  width: 6px;
  height: 6px;
  background-color: var(--holo-cyan);
  border-radius: 50%;
  top: -2.5px;
  left: 50%;
  transform: translateX(-50%);
  box-shadow: 0 0 5px var(--holo-cyan);
}

/* ------ HOLOGRAPHIC EFFECTS ------ */

/* Holographic glitch effect */
.holographic-glitch {
  position: relative;
  overflow: hidden;
}

.holographic-glitch::before {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: -2px;
  width: 100%;
  color: var(--holo-cyan);
  overflow: hidden;
  clip: rect(0, 900px, 0, 0);
  animation: holographic-glitch-effect-1 3s infinite linear alternate-reverse;
}

.holographic-glitch::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 2px;
  width: 100%;
  color: var(--holo-magenta);
  overflow: hidden;
  clip: rect(0, 900px, 0, 0);
  animation: holographic-glitch-effect-2 2s infinite linear alternate-reverse;
}

@keyframes holographic-glitch-effect-1 {
  0% { clip: rect(40px, 9999px, 44px, 0); }
  5% { clip: rect(94px, 9999px, 66px, 0); }
  10% { clip: rect(23px, 9999px, 36px, 0); }
  15% { clip: rect(15px, 9999px, 28px, 0); }
  20% { clip: rect(18px, 9999px, 98px, 0); }
  25% { clip: rect(71px, 9999px, 86px, 0); }
  30% { clip: rect(65px, 9999px, 24px, 0); }
  35% { clip: rect(88px, 9999px, 48px, 0); }
  40% { clip: rect(32px, 9999px, 74px, 0); }
  45% { clip: rect(73px, 9999px, 86px, 0); }
  50% { clip: rect(81px, 9999px, 49px, 0); }
  55% { clip: rect(44px, 9999px, 93px, 0); }
  60% { clip: rect(20px, 9999px, 78px, 0); }
  65% { clip: rect(15px, 9999px, 34px, 0); }
  70% { clip: rect(91px, 9999px, 10px, 0); }
  75% { clip: rect(46px, 9999px, 83px, 0); }
  80% { clip: rect(75px, 9999px, 37px, 0); }
  85% { clip: rect(49px, 9999px, 52px, 0); }
  90% { clip: rect(12px, 9999px, 23px, 0); }
  95% { clip: rect(41px, 9999px, 73px, 0); }
  100% { clip: rect(67px, 9999px, 35px, 0); }
}

@keyframes holographic-glitch-effect-2 {
  0% { clip: rect(77px, 9999px, 96px, 0); }
  5% { clip: rect(45px, 9999px, 13px, 0); }
  10% { clip: rect(64px, 9999px, 35px, 0); }
  15% { clip: rect(95px, 9999px, 46px, 0); }
  20% { clip: rect(23px, 9999px, 87px, 0); }
  25% { clip: rect(19px, 9999px, 32px, 0); }
  30% { clip: rect(57px, 9999px, 81px, 0); }
  35% { clip: rect(37px, 9999px, 25px, 0); }
  40% { clip: rect(48px, 9999px, 93px, 0); }
  45% { clip: rect(93px, 9999px, 67px, 0); }
  50% { clip: rect(35px, 9999px, 17px, 0); }
  55% { clip: rect(21px, 9999px, 74px, 0); }
  60% { clip: rect(38px, 9999px, 88px, 0); }
  65% { clip: rect(67px, 9999px, 19px, 0); }
  70% { clip: rect(14px, 9999px, 75px, 0); }
  75% { clip: rect(29px, 9999px, 35px, 0); }
  80% { clip: rect(85px, 9999px, 92px, 0); }
  85% { clip: rect(43px, 9999px, 27px, 0); }
  90% { clip: rect(10px, 9999px, 65px, 0); }
  95% { clip: rect(52px, 9999px, 39px, 0); }
  100% { clip: rect(86px, 9999px, 18px, 0); }
}

/* Holographic Noise Effect */
.holographic-noise {
  position: relative;
}

.holographic-noise::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
  pointer-events: none;
  z-index: 1;
  opacity: 0.1;
}

/* Holographic Terminal Cursor */
.holographic-cursor {
  display: inline-block;
  width: 10px;
  height: 1.2em;
  background-color: var(--holo-cyan);
  animation: holographic-cursor-blink 1s step-end infinite;
  margin-left: 2px;
  vertical-align: text-bottom;
}

@keyframes holographic-cursor-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

/* ------ HOLOGRAPHIC THEME VARIATIONS ------ */

/* Magenta variant */
.holographic-magenta {
  border-color: var(--holo-magenta);
  box-shadow: 0 0 15px var(--holo-magenta-transparent);
}

.holographic-magenta .holographic-grid {
  background-image: 
    linear-gradient(to right, rgba(255, 61, 61, 0.2) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255, 61, 61, 0.2) 1px, transparent 1px);
}

.holographic-magenta .holographic-scan::after {
  background: linear-gradient(
    to bottom,
    transparent 0%,
    var(--holo-magenta) 50%,
    transparent 100%
  );
}

.holographic-magenta .holographic-node {
  background-color: var(--holo-magenta);
  box-shadow: 0 0 10px var(--holo-magenta);
}

.holographic-magenta .holographic-node::before {
  border-color: var(--holo-magenta);
}

.holographic-magenta .holographic-connection {
  background-color: var(--holo-magenta-transparent);
  box-shadow: 0 0 8px var(--holo-magenta);
}

/* Blue variant */
.holographic-blue {
  border-color: var(--holo-blue);
  box-shadow: 0 0 15px var(--holo-blue-transparent);
}

.holographic-blue .holographic-grid {
  background-image: 
    linear-gradient(to right, rgba(77, 77, 255, 0.2) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(77, 77, 255, 0.2) 1px, transparent 1px);
}

.holographic-blue .holographic-scan::after {
  background: linear-gradient(
    to bottom,
    transparent 0%,
    var(--holo-blue) 50%,
    transparent 100%
  );
}

.holographic-blue .holographic-node {
  background-color: var(--holo-blue);
  box-shadow: 0 0 10px var(--holo-blue);
}

.holographic-blue .holographic-node::before {
  border-color: var(--holo-blue);
}

.holographic-blue .holographic-connection {
  background-color: var(--holo-blue-transparent);
  box-shadow: 0 0 8px var(--holo-blue);
}

/* ------ LIGHT THEME OVERRIDES ------ */

.light-theme .holographic-container {
  background-color: rgba(245, 245, 245, 0.5);
  border-color: var(--holo-blue);
  box-shadow: 0 0 20px rgba(77, 77, 255, 0.2);
}

.light-theme .holographic-container.interactive:hover {
  box-shadow: 
    0 0 30px rgba(77, 77, 255, 0.3),
    0 0 60px rgba(77, 77, 255, 0.1);
}

.light-theme .holographic-grid {
  background-image: 
    linear-gradient(to right, rgba(77, 77, 255, 0.2) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(77, 77, 255, 0.2) 1px, transparent 1px);
}

.light-theme .holographic-scan::after {
  background: linear-gradient(
    to bottom,
    transparent 0%,
    var(--holo-blue) 50%,
    transparent 100%
  );
}

.light-theme .holographic-text {
  text-shadow: 
    0 0 5px var(--holo-blue),
    0 0 10px var(--holo-blue-transparent);
}

.light-theme .holographic-text-outline {
  -webkit-text-stroke: 1px var(--holo-blue);
  text-shadow: 0 0 10px var(--holo-blue-transparent);
}

.light-theme .holographic-card {
  background-color: rgba(245, 245, 245, 0.7);
  border-color: var(--holo-blue);
  box-shadow: 0 0 15px var(--holo-blue-transparent);
}

.light-theme .holographic-card:hover {
  border-color: var(--holo-blue);
  box-shadow: 
    0 0 20px var(--holo-blue-transparent),
    0 0 40px var(--holo-blue-transparent);
}

.light-theme .holographic-panel {
  background-color: rgba(245, 245, 245, 0.6);
  border-color: var(--holo-blue);
  box-shadow: 0 0 15px var(--holo-blue-transparent);
}

.light-theme .holographic-panel-header {
  border-bottom-color: var(--holo-blue);
}

.light-theme .holographic-panel::before,
.light-theme .holographic-panel::after {
  border-color: var(--holo-blue);
}

.light-theme .holographic-node {
  background-color: var(--holo-blue);
  box-shadow: 0 0 10px var(--holo-blue);
}

.light-theme .holographic-node::before {
  border-color: var(--holo-blue);
}

.light-theme .holographic-connection {
  background-color: var(--holo-blue-transparent);
  box-shadow: 0 0 8px var(--holo-blue);
}

.light-theme .holographic-button {
  background-color: rgba(77, 77, 255, 0.1);
  border-color: var(--holo-blue);
}

.light-theme .holographic-button:hover {
  background-color: rgba(77, 77, 255, 0.2);
  box-shadow: 
    0 0 15px var(--holo-blue-transparent),
    0 0 30px var(--holo-blue-transparent);
}

.light-theme .holographic-button::before {
  background: linear-gradient(
    90deg,
    transparent,
    rgba(77, 77, 255, 0.3),
    transparent
  );
}

.light-theme .holographic-cursor {
  background-color: var(--holo-blue);
}

/* ------ RESPONSIVE ADJUSTMENTS ------ */

@media (max-width: 768px) {
  .holographic-panel {
    padding: 1rem;
  }
  
  .holographic-button {
    padding: 0.5rem 1.2rem;
    font-size: 0.9rem;
  }
  
  .holographic-panel::before,
  .holographic-panel::after {
    width: 15px;
    height: 15px;
  }
}

@media (max-width: 480px) {
  .holographic-layers,
  .holographic-parallax {
    perspective: 500px;
  }
  
  .holographic-container.interactive:hover {
    transform: none;
  }
  
  .holographic-panel::before,
  .holographic-panel::after {
    display: none;
  }
}
</file>

<file path="frontend/src/styles/neon.css">
/* neon.css - Styles for neon glow effects and related elements */

/* ------ NEON VARIABLES ------ */
:root {
  --neon-cyan: #00fff5;
  --neon-magenta: #ff3d3d;
  --neon-blue: #4d4dff;
  --neon-green: #00ff9f;
  --neon-purple: #d22aff;
  --neon-yellow: #ffcc00;
  
  --neon-glow-sm: 0 0 5px;
  --neon-glow-md: 0 0 10px;
  --neon-glow-lg: 0 0 20px;
  --neon-glow-xl: 0 0 30px;
  
  --neon-text-shadow-sm: 0 0 2px;
  --neon-text-shadow-md: 0 0 5px;
  --neon-text-shadow-lg: 0 0 10px;
  --neon-text-shadow-xl: 0 0 15px;
}

/* ------ NEON TEXT EFFECTS ------ */

/* Base neon text */
.neon-text {
  color: var(--neon-cyan);
  text-shadow: 
    var(--neon-text-shadow-sm) var(--neon-cyan),
    var(--neon-text-shadow-md) var(--neon-cyan);
  letter-spacing: 2px;
}

/* Color variations */
.neon-text-magenta {
  color: var(--neon-magenta);
  text-shadow: 
    var(--neon-text-shadow-sm) var(--neon-magenta),
    var(--neon-text-shadow-md) var(--neon-magenta);
}

.neon-text-blue {
  color: var(--neon-blue);
  text-shadow: 
    var(--neon-text-shadow-sm) var(--neon-blue),
    var(--neon-text-shadow-md) var(--neon-blue);
}

.neon-text-green {
  color: var(--neon-green);
  text-shadow: 
    var(--neon-text-shadow-sm) var(--neon-green),
    var(--neon-text-shadow-md) var(--neon-green);
}

.neon-text-purple {
  color: var(--neon-purple);
  text-shadow: 
    var(--neon-text-shadow-sm) var(--neon-purple),
    var(--neon-text-shadow-md) var(--neon-purple);
}

.neon-text-yellow {
  color: var(--neon-yellow);
  text-shadow: 
    var(--neon-text-shadow-sm) var(--neon-yellow),
    var(--neon-text-shadow-md) var(--neon-yellow);
}

/* Intensity variations */
.neon-text-bright {
  text-shadow: 
    var(--neon-text-shadow-md) currentColor,
    var(--neon-text-shadow-lg) currentColor;
}

.neon-text-intense {
  text-shadow: 
    var(--neon-text-shadow-md) currentColor,
    var(--neon-text-shadow-lg) currentColor,
    var(--neon-text-shadow-xl) currentColor;
}

/* Pulsing neon text animation */
.neon-text-pulse {
  animation: neon-text-pulse 2s ease-in-out infinite;
}

@keyframes neon-text-pulse {
  0%, 100% {
    text-shadow: 
      var(--neon-text-shadow-sm) currentColor,
      var(--neon-text-shadow-md) currentColor;
  }
  50% {
    text-shadow: 
      var(--neon-text-shadow-md) currentColor,
      var(--neon-text-shadow-lg) currentColor,
      var(--neon-text-shadow-xl) currentColor;
  }
}

/* Flickering neon text animation */
.neon-text-flicker {
  animation: neon-text-flicker 3s linear infinite;
}

@keyframes neon-text-flicker {
  0%, 30%, 31%, 60%, 65%, 100% {
    text-shadow: 
      var(--neon-text-shadow-sm) currentColor,
      var(--neon-text-shadow-md) currentColor;
  }
  
  30.5%, 31.5%, 64.5%, 65.5%, 66%, 66.5% {
    text-shadow: none;
  }
  
  5%, 50%, 75% {
    text-shadow: 
      var(--neon-text-shadow-md) currentColor,
      var(--neon-text-shadow-lg) currentColor;
  }
}

/* ------ NEON BORDERS ------ */

/* Basic neon border */
.neon-border {
  border: 1px solid var(--neon-cyan);
  box-shadow: 
    var(--neon-glow-sm) var(--neon-cyan),
    inset var(--neon-glow-sm) var(--neon-cyan);
}

/* Color variations */
.neon-border-magenta {
  border-color: var(--neon-magenta);
  box-shadow: 
    var(--neon-glow-sm) var(--neon-magenta),
    inset var(--neon-glow-sm) var(--neon-magenta);
}

.neon-border-blue {
  border-color: var(--neon-blue);
  box-shadow: 
    var(--neon-glow-sm) var(--neon-blue),
    inset var(--neon-glow-sm) var(--neon-blue);
}

.neon-border-green {
  border-color: var(--neon-green);
  box-shadow: 
    var(--neon-glow-sm) var(--neon-green),
    inset var(--neon-glow-sm) var(--neon-green);
}

.neon-border-purple {
  border-color: var(--neon-purple);
  box-shadow: 
    var(--neon-glow-sm) var(--neon-purple),
    inset var(--neon-glow-sm) var(--neon-purple);
}

.neon-border-yellow {
  border-color: var(--neon-yellow);
  box-shadow: 
    var(--neon-glow-sm) var(--neon-yellow),
    inset var(--neon-glow-sm) var(--neon-yellow);
}

/* Intensity variations */
.neon-border-bright {
  box-shadow: 
    var(--neon-glow-md) currentColor,
    inset var(--neon-glow-sm) currentColor;
}

.neon-border-intense {
  box-shadow: 
    var(--neon-glow-md) currentColor,
    var(--neon-glow-lg) currentColor,
    inset var(--neon-glow-sm) currentColor;
}

/* Pulsing neon border animation */
.neon-border-pulse {
  animation: neon-border-pulse 2s ease-in-out infinite;
}

@keyframes neon-border-pulse {
  0%, 100% {
    box-shadow: 
      var(--neon-glow-sm) currentColor,
      inset var(--neon-glow-sm) currentColor;
  }
  50% {
    box-shadow: 
      var(--neon-glow-md) currentColor,
      var(--neon-glow-lg) currentColor,
      inset var(--neon-glow-sm) currentColor;
  }
}

/* ------ NEON BUTTONS ------ */

/* Base neon button */
.neon-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  padding: 0.5rem 1.5rem;
  background-color: rgba(0, 0, 0, 0.2);
  border: 1px solid var(--neon-cyan);
  color: var(--neon-cyan);
  font-family: var(--font-mono);
  font-size: 0.9rem;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  overflow: hidden;
}

.neon-button:hover, .neon-button:focus {
  background-color: rgba(0, 255, 245, 0.2);
  box-shadow: 0 0 15px rgba(0, 255, 245, 0.5);
  transform: translateY(-2px);
}

.neon-button:active {
  transform: translateY(1px);
}

/* Button hover sweep effect */
.neon-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(0, 255, 245, 0.4),
    transparent
  );
  transition: left 0.5s ease;
}

.neon-button:hover::before {
  left: 100%;
}

/* Color variations */
.neon-button-magenta {
  border-color: var(--neon-magenta);
  color: var(--neon-magenta);
}

.neon-button-magenta:hover, .neon-button-magenta:focus {
  background-color: rgba(255, 61, 61, 0.2);
  box-shadow: 0 0 15px rgba(255, 61, 61, 0.5);
}

.neon-button-magenta::before {
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 61, 61, 0.4),
    transparent
  );
}

.neon-button-blue {
  border-color: var(--neon-blue);
  color: var(--neon-blue);
}

.neon-button-blue:hover, .neon-button-blue:focus {
  background-color: rgba(77, 77, 255, 0.2);
  box-shadow: 0 0 15px rgba(77, 77, 255, 0.5);
}

.neon-button-blue::before {
  background: linear-gradient(
    90deg,
    transparent,
    rgba(77, 77, 255, 0.4),
    transparent
  );
}

/* Size variations */
.neon-button-sm {
  padding: 0.3rem 1rem;
  font-size: 0.8rem;
}

.neon-button-lg {
  padding: 0.7rem 2rem;
  font-size: 1rem;
}

/* Disabled state */
.neon-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

/* ------ NEON INPUTS ------ */

/* Base neon input */
.neon-input {
  background-color: rgba(10, 10, 10, 0.3);
  border: 1px solid var(--neon-cyan);
  color: var(--text-primary);
  padding: 0.6rem 1rem;
  font-family: var(--font-mono);
  font-size: 0.9rem;
  transition: all 0.3s ease;
  width: 100%;
}

.neon-input:focus {
  outline: none;
  border-color: var(--neon-cyan);
  box-shadow: 0 0 10px rgba(0, 255, 245, 0.5);
}

.neon-input::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

/* Color variations */
.neon-input-magenta {
  border-color: var(--neon-magenta);
}

.neon-input-magenta:focus {
  border-color: var(--neon-magenta);
  box-shadow: 0 0 10px rgba(255, 61, 61, 0.5);
}

.neon-input-blue {
  border-color: var(--neon-blue);
}

.neon-input-blue:focus {
  border-color: var(--neon-blue);
  box-shadow: 0 0 10px rgba(77, 77, 255, 0.5);
}

/* ------ NEON LINKS ------ */

/* Base neon link */
.neon-link {
  color: var(--neon-cyan);
  text-decoration: none;
  position: relative;
  transition: all 0.3s ease;
}

.neon-link::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 1px;
  bottom: -2px;
  left: 0;
  background-color: var(--neon-cyan);
  box-shadow: 0 0 5px var(--neon-cyan);
  transform: scaleX(0);
  transform-origin: bottom right;
  transition: transform 0.3s ease;
}

.neon-link:hover, .neon-link:focus {
  text-shadow: 0 0 5px var(--neon-cyan);
}

.neon-link:hover::after, .neon-link:focus::after {
  transform: scaleX(1);
  transform-origin: bottom left;
}

/* Color variations */
.neon-link-magenta {
  color: var(--neon-magenta);
}

.neon-link-magenta::after {
  background-color: var(--neon-magenta);
  box-shadow: 0 0 5px var(--neon-magenta);
}

.neon-link-magenta:hover, .neon-link-magenta:focus {
  text-shadow: 0 0 5px var(--neon-magenta);
}

.neon-link-blue {
  color: var(--neon-blue);
}

.neon-link-blue::after {
  background-color: var(--neon-blue);
  box-shadow: 0 0 5px var(--neon-blue);
}

.neon-link-blue:hover, .neon-link-blue:focus {
  text-shadow: 0 0 5px var(--neon-blue);
}

/* ------ NEON BADGES ------ */

/* Base neon badge */
.neon-badge {
  display: inline-block;
  padding: 0.25rem 0.75rem;
  font-size: 0.8rem;
  font-family: var(--font-mono);
  background-color: rgba(0, 255, 245, 0.1);
  border: 1px solid var(--neon-cyan);
  color: var(--neon-cyan);
  border-radius: 2px;
  box-shadow: 0 0 5px rgba(0, 255, 245, 0.3);
}

/* Color variations */
.neon-badge-magenta {
  background-color: rgba(255, 61, 61, 0.1);
  border-color: var(--neon-magenta);
  color: var(--neon-magenta);
  box-shadow: 0 0 5px rgba(255, 61, 61, 0.3);
}

.neon-badge-blue {
  background-color: rgba(77, 77, 255, 0.1);
  border-color: var(--neon-blue);
  color: var(--neon-blue);
  box-shadow: 0 0 5px rgba(77, 77, 255, 0.3);
}

.neon-badge-green {
  background-color: rgba(0, 255, 159, 0.1);
  border-color: var(--neon-green);
  color: var(--neon-green);
  box-shadow: 0 0 5px rgba(0, 255, 159, 0.3);
}

.neon-badge-purple {
  background-color: rgba(210, 42, 255, 0.1);
  border-color: var(--neon-purple);
  color: var(--neon-purple);
  box-shadow: 0 0 5px rgba(210, 42, 255, 0.3);
}

/* ------ NEON CARDS ------ */

/* Base neon card */
.neon-card {
  background-color: rgba(10, 10, 10, 0.5);
  border: 1px solid var(--neon-cyan);
  box-shadow: 0 0 10px rgba(0, 255, 245, 0.3);
  padding: 1.5rem;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
}

.neon-card:hover {
  box-shadow: 0 0 20px rgba(0, 255, 245, 0.5);
}

/* Card corner accent */
.neon-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent);
}

.neon-card::after {
  content: '';
  position: absolute;
  top: 5px;
  right: 5px;
  width: 10px;
  height: 10px;
  border-top: 2px solid var(--neon-cyan);
  border-right: 2px solid var(--neon-cyan);
}

/* Color variations */
.neon-card-magenta {
  border-color: var(--neon-magenta);
  box-shadow: 0 0 10px rgba(255, 61, 61, 0.3);
}

.neon-card-magenta:hover {
  box-shadow: 0 0 20px rgba(255, 61, 61, 0.5);
}

.neon-card-magenta::before {
  background: linear-gradient(90deg, transparent, var(--neon-magenta), transparent);
}

.neon-card-magenta::after {
  border-top-color: var(--neon-magenta);
  border-right-color: var(--neon-magenta);
}

.neon-card-blue {
  border-color: var(--neon-blue);
  box-shadow: 0 0 10px rgba(77, 77, 255, 0.3);
}

.neon-card-blue:hover {
  box-shadow: 0 0 20px rgba(77, 77, 255, 0.5);
}

.neon-card-blue::before {
  background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
}

.neon-card-blue::after {
  border-top-color: var(--neon-blue);
  border-right-color: var(--neon-blue);
}

/* ------ NEON PROGRESS BARS ------ */

/* Base neon progress */
.neon-progress {
  width: 100%;
  height: 6px;
  background-color: rgba(10, 10, 10, 0.5);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
}

.neon-progress-bar {
  height: 100%;
  background-color: var(--neon-cyan);
  box-shadow: 0 0 8px var(--neon-cyan);
  transition: width 0.5s ease;
}

/* Color variations */
.neon-progress-magenta .neon-progress-bar {
  background-color: var(--neon-magenta);
  box-shadow: 0 0 8px var(--neon-magenta);
}

.neon-progress-blue .neon-progress-bar {
  background-color: var(--neon-blue);
  box-shadow: 0 0 8px var(--neon-blue);
}

.neon-progress-green .neon-progress-bar {
  background-color: var(--neon-green);
  box-shadow: 0 0 8px var(--neon-green);
}

/* Pulsing effect */
.neon-progress-pulse .neon-progress-bar {
  animation: neon-progress-pulse 2s ease-in-out infinite;
}

@keyframes neon-progress-pulse {
  0%, 100% {
    opacity: 1;
    box-shadow: 0 0 5px currentColor;
  }
  50% {
    opacity: 0.8;
    box-shadow: 0 0 15px currentColor;
  }
}

/* ------ NEON DIVIDERS ------ */

/* Base neon divider */
.neon-divider {
  border: none;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent);
  margin: 1.5rem 0;
  position: relative;
  box-shadow: 0 0 5px var(--neon-cyan);
}

/* Color variations */
.neon-divider-magenta {
  background: linear-gradient(90deg, transparent, var(--neon-magenta), transparent);
  box-shadow: 0 0 5px var(--neon-magenta);
}

.neon-divider-blue {
  background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
  box-shadow: 0 0 5px var(--neon-blue);
}

.neon-divider-green {
  background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
  box-shadow: 0 0 5px var(--neon-green);
}

/* Divider with dot accent */
.neon-divider-dot::before {
  content: '';
  position: absolute;
  width: 5px;
  height: 5px;
  background-color: currentColor;
  border-radius: 50%;
  top: -2px;
  left: 50%;
  transform: translateX(-50%);
  box-shadow: 0 0 5px currentColor;
}

/* ------ NEON ICONS ------ */

/* Base neon icon */
.neon-icon {
  color: var(--neon-cyan);
  filter: drop-shadow(0 0 3px var(--neon-cyan));
  transition: all 0.3s ease;
}

.neon-icon:hover {
  filter: drop-shadow(0 0 5px var(--neon-cyan));
  transform: scale(1.1);
}

/* Color variations */
.neon-icon-magenta {
  color: var(--neon-magenta);
  filter: drop-shadow(0 0 3px var(--neon-magenta));
}

.neon-icon-magenta:hover {
  filter: drop-shadow(0 0 5px var(--neon-magenta));
}

.neon-icon-blue {
  color: var(--neon-blue);
  filter: drop-shadow(0 0 3px var(--neon-blue));
}

.neon-icon-blue:hover {
  filter: drop-shadow(0 0 5px var(--neon-blue));
}

.neon-icon-green {
  color: var(--neon-green);
  filter: drop-shadow(0 0 3px var(--neon-green));
}

.neon-icon-green:hover {
  filter: drop-shadow(0 0 5px var(--neon-green));
}

/* Pulsing neon icon */
.neon-icon-pulse {
  animation: neon-icon-pulse 2s ease-in-out infinite;
}

@keyframes neon-icon-pulse {
  0%, 100% {
    filter: drop-shadow(0 0 3px currentColor);
  }
  50% {
    filter: drop-shadow(0 0 8px currentColor);
  }
}

/* ------ NEON OUTLINES ------ */

/* Base neon outline */
.neon-outline {
  position: relative;
}

.neon-outline::before {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  border: 1px solid var(--neon-cyan);
  box-shadow: 0 0 5px var(--neon-cyan);
  pointer-events: none;
  animation: neon-outline-pulse 2s ease-in-out infinite;
}

@keyframes neon-outline-pulse {
  0%, 100% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
}

/* Color variations */
.neon-outline-magenta::before {
  border-color: var(--neon-magenta);
  box-shadow: 0 0 5px var(--neon-magenta);
}

.neon-outline-blue::before {
  border-color: var(--neon-blue);
  box-shadow: 0 0 5px var(--neon-blue);
}

.neon-outline-green::before {
  border-color: var(--neon-green);
  box-shadow: 0 0 5px var(--neon-green);
}

/* ------ LIGHT THEME OVERRIDES ------ */

.light-theme .neon-text {
  color: var(--neon-blue);
  text-shadow: 
    var(--neon-text-shadow-sm) var(--neon-blue),
    var(--neon-text-shadow-md) var(--neon-blue);
}

.light-theme .neon-border {
  border-color: var(--neon-blue);
  box-shadow: 
    var(--neon-glow-sm) var(--neon-blue),
    inset var(--neon-glow-sm) var(--neon-blue);
}

.light-theme .neon-button {
  border-color: var(--neon-blue);
  color: var(--neon-blue);
}

.light-theme .neon-button:hover, .light-theme .neon-button:focus {
  background-color: rgba(77, 77, 255, 0.2);
  box-shadow: 0 0 15px rgba(77, 77, 255, 0.5);
}

.light-theme .neon-button::before {
  background: linear-gradient(
    90deg,
    transparent,
    rgba(77, 77, 255, 0.4),
    transparent
  );
}

.light-theme .neon-input {
  border-color: var(--neon-blue);
}

.light-theme .neon-input:focus {
  border-color: var(--neon-blue);
  box-shadow: 0 0 10px rgba(77, 77, 255, 0.5);
}

.light-theme .neon-link {
  color: var(--neon-blue);
}

.light-theme .neon-link::after {
  background-color: var(--neon-blue);
  box-shadow: 0 0 5px var(--neon-blue);
}

.light-theme .neon-link:hover, .light-theme .neon-link:focus {
  text-shadow: 0 0 5px var(--neon-blue);
}

.light-theme .neon-badge {
  background-color: rgba(77, 77, 255, 0.1);
  border-color: var(--neon-blue);
  color: var(--neon-blue);
  box-shadow: 0 0 5px rgba(77, 77, 255, 0.3);
}

.light-theme .neon-card {
  border-color: var(--neon-blue);
  box-shadow: 0 0 10px rgba(77, 77, 255, 0.3);
}

.light-theme .neon-card:hover {
  box-shadow: 0 0 20px rgba(77, 77, 255, 0.5);
}

.light-theme .neon-card::before {
  background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
}

.light-theme .neon-card::after {
  border-top-color: var(--neon-blue);
  border-right-color: var(--neon-blue);
}

.light-theme .neon-progress-bar {
  background-color: var(--neon-blue);
  box-shadow: 0 0 8px var(--neon-blue);
}

.light-theme .neon-divider {
  background: linear-gradient(90deg, transparent, var(--neon-blue), transparent);
  box-shadow: 0 0 5px var(--neon-blue);
}

.light-theme .neon-icon {
  color: var(--neon-blue);
  filter: drop-shadow(0 0 3px var(--neon-blue));
}

.light-theme .neon-icon:hover {
  filter: drop-shadow(0 0 5px var(--neon-blue));
}

.light-theme .neon-outline::before {
  border-color: var(--neon-blue);
  box-shadow: 0 0 5px var(--neon-blue);
}
</file>

<file path="frontend/src/styles/reset.css">
/* reset.css - CSS reset to provide consistent styling across browsers */

/* Box sizing border-box for all elements */
*,
*::before,
*::after {
  box-sizing: border-box;
}

/* Remove default margin and padding */
html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}

/* Display block for HTML5 elements */
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
menu,
nav,
section {
  display: block;
}

/* Set base line-height */
body {
  line-height: 1;
}

/* Remove list styles */
ol,
ul {
  list-style: none;
}

/* Reset quote styling */
blockquote,
q {
  quotes: none;
}

blockquote:before,
blockquote:after,
q:before,
q:after {
  content: '';
  content: none;
}

/* Reset table spacing */
table {
  border-collapse: collapse;
  border-spacing: 0;
}

/* Remove outline on focused elements */
:focus {
  outline: 0;
}

/* Remove text decoration on links */
a {
  text-decoration: none;
  color: inherit;
}

/* Set image max-width to 100% */
img {
  max-width: 100%;
  height: auto;
  display: block;
}

/* Reset button styles */
button {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  font: inherit;
  color: inherit;
}

/* Remove default styling for input and textarea */
input,
textarea,
select {
  font: inherit;
  color: inherit;
}

/* Remove default styling for buttons in Firefox */
button::-moz-focus-inner {
  border: 0;
  padding: 0;
}

/* Prevent text size adjustment on orientation change in iOS */
html {
  -webkit-text-size-adjust: 100%;
}

/* Remove default margin for fieldset */
fieldset {
  margin: 0;
  padding: 0;
  border: 0;
}

/* Remove default appearance for select */
select {
  appearance: none;
}

/* Make sure textarea only resizes vertically */
textarea {
  resize: vertical;
}

/* Standardize form elements */
button,
input,
optgroup,
select,
textarea {
  margin: 0;
}

/* Remove the clear button in search inputs */
input[type="search"]::-webkit-search-decoration,
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-results-button,
input[type="search"]::-webkit-search-results-decoration {
  display: none;
}

/* Set smooth scrolling */
html {
  scroll-behavior: smooth;
}

/* Make root use 10px for easier rem calculations */
html {
  font-size: 62.5%;
}

/* Set default body font size to 16px (1.6rem) */
body {
  font-size: 1.6rem;
}

/* Ensure full viewport height */
html, body {
  height: 100%;
}

/* Fix for browser inconsistencies with button and input */
button,
input,
select,
textarea {
  background-color: transparent;
  border: none;
}

/* Accessible hiding */
.visually-hidden {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

/* Reset default styles for details and summary */
details {
  display: block;
}

summary {
  display: list-item;
  cursor: pointer;
}

/* Correct display not defined in IE 9-11 */
audio,
canvas,
progress,
video {
  display: inline-block;
}

/* Add the correct display in iOS 4-7 */
audio:not([controls]) {
  display: none;
  height: 0;
}

/* Remove gaps in links underline in iOS 8+ and Safari 8+ */
a {
  -webkit-text-decoration-skip: objects;
}

/* Address Firefox 4+ setting line-height on input using !important */
input {
  line-height: normal;
}

/* Add the correct vertical alignment in Chrome, Firefox, and Opera */
progress {
  vertical-align: baseline;
}

/* Correct element display in IE */
[hidden],
template {
  display: none;
}

/* Improve element outlines in Firefox */
a:focus,
button:focus,
input:focus,
select:focus,
textarea:focus {
  outline: thin dotted;
}

/* Remove outline for non-keyboard focus */
[tabindex="-1"]:focus {
  outline: none;
}

/* Address appearance in browsers */
button,
select {
  text-transform: none;
}

/* Prevent sub and sup affecting line-height */
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/* Ensure consistency across browsers */
abbr[title] {
  border-bottom: none;
  text-decoration: underline;
  text-decoration: underline dotted;
}

/* Remove inner border and padding in Firefox */
button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

/* Correct style in Android 4.0+ */
@media screen and (-webkit-min-device-pixel-ratio: 0) {
  input {
    line-height: 1;
  }
}
</file>

<file path="frontend/src/styles/responsive.css">
/* responsive.css - Media queries and responsive design styles */

/* ==================== BREAKPOINTS ==================== */
/* 
  --mobile-sm: 320px   (Small mobile devices)
  --mobile: 480px      (Mobile devices)
  --tablet-sm: 600px   (Small tablets)
  --tablet: 768px      (Tablets)
  --laptop-sm: 960px   (Small laptops)
  --laptop: 1024px     (Laptops)
  --desktop-sm: 1280px (Small desktops)
  --desktop: 1440px    (Desktops)
  --desktop-lg: 1920px (Large desktops)
*/

/* ==================== UTILITY CLASSES ==================== */

/* Hide on specific screen sizes */
.hide-on-mobile {
  display: initial !important;
}

.show-on-mobile {
  display: none !important;
}

@media (max-width: 768px) {
  .hide-on-mobile {
    display: none !important;
  }
  
  .show-on-mobile {
    display: initial !important;
  }
}

.hide-on-tablet {
  display: initial !important;
}

.show-on-tablet {
  display: none !important;
}

@media (min-width: 481px) and (max-width: 1024px) {
  .hide-on-tablet {
    display: none !important;
  }
  
  .show-on-tablet {
    display: initial !important;
  }
}

.hide-on-desktop {
  display: initial !important;
}

.show-on-desktop {
  display: none !important;
}

@media (min-width: 1025px) {
  .hide-on-desktop {
    display: none !important;
  }
  
  .show-on-desktop {
    display: initial !important;
  }
}

/* ==================== CONTAINER RESPONSIVENESS ==================== */

.container {
  width: 100%;
  max-width: var(--container-lg);
  margin: 0 auto;
  padding: 0 var(--space-md);
}

@media (max-width: 1280px) {
  .container {
    max-width: var(--container-md);
  }
}

@media (max-width: 768px) {
  .container {
    max-width: var(--container-sm);
    padding: 0 var(--space-sm);
  }
}

/* ==================== TYPOGRAPHY RESPONSIVENESS ==================== */

@media (max-width: 1024px) {
  h1 {
    font-size: 2.2rem;
  }
  
  h2 {
    font-size: 1.8rem;
  }
  
  h3 {
    font-size: 1.5rem;
  }
  
  h4 {
    font-size: 1.3rem;
  }
  
  h5, h6 {
    font-size: 1.1rem;
  }
}

@media (max-width: 768px) {
  h1 {
    font-size: 2rem;
  }
  
  h2 {
    font-size: 1.6rem;
  }
  
  h3 {
    font-size: 1.4rem;
  }
  
  h4, h5, h6 {
    font-size: 1.2rem;
  }
  
  p {
    font-size: 0.95rem;
  }
}

@media (max-width: 480px) {
  h1 {
    font-size: 1.8rem;
  }
  
  h2 {
    font-size: 1.5rem;
  }
  
  h3, h4, h5, h6 {
    font-size: 1.2rem;
  }
  
  p {
    font-size: 0.9rem;
  }
}

/* ==================== CYBER BUTTON RESPONSIVENESS ==================== */

@media (max-width: 768px) {
  .cyber-button {
    padding: var(--space-xs) var(--space-sm);
    min-width: 130px;
    font-size: 0.9rem;
  }
  
  .cyber-button--large {
    padding: var(--space-sm) var(--space-md);
    min-width: 160px;
    font-size: 1rem;
  }
}

@media (max-width: 480px) {
  .cyber-button {
    width: 100%;
    text-align: center;
    justify-content: center;
  }
}

/* ==================== CYBER CARD RESPONSIVENESS ==================== */

@media (max-width: 768px) {
  .cyber-card {
    padding: var(--space-md);
  }
  
  .cyber-card::after {
    width: 25%;
    height: 20px;
  }
}

@media (max-width: 480px) {
  .cyber-card {
    padding: var(--space-sm);
  }
  
  .cyber-card::after {
    width: 20%;
    height: 15px;
  }
}

/* ==================== GRID RESPONSIVENESS ==================== */

@media (max-width: 1024px) {
  .cyber-grid--3col,
  .cyber-grid--4col {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  .cyber-grid,
  .cyber-grid--2col,
  .cyber-grid--3col,
  .cyber-grid--4col {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
}

/* ==================== FORM ELEMENTS RESPONSIVENESS ==================== */

@media (max-width: 768px) {
  .cyber-input {
    padding: var(--space-xs) var(--space-sm);
    font-size: 0.9rem;
  }
  
  .cyber-label {
    font-size: 0.8rem;
  }
  
  .cyber-textarea {
    min-height: 100px;
  }
}

/* ==================== SECTION SPACING RESPONSIVENESS ==================== */

@media (max-width: 1024px) {
  .section {
    padding: var(--space-xl) 0;
  }
}

@media (max-width: 768px) {
  .section {
    padding: var(--space-lg) 0;
  }
}

@media (max-width: 480px) {
  .section {
    padding: var(--space-md) 0;
  }
}

/* ==================== NAVIGATION RESPONSIVENESS ==================== */

@media (max-width: 768px) {
  :root {
    --header-height: 60px;
  }
  
  .nav-menu {
    width: 200px;
  }
  
  .menu-link {
    padding: 0.6rem 1.2rem;
  }
  
  .menu-title {
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  :root {
    --header-height: 50px;
  }
  
  .nav-menu {
    width: 100%;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
  }
}

/* ==================== FOOTER RESPONSIVENESS ==================== */

@media (max-width: 768px) {
  :root {
    --footer-height: 50px;
  }
  
  .footer-container {
    padding: 0 var(--space-sm);
  }
  
  .system-stats {
    display: none;
  }
  
  .footer-links {
    font-size: 0.7rem;
  }
  
  .copyright {
    font-size: 0.6rem;
  }
  
  .time-value,
  .date-value {
    font-size: 0.7rem;
  }
  
  .social-link {
    width: 20px;
    height: 20px;
  }
}

@media (max-width: 480px) {
  :root {
    --footer-height: auto;
  }
  
  .footer-container {
    flex-direction: column;
    padding: var(--space-xs) var(--space-sm);
  }
  
  .footer-left,
  .footer-center,
  .footer-right {
    width: 100%;
    justify-content: center;
    margin: var(--space-xs) 0;
  }
  
  .footer-right {
    align-items: center;
  }
  
  .time-display {
    text-align: center;
  }
  
  .digital-footer {
    position: relative;
  }
}

/* ==================== PERFORMANCE OPTIMIZATIONS ==================== */

/* Reduce animation complexity on mobile devices */
@media (max-width: 768px) {
  .hologram::before,
  .holographic-text::after,
  .data-panel::after,
  .cyber-button::before {
    animation-duration: 4s;
  }
  
  .float,
  .pulse,
  .rotate {
    animation-duration: 5s;
  }
  
  .neon-pulse {
    animation-duration: 3s;
  }
}

/* Disable some animations for users who prefer reduced motion */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.001ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.001ms !important;
    scroll-behavior: auto !important;
  }
}

/* ==================== TOUCH DEVICE OPTIMIZATIONS ==================== */

/* Increase tap target sizes for touch devices */
@media (hover: none) and (pointer: coarse) {
  .menu-link,
  .footer-link,
  .social-link,
  .cyber-button {
    padding: var(--space-sm) var(--space-md);
  }
  
  .cyber-checkbox-label::before {
    width: 24px;
    height: 24px;
  }
  
  .cyber-checkbox-label {
    padding-left: 36px;
  }
  
  /* Remove hover effects that don't work well on touch devices */
  .cyber-button:hover,
  .menu-link:hover,
  .footer-link:hover,
  .social-link:hover,
  .cyber-card:hover {
    transform: none;
  }
  
  /* Custom cursor not needed on touch devices */
  .cyber-cursor,
  .cyber-cursor-dot {
    display: none;
  }
  
  body {
    cursor: auto;
  }
  
  a, button, input, select, textarea, [role="button"] {
    cursor: auto;
  }
}

/* ==================== PRINT STYLES ==================== */

@media print {
  /* Reset background colors for print */
  body {
    background: white !important;
    color: black !important;
  }
  
  /* Hide elements not necessary for print */
  .holographic-nav,
  .digital-footer,
  .ambient-background,
  .cyber-button,
  video,
  audio,
  .terminal-section {
    display: none !important;
  }
  
  /* Reset text colors for print */
  h1, h2, h3, h4, h5, h6, p, li, a {
    color: black !important;
    text-shadow: none !important;
  }
  
  /* Ensure links show their URL */
  a::after {
    content: " (" attr(href) ")";
    font-size: 0.8em;
    font-weight: normal;
  }
  
  /* Simplify cards and panels */
  .cyber-card,
  .data-panel,
  .holographic {
    border: 1px solid #ccc !important;
    border-radius: 0 !important;
    box-shadow: none !important;
  }
  
  /* Ensure proper page breaks */
  h1, h2, h3, 
  .section {
    page-break-after: avoid;
    page-break-inside: avoid;
  }
  
  .main-content {
    padding-top: 0 !important;
    padding-bottom: 0 !important;
  }
}

/* ==================== HIGH CONTRAST MODE ==================== */

@media (prefers-contrast: high) {
  :root {
    --accent-cyan: #00ffff;
    --accent-magenta: #ff00ff;
    --accent-blue: #0000ff;
    --text-primary: #ffffff;
    --text-secondary: #dddddd;
    --bg-primary: #000000;
    --bg-secondary: #111111;
  }
  
  .holographic::before,
  .cyber-card::after,
  .cyber-button::before,
  .neon-border,
  .neon-text {
    opacity: 1 !important;
  }
  
  .cyber-button,
  .cyber-card,
  .data-panel,
  .holographic {
    border-width: 2px !important;
  }
}

/* ==================== DEVICE-SPECIFIC FIXES ==================== */

/* Fix for notched devices */
@supports (padding-top: env(safe-area-inset-top)) {
  .holographic-nav {
    padding-top: env(safe-area-inset-top);
  }
  
  .nav-menu {
    padding-top: calc(env(safe-area-inset-top) + var(--header-height));
  }
  
  .digital-footer {
    padding-bottom: env(safe-area-inset-bottom);
  }
}

/* Fix for legacy browsers */
@supports not (display: flex) {
  .hero-content,
  .footer-container,
  .nav-container {
    display: block;
  }
  
  .hero-left,
  .hero-right,
  .footer-left,
  .footer-center,
  .footer-right {
    display: inline-block;
    vertical-align: middle;
  }
}
</file>

<file path="frontend/src/utils/3dUtils.js">
/**
 * 3D Utility functions
 * Helper functions for Three.js and 3D effects in the portfolio
 */

import * as THREE from 'three';

/**
 * Create a cyberpunk city skyline geometry
 * @param {number} buildings - Number of buildings to generate
 * @param {number} width - Width of the city
 * @param {number} depth - Depth of the city
 * @returns {THREE.Group} - Group containing all building meshes
 */
export const createCyberpunkCity = (buildings = 50, width = 100, depth = 100) => {
  const city = new THREE.Group();
  
  // Ground grid
  const gridHelper = new THREE.GridHelper(
    Math.max(width, depth), 
    Math.max(width, depth) / 5,
    0x00fff5,
    0x00fff5
  );
  gridHelper.position.y = 0;
  gridHelper.material.opacity = 0.3;
  gridHelper.material.transparent = true;
  city.add(gridHelper);
  
  // Generate buildings
  for (let i = 0; i < buildings; i++) {
    // Random building dimensions and position
    const buildingWidth = 2 + Math.random() * 5;
    const buildingDepth = 2 + Math.random() * 5;
    const buildingHeight = 5 + Math.random() * 40;
    
    const posX = (Math.random() - 0.5) * width;
    const posZ = (Math.random() - 0.5) * depth;
    
    // Create building mesh
    const geometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
    
    // Determine if building should have neon effect
    const hasNeon = Math.random() > 0.7;
    
    // Create materials
    const material = new THREE.MeshPhongMaterial({
      color: 0x111111,
      emissive: hasNeon ? new THREE.Color(0x00fff5) : null,
      emissiveIntensity: hasNeon ? 0.5 : 0,
      flatShading: true
    });
    
    const building = new THREE.Mesh(geometry, material);
    building.position.set(posX, buildingHeight / 2, posZ);
    
    // Some buildings have neon edges
    if (hasNeon) {
      const edges = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({
        color: new THREE.Color(0x00fff5),
        linewidth: 1
      });
      const wireframe = new THREE.LineSegments(edges, edgeMaterial);
      building.add(wireframe);
    }
    
    // Add windows
    addBuildingWindows(building, buildingWidth, buildingHeight, buildingDepth);
    
    city.add(building);
  }
  
  return city;
};

/**
 * Add illuminated windows to building
 * @param {THREE.Mesh} building - Building mesh
 * @param {number} width - Building width
 * @param {number} height - Building height
 * @param {number} depth - Building depth
 */
const addBuildingWindows = (building, width, height, depth) => {
  // Window parameters
  const windowSize = 0.2;
  const windowSpacingX = windowSize * 2;
  const windowSpacingY = windowSize * 2;
  
  // Window geometry and material
  const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
  
  // Create windows for each side of the building
  for (let side = 0; side < 4; side++) {
    // Determine position offset based on which side
    let xOffset = 0;
    let zOffset = 0;
    let rotation = 0;
    
    switch (side) {
      case 0: // Front
        zOffset = depth / 2;
        break;
      case 1: // Right
        xOffset = width / 2;
        rotation = Math.PI / 2;
        break;
      case 2: // Back
        zOffset = -depth / 2;
        break;
      case 3: // Left
        xOffset = -width / 2;
        rotation = Math.PI / 2;
        break;
    }
    
    // Calculate available space for windows
    const availableWidth = side % 2 === 0 ? width : depth;
    const windowColumns = Math.floor((availableWidth - windowSize) / windowSpacingX);
    const windowRows = Math.floor((height - windowSize) / windowSpacingY);
    
    // Generate random windows
    for (let row = 0; row < windowRows; row++) {
      for (let col = 0; col < windowColumns; col++) {
        // Random chance for window to be lit
        if (Math.random() > 0.5) continue;
        
        // Calculate window position
        let windowX = -availableWidth / 2 + windowSize / 2 + col * windowSpacingX + windowSpacingX / 2;
        const windowY = -height / 2 + windowSize / 2 + row * windowSpacingY + windowSpacingY / 2;
        
        // Create window with random color
        const isNeon = Math.random() > 0.8;
        const windowColor = isNeon ? 
          new THREE.Color(0x00fff5) : 
          new THREE.Color(0xffff00).multiplyScalar(0.5 + Math.random() * 0.5);
        
        const windowMaterial = new THREE.MeshBasicMaterial({
          color: windowColor,
          transparent: true,
          opacity: 0.7 + Math.random() * 0.3
        });
        
        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
        
        // Position window based on side
        if (side % 2 === 0) {
          windowMesh.position.set(windowX, windowY, zOffset);
        } else {
          windowMesh.position.set(xOffset, windowY, windowX);
          windowMesh.rotation.y = rotation;
        }
        
        building.add(windowMesh);
      }
    }
  }
};

/**
 * Create flying data particles effect
 * @param {number} count - Number of particles
 * @param {number} range - Movement range
 * @returns {Object} - Particles data for Three.js
 */
export const createDataParticles = (count = 1000, range = 100) => {
  // Create geometry for particles
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const sizes = new Float32Array(count);
  const velocities = new Float32Array(count * 3);
  
  // Generate random particles
  for (let i = 0; i < count; i++) {
    const i3 = i * 3;
    
    // Random position within range
    positions[i3] = (Math.random() - 0.5) * range;
    positions[i3 + 1] = (Math.random() - 0.5) * range;
    positions[i3 + 2] = (Math.random() - 0.5) * range;
    
    // Random velocities
    velocities[i3] = (Math.random() - 0.5) * 0.2;
    velocities[i3 + 1] = (Math.random() - 0.5) * 0.2;
    velocities[i3 + 2] = (Math.random() - 0.5) * 0.2;
    
    // Random colors (cyan or magenta theme)
    const useAltColor = Math.random() > 0.8;
    
    if (useAltColor) {
      // Magenta theme
      colors[i3] = 1.0;
      colors[i3 + 1] = 0.2;
      colors[i3 + 2] = 0.5;
    } else {
      // Cyan theme
      colors[i3] = 0.0;
      colors[i3 + 1] = 1.0;
      colors[i3 + 2] = 0.96;
    }
    
    // Random sizes
    sizes[i] = 0.5 + Math.random() * 2.5;
  }
  
  // Set attributes
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  
  // Material for particles
  const material = new THREE.PointsMaterial({
    size: 1,
    transparent: true,
    opacity: 0.7,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    sizeAttenuation: true,
  });
  
  // Create points mesh
  const points = new THREE.Points(geometry, material);
  
  // Return data needed for animation updates
  return {
    mesh: points,
    velocities: velocities,
    update: (delta) => {
      const positions = points.geometry.attributes.position.array;
      
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        
        // Update position based on velocity
        positions[i3] += velocities[i3] * delta;
        positions[i3 + 1] += velocities[i3 + 1] * delta;
        positions[i3 + 2] += velocities[i3 + 2] * delta;
        
        // Wrap around if out of bounds
        if (Math.abs(positions[i3]) > range / 2) {
          positions[i3] *= -0.9;
        }
        if (Math.abs(positions[i3 + 1]) > range / 2) {
          positions[i3 + 1] *= -0.9;
        }
        if (Math.abs(positions[i3 + 2]) > range / 2) {
          positions[i3 + 2] *= -0.9;
        }
      }
      
      points.geometry.attributes.position.needsUpdate = true;
    }
  };
};

/**
 * Create a holographic shader material
 * @param {string} color - Base color for hologram (hex)
 * @param {number} opacity - Base opacity
 * @param {number} fresnelIntensity - Fresnel effect intensity
 * @returns {THREE.ShaderMaterial} - Holographic material
 */
export const createHolographicMaterial = (color = '#00fff5', opacity = 0.5, fresnelIntensity = 1.0) => {
  // Convert hex color to RGB array
  const threeColor = new THREE.Color(color);
  const colorArray = [threeColor.r, threeColor.g, threeColor.b];
  
  // Vertex shader with fresnel effect
  const vertexShader = `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    void main() {
      vPosition = position;
      vNormal = normalize(normalMatrix * normal);
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;
  
  // Fragment shader with scan lines and noise
  const fragmentShader = `
    uniform vec3 color;
    uniform float opacity;
    uniform float fresnelIntensity;
    uniform float time;
    
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    
    // Random function
    float random(vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
    }
    
    void main() {
      // Fresnel effect (opacity based on view angle)
      vec3 viewDirection = normalize(cameraPosition - vPosition);
      float fresnel = fresnelIntensity * pow(1.0 - dot(viewDirection, vNormal), 3.0);
      
      // Scan line effect
      float scanLine = step(0.5, fract(vPosition.y * 20.0 + time * 2.0));
      scanLine = mix(0.8, 1.0, scanLine);
      
      // Edge glow
      float edge = 1.0 - dot(vNormal, viewDirection);
      edge = pow(edge, 3.0) * 2.0;
      
      // Random noise
      float noise = random(vUv + vec2(time * 0.01, 0.0)) * 0.1;
      
      // Combine effects
      float alpha = opacity * (fresnel + edge) * scanLine + noise;
      
      // Output color
      gl_FragColor = vec4(color, alpha);
    }
  `;
  
  // Create shader material
  return new THREE.ShaderMaterial({
    uniforms: {
      color: { value: colorArray },
      opacity: { value: opacity },
      fresnelIntensity: { value: fresnelIntensity },
      time: { value: 0.0 }
    },
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    transparent: true,
    side: THREE.DoubleSide
  });
};

/**
 * Setup lighting for cyberpunk scene
 * @param {THREE.Scene} scene - Three.js scene
 */
export const setupCyberpunkLighting = (scene) => {
  // Ambient light for base illumination
  const ambientLight = new THREE.AmbientLight(0x111111, 0.2);
  scene.add(ambientLight);
  
  // Main directional light
  const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
  mainLight.position.set(20, 40, 20);
  mainLight.castShadow = true;
  
  // Configure shadow properties
  mainLight.shadow.mapSize.width = 1024;
  mainLight.shadow.mapSize.height = 1024;
  mainLight.shadow.camera.near = 1;
  mainLight.shadow.camera.far = 100;
  mainLight.shadow.camera.left = -30;
  mainLight.shadow.camer
</file>

<file path="frontend/src/utils/glitchUtils.js">
/**
 * Glitch effect utilities
 * Collection of functions to create and manage cyberpunk glitch effects
 */

// Random characters for text glitching
const GLITCH_CHARS = '!<>-_\\/[]{}â€”=+*^?#________';

/**
 * Apply a glitch effect to a text string
 * @param {string} text - Original text to glitch
 * @param {number} intensity - Glitch effect intensity (0-100)
 * @returns {string} - Glitched text
 */
export const glitchText = (text, intensity = 20) => {
  if (!text) return '';
  
  // Normalize intensity to 0-100 range
  const normalizedIntensity = Math.max(0, Math.min(100, intensity));
  
  // Calculate how many characters to glitch based on intensity
  const charsToGlitch = Math.ceil(text.length * (normalizedIntensity / 100));
  
  // Convert text to array for manipulation
  const textArray = text.split('');
  
  // Apply glitch to random characters
  for (let i = 0; i < charsToGlitch; i++) {
    const randomIndex = Math.floor(Math.random() * text.length);
    const randomChar = GLITCH_CHARS.charAt(Math.floor(Math.random() * GLITCH_CHARS.length));
    textArray[randomIndex] = randomChar;
  }
  
  return textArray.join('');
};

/**
 * Creates text with split RGB channels effect
 * @param {string} text - Text to apply effect to
 * @param {number} offset - Pixel offset for color channels
 * @returns {Object} - HTML/CSS objects for applying the effect
 */
export const createRGBSplitText = (text, offset = 2) => {
  return {
    container: {
      position: 'relative',
      display: 'inline-block'
    },
    original: {
      visibility: 'hidden'
    },
    red: {
      position: 'absolute',
      top: 0,
      left: -offset + 'px',
      color: 'rgba(255, 0, 0, 0.8)',
      zIndex: 1
    },
    green: {
      position: 'absolute',
      top: 0,
      left: 0,
      color: 'rgba(0, 255, 0, 0.8)',
      zIndex: 2
    },
    blue: {
      position: 'absolute',
      top: 0,
      left: offset + 'px',
      color: 'rgba(0, 0, 255, 0.8)',
      zIndex: 3
    }
  };
};

/**
 * Create a clip-path polygon for glitch effect
 * @param {number} complexity - Number of points in the polygon
 * @param {number} intensity - How severe the glitch distortion is
 * @returns {string} - CSS clip-path polygon function
 */
export const createGlitchClipPath = (complexity = 6, intensity = 10) => {
  // Generate clip-path polygon points
  const points = [];
  
  // Always include corners for base shape
  points.push('0% 0%'); // Top left
  
  // Add random points along top edge
  for (let i = 1; i < complexity - 1; i++) {
    const x = (i * (100 / (complexity - 1))).toFixed(1);
    const y = (Math.random() * intensity).toFixed(1);
    points.push(`${x}% ${y}%`);
  }
  
  points.push('100% 0%'); // Top right
  
  // Add random points along right edge
  for (let i = 1; i < complexity - 1; i++) {
    const y = (i * (100 / (complexity - 1))).toFixed(1);
    const x = (100 - Math.random() * intensity).toFixed(1);
    points.push(`${x}% ${y}%`);
  }
  
  points.push('100% 100%'); // Bottom right
  
  // Add random points along bottom edge
  for (let i = complexity - 2; i > 0; i--) {
    const x = (i * (100 / (complexity - 1))).toFixed(1);
    const y = (100 - Math.random() * intensity).toFixed(1);
    points.push(`${x}% ${y}%`);
  }
  
  points.push('0% 100%'); // Bottom left
  
  // Add random points along left edge
  for (let i = complexity - 2; i > 0; i--) {
    const y = (i * (100 / (complexity - 1))).toFixed(1);
    const x = (Math.random() * intensity).toFixed(1);
    points.push(`${x}% ${y}%`);
  }
  
  return `polygon(${points.join(', ')})`;
};

/**
 * Generate a glitch animation keyframes string
 * @param {number} steps - Number of keyframe steps
 * @param {number} intensity - Glitch intensity
 * @returns {string} - CSS keyframes definition
 */
export const generateGlitchKeyframes = (steps = 5, intensity = 10) => {
  let keyframes = '@keyframes glitch {\n';
  
  // Create keyframe steps
  for (let i = 0; i <= steps; i++) {
    const percent = i === steps ? 100 : Math.floor((i / steps) * 100);
    const translateX = (Math.random() * intensity * 2 - intensity).toFixed(1);
    const translateY = (Math.random() * intensity * 2 - intensity).toFixed(1);
    const scale = (0.95 + Math.random() * 0.1).toFixed(2);
    const rotate = (Math.random() * intensity / 5).toFixed(1);
    const clipPath = createGlitchClipPath(4, intensity);
    
    keyframes += `  ${percent}% {\n`;
    keyframes += `    transform: translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${rotate}deg);\n`;
    keyframes += `    clip-path: ${clipPath};\n`;
    keyframes += `  }\n`;
  }
  
  keyframes += '}';
  return keyframes;
};

/**
 * Apply scanline effect CSS properties
 * @param {number} lineHeight - Height of each scanline in pixels
 * @param {number} opacity - Opacity of scanlines
 * @returns {Object} - CSS properties for scanline effect
 */
export const getScanlineEffect = (lineHeight = 2, opacity = 0.2) => {
  return {
    position: 'relative',
    overflow: 'hidden',
    '&::after': {
      content: '""',
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      background: `repeating-linear-gradient(
        0deg,
        transparent,
        transparent ${lineHeight - 1}px,
        rgba(255, 255, 255, ${opacity}) ${lineHeight - 1}px,
        rgba(255, 255, 255, ${opacity}) ${lineHeight}px
      )`,
      pointerEvents: 'none'
    }
  };
};

/**
 * Generate noise background pattern
 * @param {number} opacity - Noise opacity
 * @param {string} color - Base color of noise
 * @returns {string} - CSS background property
 */
export const getNoiseBackground = (opacity = 0.05, color = '255, 255, 255') => {
  const noiseDataUrl = `data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='${opacity}'/%3E%3C/svg%3E`;
  
  return `url("${noiseDataUrl}")`;
};

/**
 * Generate a random digital/binary sequence
 * @param {number} length - Length of sequence
 * @returns {string} - Random sequence of 0s and 1s
 */
export const generateBinarySequence = (length = 16) => {
  let result = '';
  for (let i = 0; i < length; i++) {
    result += Math.floor(Math.random() * 2);
  }
  return result;
};

/**
 * Apply CRT TV effect to an element
 * @param {Object} options - CRT effect options
 * @returns {Object} - CSS properties for CRT effect
 */
export const getCRTEffect = ({
  curvature = 4, // Screen curvature amount
  vignette = 0.6, // Vignette darkness
  scanlines = true, // Show scanlines
  noise = true, // Show noise
  flicker = true // Screen flicker
} = {}) => {
  return {
    position: 'relative',
    overflow: 'hidden',
    '&::before': {
      // Curvature effect
      content: '""',
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      background: `radial-gradient(
        ellipse at center,
        transparent 0%,
        rgba(0, 0, 0, ${vignette}) 90%
      )`,
      borderRadius: `${curvature}% / ${curvature * 1.5}%`,
      boxShadow: 'inset 0 0 10px rgba(0, 0, 0, 0.8)',
      pointerEvents: 'none'
    },
    '&::after': scanlines ? {
      // Scanlines
      content: '""',
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      background: `linear-gradient(
        to bottom,
        transparent 50%,
        rgba(0, 0, 0, 0.1) 51%
      )`,
      backgroundSize: '100% 4px',
      pointerEvents: 'none',
      opacity: 0.4,
      animation: flicker ? 'flicker 0.15s infinite alternate' : 'none'
    } : {}
  };
};

// Export all utilities
export default {
  glitchText,
  createRGBSplitText,
  createGlitchClipPath,
  generateGlitchKeyframes,
  getScanlineEffect,
  getNoiseBackground,
  generateBinarySequence,
  getCRTEffect
};
</file>

<file path="frontend/src/utils/terminalCommands.js">
/**
 * Terminal commands utility
 * Contains command definitions, processors, and helpers for terminal interface
 */

// ANSI color codes for terminal text
export const ANSI_COLORS = {
  RESET: '\u001b[0m',
  BLACK: '\u001b[30m',
  RED: '\u001b[31m',
  GREEN: '\u001b[32m',
  YELLOW: '\u001b[33m',
  BLUE: '\u001b[34m',
  MAGENTA: '\u001b[35m',
  CYAN: '\u001b[36m',
  WHITE: '\u001b[37m',
  
  BG_BLACK: '\u001b[40m',
  BG_RED: '\u001b[41m',
  BG_GREEN: '\u001b[42m',
  BG_YELLOW: '\u001b[43m',
  BG_BLUE: '\u001b[44m',
  BG_MAGENTA: '\u001b[45m',
  BG_CYAN: '\u001b[46m',
  BG_WHITE: '\u001b[47m',
  
  BRIGHT_BLACK: '\u001b[30;1m',
  BRIGHT_RED: '\u001b[31;1m',
  BRIGHT_GREEN: '\u001b[32;1m',
  BRIGHT_YELLOW: '\u001b[33;1m',
  BRIGHT_BLUE: '\u001b[34;1m',
  BRIGHT_MAGENTA: '\u001b[35;1m',
  BRIGHT_CYAN: '\u001b[36;1m',
  BRIGHT_WHITE: '\u001b[37;1m',
};

// Common terminal symbols
export const TERMINAL_SYMBOLS = {
  PROMPT: '$',
  SUCCESS: 'âœ“',
  ERROR: 'âœ—',
  WARNING: 'âš ',
  INFO: 'â„¹',
  LOADING: 'â£¾â£½â£»â¢¿â¡¿â£Ÿâ£¯â£·',
  COMMAND: '>',
  CURSOR: 'â–‹',
};

// Available terminal commands
export const AVAILABLE_COMMANDS = [
  'help',
  'clear',
  'about',
  'skills',
  'projects',
  'contact',
  'experience',
  'education',
  'certifications',
  'github',
  'linkedin',
  'resume',
  'echo',
  'whois',
  'ls',
  'date',
  'time',
  'ask',
  'exit',
  'theme',
  'matrix',
  'hack',
  'quote',
  'glitch',
  'ping',
  'netstat',
  'whoami',
  'sys',
  'scan',
  'decrypt',
  'encrypt',
];

// Command descriptions for help command
export const COMMAND_DESCRIPTIONS = {
  help: 'Display available commands',
  clear: 'Clear terminal screen',
  about: 'Display information about me',
  skills: 'List my technical skills',
  projects: 'View my featured projects',
  contact: 'Display contact information',
  experience: 'Show work experience',
  education: 'Display educational background',
  certifications: 'Show earned certifications',
  github: 'Open GitHub profile',
  linkedin: 'Open LinkedIn profile',
  resume: 'View resume information',
  echo: 'Echo text back to terminal',
  whois: 'Display information about the system',
  ls: 'List available sections',
  date: 'Display current date',
  time: 'Display current time',
  ask: 'Ask a question about me (AI-powered)',
  exit: 'Exit terminal mode',
  theme: 'Toggle light/dark theme',
  matrix: 'Display Matrix effect',
  hack: 'Simulate hacking (for fun)',
  quote: 'Display a random cyber quote',
  glitch: 'Apply a glitch effect to the terminal',
  ping: 'Ping a network destination',
  netstat: 'Show network statistics',
  whoami: 'Display current user information',
  sys: 'Show system information',
  scan: 'Scan system for vulnerabilities',
  decrypt: 'Decrypt encrypted text',
  encrypt: 'Encrypt plain text',
};

// Cyberpunk quotes for the quote command
export const CYBER_QUOTES = [
  "The future is already here â€“ it's just not evenly distributed. - William Gibson",
  "Information wants to be free. - Stewart Brand",
  "In the face of ambiguity, refuse the temptation to guess. - The Zen of Python",
  "Any sufficiently advanced technology is indistinguishable from magic. - Arthur C. Clarke",
  "The best way to predict the future is to invent it. - Alan Kay",
  "Security is always excessive until it's not enough. - Robbie Sinclair",
  "Privacy is not something that I'm merely entitled to, it's an absolute prerequisite. - Marlon Brando",
  "The quieter you become, the more you can hear. - Ram Dass",
  "There is no security on this earth; there is only opportunity. - Douglas MacArthur",
  "Simplicity is the ultimate sophistication. - Leonardo da Vinci",
  "The function of good software is to make the complex appear to be simple. - Grady Booch",
  "The only truly secure system is one that is powered off, cast in a block of concrete and sealed in a lead-lined room. - Gene Spafford",
  "The electric light did not come from the continuous improvement of candles. - Oren Harari",
  "We're changing the world with technology. - Bill Gates",
  "Hardware: The parts of a computer that can be kicked. - Jeff Pesis",
  "Cyberspace. A consensual hallucination experienced daily by billions. - William Gibson",
  "The real problem is not whether machines think but whether men do. - B.F. Skinner",
  "The Internet treats censorship as a malfunction and routes around it. - John Perry Barlow",
  "In a world of infinite choice, contextâ€”not contentâ€”is king. - Chris Anderson",
  "It's hardware that makes a machine fast. It's software that makes a fast machine slow. - Craig Bruce"
];

// Random hex codes generator
export const generateRandomHex = (length = 8) => {
  let result = '';
  const characters = 'ABCDEFabcdef0123456789';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
};

// Generate simulated terminal IP address
export const generateRandomIP = () => {
  return `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
};

// Format terminal response
export const formatResponse = (text, type = 'standard') => {
  switch (type) {
    case 'success':
      return `${ANSI_COLORS.BRIGHT_GREEN}${TERMINAL_SYMBOLS.SUCCESS} ${text}${ANSI_COLORS.RESET}`;
    case 'error':
      return `${ANSI_COLORS.BRIGHT_RED}${TERMINAL_SYMBOLS.ERROR} ${text}${ANSI_COLORS.RESET}`;
    case 'warning':
      return `${ANSI_COLORS.BRIGHT_YELLOW}${TERMINAL_SYMBOLS.WARNING} ${text}${ANSI_COLORS.RESET}`;
    case 'info':
      return `${ANSI_COLORS.BRIGHT_CYAN}${TERMINAL_SYMBOLS.INFO} ${text}${ANSI_COLORS.RESET}`;
    case 'command':
      return `${ANSI_COLORS.BRIGHT_CYAN}${TERMINAL_SYMBOLS.COMMAND} ${text}${ANSI_COLORS.RESET}`;
    default:
      return text;
  }
};

// Parse command arguments
export const parseCommand = (commandString) => {
  const parts = commandString.trim().split(' ');
  const command = parts[0].toLowerCase();
  const args = parts.slice(1).join(' ');
  
  return { command, args };
};

// Simulate typing effect text
export const simulateTyping = (element, text, speed = 30) => {
  return new Promise((resolve) => {
    let i = 0;
    const interval = setInterval(() => {
      if (i < text.length) {
        element.textContent += text.charAt(i);
        i++;
      } else {
        clearInterval(interval);
        resolve();
      }
    }, speed);
  });
};

// Format current datetime for terminal
export const formatDateTime = () => {
  const now = new Date();
  return now.toLocaleString('en-US', {
    weekday: 'short',
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });
};

export default {
  ANSI_COLORS,
  TERMINAL_SYMBOLS,
  AVAILABLE_COMMANDS,
  COMMAND_DESCRIPTIONS,
  CYBER_QUOTES,
  generateRandomHex,
  generateRandomIP,
  formatResponse,
  parseCommand,
  simulateTyping,
  formatDateTime
};
</file>

<file path="frontend/src/index.css">
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
</file>

<file path="frontend/src/main.jsx">
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App.jsx'

// Global styles
import './styles/reset.css'
import './styles/base.css'
import './styles/cyberpunk.css'
import './styles/animations.css'
import './styles/glitch.css'
import './styles/responsive.css'

// Audio context setup
import { AudioProvider } from './contexts/AudioContext'
// Theme context setup
import { ThemeProvider } from './contexts/ThemeContext'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <ThemeProvider>
        <AudioProvider>
          <App />
        </AudioProvider>
      </ThemeProvider>
    </BrowserRouter>
  </React.StrictMode>,
)

// Initialize particle effects - we'll make them adjust to FPS capability
window.addEventListener('DOMContentLoaded', () => {
  // Check for performance capability to adjust particle density
  const performanceTest = () => {
    let startTime = performance.now();
    let iterations = 10000000;
    
    // Simple computational load test
    for (let i = 0; i < iterations; i++) {
      Math.sqrt(Math.random());
    }
    
    let endTime = performance.now();
    let duration = endTime - startTime;
    
    // Set performance level in localStorage (1-5 scale)
    let performanceLevel = 5;
    
    if (duration > 500) performanceLevel = 1;
    else if (duration > 300) performanceLevel = 2;
    else if (duration > 200) performanceLevel = 3;
    else if (duration > 100) performanceLevel = 4;
    
    localStorage.setItem('performanceLevel', performanceLevel);
    console.log(`Performance level: ${performanceLevel}`);
  };
  
  performanceTest();
});
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/Dockerfile.dev">
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 5173
CMD ["npm", "run", "dev", "--", "--host", "0.0.0.0"]
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/images/meta-image.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Ultra-futuristic cyberpunk portfolio - A glimpse into the digital future" />
    
    <!-- Preload critical fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Fira+Code:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Meta tags for social sharing -->
    <meta property="og:title" content="Cyberpunk Portfolio" />
    <meta property="og:description" content="Step into the future with this cutting-edge digital experience" />
    <meta property="og:image" content="/images/meta-image.jpg" />
    <meta property="og:url" content="https://carterperez-dev.com" />
    <meta name="twitter:card" content="summary_large_image" />
    
    <title>Carter Perez Portfolio | Digital Frontier</title>
  </head>
  <body>
    <!-- Initial loading overlay -->
    <div id="boot-sequence">
      <div class="boot-content">
        <div class="boot-logo"></div>
        <div class="boot-progress">
          <div class="boot-progress-bar"></div>
        </div>
        <div class="boot-text">INITIALIZING NEURAL INTERFACE</div>
        <div class="boot-version">v2.7.5</div>
      </div>
    </div>

    <div id="root"></div>
    
    <!-- Ambient audio elements (muted by default) -->
    <audio id="ambient-background" loop preload="metadata">
      <source src="/assets/audio/ambient-cyber.mp3" type="audio/mpeg">
    </audio>
    <audio id="ui-sound-hover" preload="metadata">
      <source src="/assets/audio/hover.mp3" type="audio/mpeg">
    </audio>
    <audio id="ui-sound-click" preload="metadata">
      <source src="/assets/audio/click.mp3" type="audio/mpeg">
    </audio>
    
    <script type="module" src="/src/main.jsx"></script>
    
    <!-- Boot sequence simulation -->
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const bootSequence = document.getElementById('boot-sequence');
        const bootProgress = document.querySelector('.boot-progress-bar');
        const bootText = document.querySelector('.boot-text');
        
        const bootMessages = [
          'INITIALIZING NEURAL INTERFACE',
          'CALIBRATING VISUAL CORTEX',
          'LOADING EXPERIENCE MATRIX',
          'ENABLING QUANTUM RENDERING',
          'ESTABLISHING NEURAL UPLINK'
        ];
        
        let msgIndex = 0;
        let progress = 0;
        
        // Simulate boot progress
        const bootInterval = setInterval(() => {
          progress += Math.random() * 5 + 1;
          
          if (progress >= 100) {
            progress = 100;
            clearInterval(bootInterval);
            
            setTimeout(() => {
              bootSequence.style.opacity = 0;
              setTimeout(() => {
                bootSequence.style.display = 'none';
              }, 500);
            }, 500);
          }
          
          bootProgress.style.width = `${progress}%`;
          
          if (progress > (msgIndex + 1) * 20) {
            msgIndex = Math.min(msgIndex + 1, bootMessages.length - 1);
            bootText.innerHTML = bootMessages[msgIndex];
            bootText.classList.add('glitch-text');
            
            setTimeout(() => {
              bootText.classList.remove('glitch-text');
            }, 500);
          }
        }, 150);
      });
    </script>
  </body>
</html>
</file>

<file path="frontend/README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="frontend/vite.config.js">
// frontend/vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [
    react({
      include: '**/*.{jsx,js}',
    })
  ],
  resolve: {
    alias: {
      '@': path.resolve(process.cwd(), './src'), 
    },
  },
  server: {
    host: '0.0.0.0', 
    port: 5173,    
    strictPort: true, 
    allowedHosts: ['localhost'], 
  },

});
</file>

<file path="nginx/sites-enabled/reverse_proxy.conf">
# Inside ./nginx/sites-enabled/your_config_file.conf

server {
    listen 80;
    listen [::]:80;
    server_name _;

    location / {
        # CHANGE THIS LINE: Use the correct service name
        proxy_pass http://frontend_service:5173;

        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
        # Add these standard headers too
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api/ {
        # CHANGE THIS LINE: Use the correct service name
        proxy_pass http://backend_service:5000/; # Keep trailing slash if backend expects it

        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
</file>

<file path="nginx/nginx.conf">
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*.conf;
}
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

.env
</file>

<file path="docker-compose.yaml">
services:
  frontend:
    container_name: frontend_service
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    volumes:
      - ./frontend:/app
      - /app/node_modules    
    ports:
      - "5173:5173"
    networks:
      - portfolio_network
    restart: always 
    command: npm run dev -- --host 0.0.0.0 
    
     
  backend:
    container_name: backend_service
    build:
      context: ./backend
      dockerfile: Dockerfile.backend
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/app
    env_file:
      - .env
    networks:
      - portfolio_network
    restart: always

  nginx:
    container_name: nginx_proxy
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/sites-enabled:/etc/nginx/sites-enabled
    depends_on:
      - frontend
      - backend
    networks:
      - portfolio_network
    restart: unless-stopped

networks:
  portfolio_network:
    driver: bridge
</file>

<file path="README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="frontend/src/components/layout/AmbientBackground.jsx">
import React, { useEffect, useRef, useState } from 'react';
import { useTheme } from '../../contexts/ThemeContext';

const AmbientBackground = () => {
  const canvasRef = useRef(null);
  const { theme } = useTheme();
  const [performanceLevel, setPerformanceLevel] = useState(() => {
    return parseInt(localStorage.getItem('performanceLevel') || '3', 10);
  });

  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Handle resize
    const handleResize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    
    window.addEventListener('resize', handleResize);
    handleResize();
    
    // Colors based on theme - making them more visible (less transparent)
    const primaryColor = theme === 'dark' ? 'rgba(0, 255, 245, 0.8)' : 'rgba(77, 77, 255, 0.8)';
    const secondaryColor = theme === 'dark' ? 'rgba(255, 61, 61, 0.8)' : 'rgba(255, 61, 61, 0.8)';
    const bgColor = theme === 'dark' ? 'rgba(5, 5, 5, 0.85)' : 'rgba(245, 245, 245, 0.85)';
    const gridColor = theme === 'dark' ? 'rgba(0, 255, 245, 0.2)' : 'rgba(77, 77, 255, 0.2)';
    
    // Create grid lines
    const gridLines = [];
    const gridSize = performanceLevel > 1 ? 40 : 60; // Larger grid cells for lower performance
    const cols = Math.ceil(canvas.width / gridSize) + 1; // Add one extra for smooth scrolling
    const rows = Math.ceil(canvas.height / gridSize);
    
    // Horizontal lines
    for (let y = 0; y <= rows; y++) {
      gridLines.push({
        x1: 0,
        y1: y * gridSize,
        x2: canvas.width,
        y2: y * gridSize,
        offset: 0,
        direction: 'horizontal'
      });
    }
    
    // Vertical lines
    for (let x = 0; x <= cols; x++) {
      gridLines.push({
        x1: x * gridSize,
        y1: 0,
        x2: x * gridSize,
        y2: canvas.height,
        offset: 0,
        direction: 'vertical'
      });
    }
    
    // Create moving particles - increasing count
    const particleCount = performanceLevel * 30; // Increased from 20
    const particles = [];
    
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 3 + 1.5, // Increased size
        speedX: (Math.random() - 0.5) * 0.8, // Increased speed
        speedY: (Math.random() - 0.5) * 0.4, // Increased speed
        color: Math.random() > 0.8 ? secondaryColor : primaryColor,
        pulseRate: 0.01 + Math.random() * 0.02,
        pulseOffset: Math.random() * Math.PI * 2,
        connections: []
      });
    }
    
    // Animation parameters
    const gridSpeed = 0.5; // Increased grid movement speed
    let offset = 0;
    
    const render = () => {
      // Clear canvas with slight opacity for trail effect
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Update grid offset
      offset += gridSpeed;
      if (offset >= gridSize) {
        offset = 0;
      }
      
      // Draw grid lines - increased opacity
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      
      for (const line of gridLines) {
        ctx.beginPath();
        
        if (line.direction === 'horizontal') {
          ctx.moveTo(line.x1, line.y1);
          ctx.lineTo(line.x2, line.y2);
        } else {
          // Move vertical lines for scrolling effect
          const x = line.x1 - offset;
          ctx.moveTo(x, line.y1);
          ctx.lineTo(x, line.y2);
        }
        
        ctx.stroke();
      }
      
      // Reset particle connections
      particles.forEach(particle => {
        particle.connections = [];
      });
      
      // Update particles
      for (const particle of particles) {
        // Update position
        particle.x += particle.speedX;
        particle.y += particle.speedY;
        
        // Pulse effect
        particle.pulseOffset += particle.pulseRate;
        const pulseFactor = 0.7 + Math.sin(particle.pulseOffset) * 0.3;
        
        // Wrap around edges
        if (particle.x < 0) particle.x = canvas.width;
        if (particle.x > canvas.width) particle.x = 0;
        if (particle.y < 0) particle.y = canvas.height;
        if (particle.y > canvas.height) particle.y = 0;
        
        // Draw particle
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size * pulseFactor, 0, Math.PI * 2);
        ctx.fillStyle = particle.color;
        ctx.fill();
        
        // Add glow effect to particles
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
        const glowColor = particle.color.replace('0.8)', '0.2)');
        ctx.fillStyle = glowColor;
        ctx.fill();
        
        // Find connections to nearby particles
        if (performanceLevel > 1) { // Reduced requirement so more devices show connections
          for (const otherParticle of particles) {
            if (particle === otherParticle) continue;
            
            const dx = particle.x - otherParticle.x;
            const dy = particle.y - otherParticle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 120) { // Increased connection distance
              // Avoid duplicate connections
              if (!particle.connections.includes(otherParticle) && 
                  !otherParticle.connections.includes(particle)) {
                particle.connections.push(otherParticle);
                
                // Draw connection
                ctx.beginPath();
                ctx.moveTo(particle.x, particle.y);
                ctx.lineTo(otherParticle.x, otherParticle.y);
                
                // Fade opacity based on distance, but higher base opacity
                const opacity = 0.2 + (1 - distance / 120) * 0.4;
                ctx.strokeStyle = theme === 'dark' 
                  ? `rgba(0, 255, 245, ${opacity})` 
                  : `rgba(77, 77, 255, ${opacity})`;
                ctx.lineWidth = 1.5; // Thicker lines
                ctx.stroke();
              }
            }
          }
        }
      }
    };
    
    // Animation loop
    let animationId;
    const animate = () => {
      render();
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Clean up
    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(animationId);
    };
  }, [theme, performanceLevel]);

  return (
    <canvas
      ref={canvasRef}
      className="ambient-background"
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        zIndex: -10,
        pointerEvents: 'none'
      }}
    />
  );
};

export default AmbientBackground;
</file>

<file path="frontend/src/components/sections/HeroSection.jsx">
import React, { useRef, useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { Link } from 'react-router-dom';
import { useAudio } from '../../contexts/AudioContext';

const HeroSection = () => {
  const { playSound } = useAudio();
  const canvasRef = useRef(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [isLoaded, setIsLoaded] = useState(false);
  
  // Typewriter effect for subtitle
  const [subtitle, setSubtitle] = useState('');
  const fullSubtitle = 'CYBERSECURITY SPECIALIST | SYSTEM INTEGRATOR | FULL-STACK DEVELOPER';
  
  // Holographic cube animation
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    const setCanvasDimensions = () => {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };
    
    window.addEventListener('resize', setCanvasDimensions);
    setCanvasDimensions();
    
    // Cube parameters - increased size by 30%
    const cube = {
      size: Math.min(canvas.width, canvas.height) * 0.26, // Increased from 0.2
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0,
      position: { x: canvas.width / 2, y: canvas.height / 2, z: 0 },
      vertices: [],
      edges: [
        [0, 1], [1, 2], [2, 3], [3, 0], // Bottom face
        [4, 5], [5, 6], [6, 7], [7, 4], // Top face
        [0, 4], [1, 5], [2, 6], [3, 7]  // Connecting edges
      ],
      calculateVertices: function() {
        const s = this.size / 2;
        
        // Define the 8 vertices of the cube
        return [
          // Bottom face
          { x: -s, y: -s, z: -s },
          { x: s, y: -s, z: -s },
          { x: s, y: -s, z: s },
          { x: -s, y: -s, z: s },
          // Top face
          { x: -s, y: s, z: -s },
          { x: s, y: s, z: -s },
          { x: s, y: s, z: s },
          { x: -s, y: s, z: s }
        ];
      }
    };
    
    // Initialize vertices
    cube.vertices = cube.calculateVertices();
    
    // Project 3D point to 2D
    const project = (point) => {
      const focalLength = 300;
      const scale = focalLength / (focalLength + point.z + cube.position.z);
      
      return {
        x: point.x * scale + cube.position.x,
        y: point.y * scale + cube.position.y
      };
    };
    
    // Rotate point around X axis
    const rotateX = (point, angle) => {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      
      return {
        x: point.x,
        y: point.y * cos - point.z * sin,
        z: point.y * sin + point.z * cos
      };
    };
    
    // Rotate point around Y axis
    const rotateY = (point, angle) => {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      
      return {
        x: point.x * cos + point.z * sin,
        y: point.y,
        z: -point.x * sin + point.z * cos
      };
    };
    
    // Rotate point around Z axis
    const rotateZ = (point, angle) => {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      
      return {
        x: point.x * cos - point.y * sin,
        y: point.x * sin + point.y * cos,
        z: point.z
      };
    };
    
    // Animation loop
    let animationId;
    const animate = () => {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update rotations
      cube.rotationX += 0.005;
      cube.rotationY += 0.007;
      cube.rotationZ += 0.003;
      
      // Calculate rotated and projected vertices
      const rotatedVertices = cube.vertices.map(vertex => {
        let rotated = { ...vertex };
        rotated = rotateX(rotated, cube.rotationX);
        rotated = rotateY(rotated, cube.rotationY);
        rotated = rotateZ(rotated, cube.rotationZ);
        
        return rotated;
      });
      
      const projectedVertices = rotatedVertices.map(vertex => project(vertex));
      
      // Draw edges
      ctx.strokeStyle = 'rgba(0, 255, 245, 0.5)';
      ctx.lineWidth = 2;
      
      for (const [i, j] of cube.edges) {
        const v1 = projectedVertices[i];
        const v2 = projectedVertices[j];
        
        ctx.beginPath();
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
        ctx.stroke();
      }
      
      // Draw vertices
      ctx.fillStyle = 'rgba(255, 61, 61, 0.7)';
      
      for (const vertex of projectedVertices) {
        ctx.beginPath();
        ctx.arc(vertex.x, vertex.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw holographic effect
      ctx.strokeStyle = 'rgba(0, 255, 245, 0.2)';
      ctx.beginPath();
      
      for (let i = 0; i < projectedVertices.length; i++) {
        const v1 = projectedVertices[i];
        const v2 = projectedVertices[(i + 1) % projectedVertices.length];
        
        ctx.moveTo(v1.x, v1.y);
        ctx.lineTo(v2.x, v2.y);
      }
      
      ctx.stroke();
      
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Clean up
    return () => {
      window.removeEventListener('resize', setCanvasDimensions);
      cancelAnimationFrame(animationId);
    };
  }, []);
  
  // Typewriter effect
  useEffect(() => {
    if (subtitle === fullSubtitle) return;
    
    const timeoutId = setTimeout(() => {
      setSubtitle(fullSubtitle.substring(0, subtitle.length + 1));
    }, 50);
    
    return () => clearTimeout(timeoutId);
  }, [subtitle, fullSubtitle]);
  
  // Mouse parallax effect
  useEffect(() => {
    const handleMouseMove = (e) => {
      setMousePosition({
        x: (e.clientX / window.innerWidth - 0.5) * 2,
        y: (e.clientY / window.innerHeight - 0.5) * 2
      });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, []);
  
  // Set loaded state after a delay
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      setIsLoaded(true);
    }, 800);
    
    return () => clearTimeout(timeoutId);
  }, []);
  
  // Animation variants
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        delay: 0.3,
        when: 'beforeChildren',
        staggerChildren: 0.1
      }
    }
  };
  
  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { type: 'spring', stiffness: 100 }
    }
  };
  
  return (
    <section className="hero-section">
      <div className="hero-background"></div>
      
      <motion.div
        className="hero-content"
        variants={containerVariants}
        initial="hidden"
        animate={isLoaded ? 'visible' : 'hidden'}
      >
        <div className="hero-left">
          <motion.h1 
            className="hero-title" 
            variants={itemVariants}
            data-text="NEURAL INTERFACE"
          >
            <span className="title-main">NEURAL</span>
            <span className="title-accent">INTERFACE</span>
          </motion.h1>
          
          <motion.div 
            className="hero-subtitle" 
            variants={itemVariants}
          >
            {subtitle}
            <span className="blinking-cursor"></span>
          </motion.div>
          
          <motion.p 
            className="hero-description" 
            variants={itemVariants}
          >
            Welcome to my digital nexus. I craft secure systems, develop full-stack applications, and specialize in cybersecurity solutions. Navigate through my digital portfolio to discover my projects, skills, and experiences.
          </motion.p>
          
          <motion.div 
            className="hero-cta" 
            variants={itemVariants}
          >
            <Link 
              to="/projects" 
              className="cyber-button"
              onClick={() => playSound('click')}
            >
              VIEW PROJECTS
            </Link>
            
            <Link 
              to="/contact" 
              className="cyber-button cyber-button--magenta"
              onClick={() => playSound('click')}
            >
              CONNECT
            </Link>
          </motion.div>
        </div>
        
        <motion.div 
          className="hero-right"
          variants={itemVariants}
          style={{
            transform: `translate(${mousePosition.x * -20}px, ${mousePosition.y * -20}px)`
          }}
        >
          <div className="hologram-container">
            <div className="hologram-frame"></div>
            <canvas 
              ref={canvasRef} 
              className="hologram-canvas"
              aria-hidden="true"
            ></canvas>
          </div>
        </motion.div>
      </motion.div>
      
      <style jsx>{`
        .hero-section {
          min-height: 100vh;
          display: flex;
          align-items: center;
          justify-content: center;
          position: relative;
          overflow: hidden;
          padding: var(--space-xxl) 0;
        }
        
        .hero-background {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: linear-gradient(135deg, rgba(10, 10, 10, 0.9), rgba(20, 20, 20, 0.95));
          z-index: -1;
        }
        
        .hero-background::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: 
            radial-gradient(circle at 20% 30%, rgba(0, 255, 245, 0.05) 0%, transparent 30%),
            radial-gradient(circle at 80% 70%, rgba(255, 61, 61, 0.05) 0%, transparent 30%);
        }
        
        .hero-content {
          display: flex;
          align-items: center;
          justify-content: space-between;
          max-width: var(--container-lg);
          margin: 0 auto;
          width: 100%;
          padding: 0 var(--space-md);
          z-index: 1;
        }
        
        .hero-left {
          flex: 1;
          max-width: 600px;
          padding-right: var(--space-xl);
        }
        
        .hero-title {
          font-size: 4rem;
          font-weight: 900;
          margin-bottom: var(--space-md);
          line-height: 1.1;
          position: relative;
          display: inline-block;
        }
        
        .title-main {
          display: block;
          color: var(--text-primary);
        }
        
        .title-accent {
          display: block;
          color: var(--accent-cyan);
          text-shadow: 0 0 10px rgba(0, 255, 245, 0.5);
          position: relative;
        }
        
        .title-accent::before {
          content: 'INTERFACE';
          position: absolute;
          top: 0;
          left: 0;
          color: var(--accent-magenta);
          filter: blur(4px);
          opacity: 0.7;
          animation: title-glitch 5s infinite alternate;
        }
        
        .hero-subtitle {
          font-family: var(--font-mono);
          font-size: 1rem;
          margin-bottom: var(--space-lg);
          color: var(--text-secondary);
          letter-spacing: 1px;
        }
        
        .blinking-cursor {
          display: inline-block;
          width: 10px;
          height: 1rem;
          background-color: var(--accent-cyan);
          animation: blink 1s step-end infinite;
          margin-left: 2px;
          vertical-align: middle;
        }
        
        .hero-description {
          font-size: 1.1rem;
          margin-bottom: var(--space-xl);
          color: var(--text-secondary);
          line-height: 1.6;
        }
        
        .hero-cta {
          display: flex;
          gap: var(--space-md);
        }
        
        .hero-right {
          flex: 1;
          display: flex;
          justify-content: center;
          align-items: center;
          position: relative;
        }
        
        .hologram-container {
          width: 350px;
          height: 350px;
          position: relative;
          display: flex;
          justify-content: center;
          align-items: center;
        }
        
        .hologram-frame {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border: 2px solid var(--accent-cyan);
          box-shadow: 0 0 20px rgba(0, 255, 245, 0.3);
          z-index: 2;
          pointer-events: none;
        }
        
        .hologram-frame::before,
        .hologram-frame::after {
          content: '';
          position: absolute;
          background-color: var(--accent-cyan);
        }
        
        .hologram-frame::before {
          top: 10px;
          right: 10px;
          width: 20px;
          height: 2px;
        }
        
        .hologram-frame::after {
          top: 10px;
          right: 10px;
          width: 2px;
          height: 20px;
        }
        
        .hologram-canvas {
          width: 100%;
          height: 100%;
        }
        
        @keyframes blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0; }
        }
        
        @keyframes title-glitch {
          0%, 100% {
            transform: translate(0);
            opacity: 0.7;
          }
          20% {
            transform: translate(-2px, 2px);
            opacity: 0.5;
          }
          40% {
            transform: translate(2px, -2px);
            opacity: 0.7;
          }
          60% {
            transform: translate(-2px, -2px);
            opacity: 0.5;
          }
          80% {
            transform: translate(2px, 2px);
            opacity: 0.7;
          }
        }
        
        /* Media queries */
        @media (max-width: 1024px) {
          .hero-title {
            font-size: 3.5rem;
          }
          
          .hologram-container {
            width: 300px;
            height: 300px;
          }
        }
        
        @media (max-width: 768px) {
          .hero-content {
            flex-direction: column;
            text-align: center;
          }
          
          .hero-left {
            padding-right: 0;
            margin-bottom: var(--space-xl);
          }
          
          .hero-cta {
            justify-content: center;
          }
          
          .hero-title {
            font-size: 3rem;
          }
        }
        
        @media (max-width: 480px) {
          .hero-title {
            font-size: 2.5rem;
          }
          
          .hero-subtitle {
            font-size: 0.9rem;
          }
          
          .hero-description {
            font-size: 1rem;
          }
          
          .hero-cta {
            flex-direction: column;
            width: 100%;
          }
          
          .hologram-container {
            width: 250px;
            height: 250px;
          }
        }
      `}</style>
    </section>
  );
};

export default HeroSection;
</file>

<file path="frontend/src/App.jsx">
import { useState, useEffect, Suspense, lazy } from 'react'
import { Routes, Route, useLocation } from 'react-router-dom'
import { AnimatePresence } from 'framer-motion'

// Contexts
import { useTheme } from './contexts/ThemeContext'
import { useAudio } from './contexts/AudioContext'

// Layouts
import HolographicNav from './components/layout/HolographicNav'
import DigitalFooter from './components/layout/DigitalFooter'
import AmbientBackground from './components/layout/AmbientBackground'
import CyberLoader from './components/common/CyberLoader'


// Eager loaded components
import HeroSection from './components/sections/HeroSection'

// Lazy loaded components for code splitting
const ProjectsGrid = lazy(() => import('./components/sections/ProjectsGrid'))
const HolographicTimeline = lazy(() => import('./components/sections/HolographicTimeline'))
const TechStackGalaxy = lazy(() => import('./components/sections/TechStackGalaxy'))
const AITerminal = lazy(() => import('./components/sections/AITerminal'))
const ContactPortal = lazy(() => import('./components/sections/ContactPortal'))
const ResumeHologram = lazy(() => import('./components/sections/ResumeHologram'))

function App() {
  const location = useLocation()
  const { theme } = useTheme()
  const { initializeAudio } = useAudio()
  const [isLoading, setIsLoading] = useState(true)
  
  // Simulating content loading
  useEffect(() => {
    // Wait for boot sequence to complete in index.html
    const bootSequence = document.getElementById('boot-sequence')
    
    const checkBoot = () => {
      if (bootSequence && bootSequence.style.display === 'none') {
        // Boot sequence completed, now load the main app with a delay
        setTimeout(() => {
          setIsLoading(false)
          // Initialize audio after user interaction
          window.addEventListener('click', initializeAudio, { once: true })
        }, 500)
      } else {
        setTimeout(checkBoot, 100) // Check again in 100ms
      }
    }
    
    checkBoot()
    
    // Clean up
    return () => {
      window.removeEventListener('click', initializeAudio)
    }
  }, [initializeAudio])
  
  // Custom cursor effect
  useEffect(() => {
    const cursor = document.createElement('div')
    cursor.className = 'cyber-cursor'
    document.body.appendChild(cursor)
    
    const cursorDot = document.createElement('div')
    cursorDot.className = 'cyber-cursor-dot'
    document.body.appendChild(cursorDot)
    
    const moveCursor = (e) => {
      cursor.style.left = `${e.clientX}px`
      cursor.style.top = `${e.clientY}px`
      
      cursorDot.style.left = `${e.clientX}px`
      cursorDot.style.top = `${e.clientY}px`
    }
    
    window.addEventListener('mousemove', moveCursor)
    
    // Interactive elements cursor effect
    const handleMouseEnter = () => {
      cursor.classList.add('expand')
    }
    
    const handleMouseLeave = () => {
      cursor.classList.remove('expand')
    }
    
    const interactiveElements = document.querySelectorAll('a, button, input, select, textarea, [role="button"]')
    interactiveElements.forEach(el => {
      el.addEventListener('mouseenter', handleMouseEnter)
      el.addEventListener('mouseleave', handleMouseLeave)
    })
    
    return () => {
      window.removeEventListener('mousemove', moveCursor)
      document.body.removeChild(cursor)
      document.body.removeChild(cursorDot)
      
      interactiveElements.forEach(el => {
        el.removeEventListener('mouseenter', handleMouseEnter)
        el.removeEventListener('mouseleave', handleMouseLeave)
      })
    }
  }, [])
  
  if (isLoading) {
    return <CyberLoader />
  }
  
  return (
    <div className={`app-container ${theme}-theme`}>
      <AmbientBackground />
      
      <HolographicNav />
      
      <main className="main-content">
        <AnimatePresence mode="wait">
          <Routes location={location} key={location.pathname}>
            <Route 
              path="/" 
              element={
                <>
                  <HeroSection />
                  <Suspense fallback={<CyberLoader />}>
                    <ProjectsGrid />
                    <TechStackGalaxy />
                    <HolographicTimeline />
                  </Suspense>
                </>
              } 
            />
            <Route 
              path="/projects" 
              element={
                <Suspense fallback={<CyberLoader />}>
                  <ProjectsGrid fullPage={true} />
                </Suspense>
              } 
            />
            <Route 
              path="/experience" 
              element={
                <Suspense fallback={<CyberLoader />}>
                  <HolographicTimeline fullPage={true} />
                </Suspense>
              } 
            />
            <Route 
              path="/tech-stack" 
              element={
                <Suspense fallback={<CyberLoader />}>
                  <TechStackGalaxy fullPage={true} />
                </Suspense>
              } 
            />
            <Route 
              path="/terminal" 
              element={
                <Suspense fallback={<CyberLoader />}>
                  <AITerminal />
                </Suspense>
              } 
            />
            <Route 
              path="/contact" 
              element={
                <Suspense fallback={<CyberLoader />}>
                  <ContactPortal />
                </Suspense>
              } 
            />
            <Route 
              path="/resume" 
              element={
                <Suspense fallback={<CyberLoader />}>
                  <ResumeHologram />
                </Suspense>
              } 
            />
          </Routes>
        </AnimatePresence>
      </main>
      
      <DigitalFooter />
    </div>
  )
}

export default App
</file>

<file path="frontend/package.json">
{
  "name": "carter-perez-devs",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@react-three/drei": "^10.0.7",
    "@react-three/fiber": "^9.1.2",
    "framer-motion": "^12.9.4",
    "gsap": "^3.13.0",
    "phosphor-react": "^1.4.1",
    "prop-types": "^15.8.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-router-dom": "^7.5.3",
    "react-tsparticles": "^2.12.2",
    "three": "^0.176.0",
    "tsparticles": "^3.8.1",
    "xterm": "^5.3.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@types/react": "^19.0.10",
    "@types/react-dom": "^19.0.4",
    "@vitejs/plugin-react": "^4.4.1",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "vite": "^6.3.1"
  }
}
</file>

</files>
